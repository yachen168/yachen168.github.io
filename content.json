{"pages":[{"title":"About","text":"","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Project","text":"","link":"/project/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"CSS 原理 - Collapsing margins","text":"什麼是 Collapsing margins？ 先來看一段 W3C 規範 的敘述： In CSS, the adjoining margins of two or more boxes (which might or might not be siblings) can combine to form a single margin. Margins that combine this way are said to collapse, and the resulting combined margin is called a collapsed margin. 簡單來說，當相鄰(adjoining)的 margin 相遇時，若合併成一個 margin，這種情況稱為 Collapsing margins。其中，W3C 對於相鄰(adjoining)的定義為： 僅發生於垂直方向 皆為在文檔流中(in flow)的塊級元素(block-level)元素，且參與同一個塊格式化上下文(block formatting context，BFC)。 例如，若是元素會創建新的 BFC，像是根元素 &lt;html&gt; 、float、position: absolute…等等，該元素就不會有 margin collapsing，至於什麼情況下會創建新的 BFC，可參考 MDN-block formatting context。 什麼時候會發生 margin collapsing？ margin collapsing 可分為兩種情況，一種是同層元素之間，另一種是元素與其父(母)容器之間，但並非所有 block-level 元素皆會發生 margin collapsing，而是有前提條件的。 (一) 相鄰的兄弟姊妹 同層且相鄰的 block 元素的 margin-bottom 與 margin-top 相遇時，發生重疊，僅發生於垂直方向。 前提條件： block 須符合相鄰(adjoining)的定義： 皆為在文檔流中(in flow)的塊級元素(block-level)元素，且參與同一個塊格式化上下文(BFC)。 例如：兩個相鄰的 block 元素，紅色 block 的 margin-bottom = 30px，黑色 block 的 margin-top = 30px，最終兩個 block 元素之間的距離為 30px，而非 60px。 範例連結 12&lt;div class=\"block1\"&gt;我有 margin-bottom：30px&lt;/div&gt;&lt;div class=\"block2\"&gt;我有 margin-top：30px&lt;/div&gt; 123456789.block1 { margin-bottom: 30px; background-color: red;}.block2 { margin-bottom: 30px; background-color: black;} (二) 容器與其第一個/最後一個子元素 亦僅發生於垂直方向，且有其前提條件。 前提條件: 皆為在文檔流中(in flow)的塊級元素(block-level)元素，且參與同一個塊格式化上下文(BFC)。 容器無設定邊框(border)、內距(padding)或加上 clear-fix 的屬性。 例如： 虛線為容器的 outline，紅色區塊為容器內的第一個子元素，現在子元素頂部緊貼著容器頂部。若想利用 margin-top 屬性，讓子元素的頂部距離容器頂部 50px。 結果會發現，子元素的頂部並沒有與容器頂部分離！ 範例連結 123&lt;div class=\"container\"&gt; &lt;div class=\"first_child\"&gt;容器中的第一個子元素&lt;/div&gt;&lt;/div&gt; 123.first_child { margin-top: 50px;} 打開開發人員工具檢視一下，會發現子元素的 margin-top 竟然跑出容器外了，這結果與直接在父容器上設定 margin-top: 50px 是一樣的。 解決方法： 使其不再符合前提條件，例如不再是 block 或是創建 BFC。 margin 計算方式 當發生 margin collapsing 時，由於外距(margin)可為負數，故會有三種情況： 兩個 margin 皆為正 ⇒ 取大值 一個 margin 為正，一個 margin 為負 ⇒ 相加 兩個 margin 皆為負 ⇒ 取最小 (最負) 參考資料 W3C - Collapsing Margins W3C - Box Model MDN - Mastering margin collapsing MDN - Block formatting context","link":"/article/Collapsing-margins.html"},{"title":"CSS 原理 - Block Formatting Context","text":"或許你沒聽過 Block Formatting Context，但你肯定有用過！其實在切版時，常常會使用到 BFC，只是你沒有意識到而已，如果能夠有意識的使用 BFC，對於版面的掌控非常有幫助。 什麼是 Block Formatting Context 如同上一篇 CSS 原理 - Formatting Context 所說，Formatting Context 指的是佈局環境，而佈局環境有許多種，不同的佈局環境會有不同的佈局規則，Block Formatting Context (BFC)是其中一種。 下方為一段 W3C 對於 BFC 的敘述： In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse. In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). 簡單來說，處在同一個 BFC 中的元素(盒子)，會有以下現象： 元素(盒子)從其 containing block(包含塊)的頂部開始，一個接一個呈現垂直排列。 若書寫方向為預設的由左至右，則元素(盒子)會貼齊其 containing block(包含塊)左側。 相鄰元素(盒子)之間的垂直距離，由元素的 margin 屬性決定。 相鄰的 block-level box(塊級盒子)垂直方向會發生 margin collapsing(邊距重疊)。 圖示 將上述現象用圖形表示： 1234567&lt;html&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 首先，&lt;html&gt; 會建立一個 BFC (先破梗了)，而 &lt;body&gt; 與三個 &lt;div&gt; 參與的是 &lt;html&gt; 建立的 BFC，也就是說， &lt;body&gt; 與三個 &lt;div&gt; 處於同一個 BFC 中，因此元素會： 呈現垂直排列。 可以用 margin 來推開彼此。 垂直方向會發生 margin collapsing(邊距重疊)，其中 margin collapsing 又分為兩種(同層元素間以及元素與其容器間)，可參考先前文章 CSS 原理 - Collapsing margins。 注意，以上現象強調的是處於同一個 BFC 裡的元素(盒子)，若元素自立門戶創建新的 BFC，則不完全適用，所以了解什麼情況會建立新的 BFC 很重要。 何時會建立 BFC 對於「什麼時候會建立一個 BFC」，其實 W3C 並沒有一個非常正式的定義，有些條件是非常不嚴謹的，而在 MDN 上則有逐一詳細列出，可供參考。 根據 MDN，以下情況的元素會創建 Block Formatting Context(BFC)： &lt;html&gt; float 元素 position: absolute、fixed 的元素 overflow: hidden、scroll、auto 的元素 display: inline-block 的元素 display: flow-root 的元素 display: flex 或 inline-flex 元素的直接子元素，即 flex items display: grid 或 inline-grid 元素的直接子元素，即 grid items display: table、table-caption、table-cell、table-rowtable-row-group、table-header-group、table-footer-groupinline-table contain: layout、content 或 paint 的元素 column-count 或 column-width 不為 auto 的元素 column-span 為 all 的元素 BFC 功用 可以解決： float 元素的外層容器塌陷問題。 元素間的 margin collapsing(外邊距重疊)問題 float 元素與其他元素的重疊問題 (float 元素遮住其他元素)。 解決 float 元素造成外容器塌陷問題 float 元素會導致外層容器的高度塌陷(若外層容器高度為 auto 且無其它比 float 元素高的子元素)。 例如：範例連結 1234&lt;div class=\"container\"&gt; &lt;span&gt;我是裝著 float 元素的容器&lt;/span&gt; &lt;div class=\"float\"&gt;我是 float 元素&lt;/div&gt;&lt;/div&gt; 1234567891011121314.container { width: 600px; background-color: grey; border: 5px solid #333;}.float { float: left; width: 200px; height: 150px; background-color: yellow; border:1px solid black; padding: 10px;} 此時可以使外層容器建立 BFC 來恢復高度，例如在外層容器加上 overflow: hidden 或 display: flow-root。 123.container{ display: flow-root;} 登愣～外層容器撐開了。 解決 margin collapsing 問題 當元素與元素之間發生 margin collapsing 時，可使元素建立 BFC 來解決 margin collapsing 的問題。 解決 float 元素遮住其他元素的問題 在先前文章 CSS 原理 - Line box 曾提到，float 元素會擠壓 line box，除此之外，float 元素還可能遮住其它元素！ 如果你有用過 float，應該有遇過 float 元素遮住其它非 float 元素的情況，例如： 12&lt;div class=\"float\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt; 12345678910111213.float{ float: left; width: 200px; height: 200px; background-color: orange;}.box{ display: block; width: 300px; height: 300px; background-color: yellow;} 橘色的 float 元素蓋住了黃色元素。 只要讓黃色元素建立 BFC 即可解決重疊問題，例如加上 overflow: hidden 或 display: flow-root。 123.box{ display: flow-root;} 參考資源 W3C-Appendix A: Glossary W3C-Box Layout Modes: the display property W3C-Collapsing margins MDN-Block formatting context","link":"/article/Block-formatting-context.html"},{"title":"CSS 原理 - Containing block","text":"Containing block，中文常被翻譯為包含塊，它其實代表的是一個「區域」，一個由 box model 的 content edge 或 padding edge (若有設定 padding)所圍繞的範圍，它攸關元素的定位、寬高、內距與外距的計算，所以必須清楚知道元素的 containing block 是誰，才不會使畫面失控。 例如，在元素設定 width、height、padding、margin 屬性時，若屬性值給予的單位為百分比(％)，則將會以該元素的 containing block 為基準去做計算，再例如，元素的 position定位，也與該元素的 containing block 有關。 如何尋找包含塊： 一個容易犯的錯誤是直接將元素的「父層」視為該元素的 containing block，事實上，在有些情況下並非如此，像是 position: absolute 與 fixed 時。大致情況如下： 根元素 &lt;html&gt; 的 containing block 稱為 initial containing block (初始包含塊)，而在連續媒體下，initial containing block 即為 viewport (視口)。 若元素的 position 屬性值為 static、relative 或 sticky，則 containing block 為距離該元素最近的祖先 block container 或 formatting context (格式化上下文)的 contnet edge (內容區邊緣)組成。 其中，block container 並不完全等於 display: block，像是 display: inline-block 與 list-item 也會形成 block container，這部分有興趣可參考 W3C display 表格。 至於 formatting context ，其實它只是一個「環境」，大致可分為幾種環境，像是 block formatting context、flex formatting context 或 grid formatting context，之後有機會再介紹。 若元素 position 屬性值為 absolute，則其 containing block 為距離它最近且 position 屬性值非 static（即為 fixed、absolute、relative 或 sticky）的祖先元素的 padding edge(內距邊緣)組成。 若元素 position 屬性值為 fixed，則其 containing block 在連續媒體下為 viewport。 如果 position 屬性值為 absolute 或 fixed，containing block 也可能是由滿足以下條件的最接近祖先元素的內容區邊緣組成： transform 或 perspective 屬性值不為 none。 filter 屬性值不為 none。 來看幾個例子吧 例 1. 找出 &lt;p&gt; 的包含塊，並且計算出 &lt;p&gt; 最終的寬、高、內距與外距。 在此例子中，因為 &lt;p&gt; 的 position 值為預設的 static，故其包含塊為距離它最近的 block container 的 padding edge(內距邊緣)所圍繞範圍，又因 &lt;p&gt; 的 width、 height、margin 與 padding 單位皆為百分比(%)，所以會以 containing block，即 &lt;section&gt; 為基準來計算。 12345&lt;body&gt; &lt;section&gt; &lt;p&gt;This is a paragraph!&lt;/p&gt; &lt;/section&gt;&lt;/body&gt; 123456789101112section { display: block; width: 400px; height: 160px;}p { width: 50%; /* == 400px * .5 = 200px */ height: 25%; /* == 160px * .25 = 40px */ margin: 5%; /* == 400px * .05 = 20px */ padding: 5%; /* == 400px * .05 = 20px */} 例 2. 現在將 &lt;section&gt; 改為 display: inline。 找出 &lt;p&gt; 的包含塊，並且計算出 &lt;p&gt; 最終的寬度。 在此例子中，&lt;p&gt; 的 position 依舊是預設的 static，但是 &lt;section&gt; 不再是 block container，沒有形成一個格式化上下文，故 &lt;p&gt; 的包含塊為 &lt;body&gt; 內距邊緣所圍範圍。 &lt;p&gt; 的寬度將以 &lt;body&gt; 為基準計算。 12345&lt;body&gt; &lt;section&gt; &lt;p&gt;This is a paragraph!&lt;/p&gt; &lt;/section&gt;&lt;/body&gt; 12345678section { display: inline;}p { width: 50%; /* == half the &lt;body&gt;'s width */ height: 200px; /* Note: a percentage would be 0 */} 例 3. 包含塊有內距(padding)。 找出 &lt;p&gt; 的包含塊，並且計算出 &lt;p&gt; 的最終寬度、高度、外距與內距。 在此例中，P元素的包含塊是 &lt;section&gt;，因為 &lt;section&gt; 的 position 值非 static。 &lt;p&gt; 百分值會受其包含塊 &lt;section&gt; 的 padding 所影響。若將包含塊的 box-sizing 值設置為 border-box，就可以避免這個問題。 12345&lt;body&gt; &lt;section&gt; &lt;p&gt;This is a paragraph!&lt;/p&gt; &lt;/section&gt;&lt;/body&gt; 12345678910111213141516section { position: absolute; left: 30px; top: 30px; width: 400px; height: 160px; padding: 30px 20px;}p { position: absolute; width: 50%; /* == (400px + 20px + 20px) * 50% = 220px */ height: 25%; /* == (160px + 30px + 30px) * 25% = 55px */ margin: 5%; /* == (400px + 20px + 20px) * 5% = 22px */ padding: 5%; /* == (400px + 20px + 20px) * 5% = 22px */} 參考資源 W3C-Containing blocks MDN-Layout and the containing block 每天來點 CSS Specification-Visual Formatting Model - 定義、containing block","link":"/article/Containing-block.html"},{"title":"CSS 原理 - Flex(上)","text":"接下來將介紹 flex，從先前 formatting context 的觀念開始，再詳細介紹每個屬性的用法以及 flex box 伸縮的計算方式。 display: flex | inline-flex flex container 顧名思義就是一個容器(container)，描述 flex 元素與其後裔元素之間的關係，當對一個元素設定 display: flex 時，此元素稱為 flex container，而其直接子元素則稱為 flex item。 display: flex 的元素會生成 block-level box 與 flex container，所以該元素本身會參與 BFC 佈局，呈現垂直排列，另一方面，為其內容建立 FFC。 display: inline-flex 的元素會生成 inline-level box 與 flex container，所以該元素本身會參與 IFC 佈局，且會為其內容建立 FFC。 flex container display 為 flex 或 inline-flex 的元素。 flex container 會建立 flex formatting contex(FFC)，所以此元素不會與 float 元素重疊。 column-* 屬性不適用。 flex item display 為 flex 或 inline-flex 元素的子元素稱為 flex item。 建立 BFC，所以 flex items 之間不會發生 margin collapsing，也不會與其父元素(flex container)發生 margin collapsing。 參與 FFC。 vertical-align 不適用。 float 與 clear 不適用。 即使 flex item 是 display: inline 的元素，仍然可以透過 width 與 height 屬性調整寬高。因 flex item 是 blockified。 主軸(main axis)與副軸(cross axis) flex items 可以透過 flex-direction 屬性來決定排列方向，flex-direction 同時也會決定主軸(main axis)與副軸(cross axis)。 圖片來源：W3C flex-direction 共有四個屬性值，會受到書寫方向 writing-mode 影響。 以橫向且由左至右的書寫方式來說，此時 row 為橫向，column 為直向。 flex-direction: row 主軸為 row 方向。 副軸為 column 方向。 由 main start 至 main end 排列。 flex-direction: row-reverse 主軸為 row 方向。 副軸為 column 方向。 由 main end 至 main start 排列。 flex-direction: column 主軸為 column 方向。 副軸為 row 方向。 由 main start 至 main end 排列。 flex-direction:column-reverse 主軸為 column 方向。 副軸為 row 方向。 由 main end 至 main start 排列。 flex-wrap flex-wrap 屬性適用於 flex container，有 nowrap、wrap 與 wrap-reverse 三種屬性值。 圖片來源：W3C nowrap 1flex-wrap: nowrap 不換行，為預設值。 wrap 1flex-wrap: wrap; 換行，由 cross start 開始向 cross end 堆疊。 wrap-reverse 1flex-wrap: wrap-reverse; 可換行，由 cross end 開始向 cross start 堆疊。 flex-flow 屬性 flex-direction 屬性與 flex-wrap 屬性的縮寫。 例如： 1flex-flow: row wrap; 上式等同於 12flex-direction: row; /* 預設值 */flex-wrap: wrap; 又例如： 1flex-flow: row-reverse wrap-reverse; 上式等同於 12flex-direction: row-reverse;flex-wrap: wrap-reverse; order 屬性 order 屬性可以控制 flex items 的順序，會從 order 最小的開始排序。 僅適用於 flex items，屬性值須為整數(可為負數)， 預設下皆為 0。 圖片來源：W3C 直接看圖比較快～ 例如在書寫方向為橫向且由左至右的前提下，若主軸(main axis)為 row，即 flex-direction: row，則 flex items 的會依照其 order 由左至右排序(order 愈小愈優先)。 1 &lt; 3 &lt; 4 -5 &lt; -2 &lt; 4 &lt; 8 若主軸(main axis)為 column，即 flex-direction: column，則 flex items 會依照其 order 由上至下排序(order 愈小愈優先)。 1 &lt; 3 &lt; 4 -10 &lt; 4 &lt; 7 &lt; 13 參考資料 W3C-CSS Flexible Box Layout Module Level 1 MDN-Controlling Ratios of Flex Items Along the Main Axis CSS TRICKS-A Complete Guide to Flexbox","link":"/article/Flex.html"},{"title":"CSS 原理 - Flex(下)","text":"vertical-align、text-align 甚至 float 都是控制不了 flex items 的，flex 有自己專屬的對齊屬性，而因對齊分為水平對齊與垂直對齊，所以首先要先認清楚誰是主軸(main axis)誰是副軸(cross axis)，才不會精神分裂。 先稍微複習一下，主軸(main axis)與副軸(cross axis)的方向取決於 flex direction 屬性與書寫模式 writing-mode，可參考先前文章 CSS 原理 - Flex(上)。 flex 的對齊 要小心的是，有些屬性是適用於 flex container，有些屬性則適用於 flex items，用錯地方是沒反應的唷。 適用於 flex container 的對齊屬性 justify-content align-items align-content 適用於 flex items 的對齊屬性 align-self justify-content 屬性 控制 flex items 在主軸(main axis)方向的對齊方式，僅適用於 flex container。以下為幾個常用且瀏覽器支援度較高的屬性值： • flex-start 為預設值，flex items 由主軸的始端開始排列。 • flex-end flex items 由主軸的末端開始排列。 • center flex items 置中於主軸。 • space-between 第一個 flex item 對齊主軸的始端，最後一個 flex item 對齊主軸的末端，其餘空間平均分佈於 flex items 之間。 • space-around 以 flex-direction: row 來看，每個 flex item 左右像自備 x 空間，第一個與最後一個 flex item 與 container 的之間有 x 空間，而 flex items 兩兩之間有 2x 空間。 • pace-evenly 以 flex-direction: row 來看，每個 flex item 左右各有 x 空間，第一個與最後一個 flex item 與 container 的之間的空間亦為 x。 圖形輔助 用圖形非常好理解，在水平且由左至右的書寫模式下，若主軸為 row (flex-direction：row)，使用此六種屬性值會呈現下圖中的結果。 圖片來源：CSS TRICKS align-items 屬性 控制 flex items 在副軸(cross axis)方向上的對齊方式，僅適用於 flex container。以下為幾個常用且瀏覽器支援度較高的值。 • flex-start flex items 由副軸的始端開始排列。 • flex-end flex items 由副軸的末端開始排列。 • center flex items 置中於副軸。 • stretch 為預設值，這也是為什麼 flex item 在預設下會撐滿容器在副軸上的空間。 • baseline flex items 依照 baseline 對齊。 圖形輔助 在水平且由左至右的書寫模式下，若副軸為 column (flex-direction：row)，使用此五種屬性值會呈現下圖中的結果。 圖片來源：CSS TRICKS align-content 屬性 控制「多行(multi-line)主軸」在副軸上的對齊方式，也就是前提為 flex container 的 flex-wrap 屬性值須為 wrap 或 wrap-reverse，而非預設的 flex-wrap: nowrap。僅適用於 flex container。 以下圖形範例以主軸(main axis)為 row(橫向)，副軸(cross axis)為 column(縱向)來說，即 flex-direction: row 下： • flex-start 「多行(multi-line)主軸」對齊副軸的始端。 • flex-end 「多行(multi-line)主軸」對齊副軸的末端。 • center 「多行(multi-line)主軸」置中於副軸。 • space-between 第一個與最後一個 line 對齊副軸的始端與末端，其餘空間平均分佈於 flex items 之間。 • stretch 延伸撐滿副軸。 • space-around 每個 line 兩旁像自備 x 空間，第一個與最後一個 line 與 container 的之間有 x 空間，而 lines 兩兩之間有 2x 空間。 • space-evenly 每個 line 左右各有 x 空間，第一個與最後一個 line 與 container 的之間的空間亦為 x。 align-self 屬性 也可以單獨控制個別 flex item 在副軸上的對齊方式。僅適用於 flex items。 以主軸(main axis)為 row(橫向)，副軸(cross axis)為 column(縱向)來說，即 flex-direction: row 下： • flex-start flex item 由副軸的始端開始排列。 • flex-end flex item 由副軸的末端開始排列。 • center flex item 置中於副軸。 • stretch flex item 撐滿副軸。 • baseline flex item 對齊 baseline。 總整理 適用於 flex container justify-content 控制主軸上所有 flex items 的對齊。 align-items 控制副軸上所有 flex items 的對齊。 align-content 控制「多行(multi-line)主軸」在副軸上的對齊方式。 適用於 flex items align-self 控制副軸上個別 flex item 的對齊。 參考資料 W3C - Flexible Box Layout Module Level 1 MDN - Aligning Items in a Flex Container CSS TRICKS - A Complete Guide to Flexbox","link":"/article/Flex3.html"},{"title":"CSS 原理 - Flex(中)","text":"這篇將介紹 flex 屬性，並且深入探討 flex 究竟是如何計算伸縮的比例。 名詞介紹 若要理解 flex 是如何計算伸縮比例，首先需要了解一下 positive free space 與 negative free space 這兩個名詞。 positive free space 若 flex items 在主軸(main axis)方向上的尺寸總和小於 flex container 的尺寸，此時會出現 flex container 的空間沒有被填滿，這些剩餘空間就稱為 positive free space。 例如，在主軸(main axis)為 row 下，若 flex container 的寬度為 500px，而 a、b、c 三個 flex items 寬度各為 100px，此時 flex container 還有 200px 的 positive free space。 圖片來源 MDN negative free space 若 flex items 在主軸(main axis)方向上的尺寸總和大於 flex container 的尺寸，此時 flex container 的空間不夠用，而 flex items 的尺寸總和與 flex container 尺寸的差額就稱為 negative free space。 例如，在主軸(main axis)為 row 下，若 flex container 的寬度為 500px，而 a、b、c 三個 flex items 寬度各為 200px，此時 flex container 的寬度 500px 小於 flex items 的寬度總和 600px，negative free space 為 600px 減 500px，等於 100px。 圖片來源 MDN flex 屬性 圖片來源：W3C 1flex: flex-grow ｜ flex-shrink ｜ flex-basis; 為三個屬性 flex-grow、flex-shrink 與 flex-basis 的縮寫。 flex-grow: 決定 flex item 將得到多少比例的 positive free space。 flex-shrink: 決定 flex item 將得到多少比例的 negative free space。 flex-basis: 決定 flex item 在尚未 grow 與 shrink 前的原始尺寸。 預設值為 flex: 0 1 auto flex-grow 以 flex-basis 為基礎，決定 positive free space 的分配比例，所以有 positive free space 才有作用。 必須為 ≥ 0 的值。 若為 0 (預設值)，則不會延伸。 計算方式 在 flex-direction: row 下，有一個寬度為 500px 的 flex container，與三個寬度各為 100px、80px、70px 的 flex items，則在預設下會有 500px - 250px = 250px 的 positive free space 。 123456&lt;div class=\"container\"&gt; &lt;div class=\"item1\"&gt;item1&lt;/div&gt; &lt;div class=\"item2\"&gt;item2&lt;/div&gt; &lt;div class=\"item3\"&gt;item3&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021.container { display: flex; outline: 3px solid #444; width: 500px; height: 120px; } .item1 { width: 100px; flex: 0 1 auto; /* 此為預設值 */}.item2 { width: 80px; flex: 0 1 auto; /* 此為預設值 */}.item3 { width: 70px; flex: 0 1 auto; /* 此為預設值 */} 現在將三個 flex items 的 flex-grow 分別設定為 1、2、2。 item1 將分配到 1/(1+2+2) = 1/5 的 positive free space。最終寬度為 150px。 item2 將分配到 2/(1+2+2) = 2/5 的 positive free space。最終寬度為 180px。 item3 將分配到 2/(1+2+2) = 2/5 的 positive free space。最終寬度為 170px。 123456789101112131415.item1 { width: 100px; flex: 1 1 auto; /* 將 flex-grow 改為 1，將佔 1/5 等分 */}.item2 { width: 80px; flex: 2 1 auto; /* 將 flex-grow 改為 2，將佔 2/5 等分 */} .item3 { width: 70px; flex: 2 1 auto; /* 將 flex-grow 改為 2，將佔 2/5 等分 */} flex-shrink 以 flex-basis 為基礎，決定 negative free space 的分配比例，所以有 negative free space 才有作用。 必須為 ≥ 0 的值。 若為 0，則不會收縮，此時若 container 空間不夠，會發生 overflow。 預設值為 1。 flex items 不會縮短至小於 min-content 的尺寸，除非設定 min-width 或 min-height 屬性。 計算方式 flex container 寬度為 500px，其三個 flex items 寬度各為 200px，故此時有 100px 的 negative free space，若將所有 flex items 的 flex-shrink 皆設定為 0，則將發生 overflow。 12345&lt;div class=\"container\"&gt; &lt;div class=\"item1\"&gt;item1&lt;/div&gt; &lt;div class=\"item2\"&gt;item2&lt;/div&gt; &lt;div class=\"item3\"&gt;item3&lt;/div&gt;&lt;/div&gt; 1234567891011.container { display: flex; width: 500px; height: 120px; outline: 3px solid #333;}.container &gt; * { width: 200px; /* 所有 flex items 寬度皆為 200px */ flex: 0 0 auto; /* 將所有的 flex-shrink 設定為 0 */} 現在將第一個與第二個 flex item 的 flex-shrink 分別設定為 1 與 4，第三個 flex item 的 flex-shrink 依然為 0。 注意，shrink 與 grow 的計算方法並不相同，公式可參考 前端新手村 flex grow &amp; shrink 演算法。 negative free space = 500px - 200 *3 = -100px item 1 將分配到 1/5 的 negative free space，所以最後寬度為 180px。 算法： 1 * 200/(1 * 200 + 4 * 200 + 0 * 200)= 1/5 item 2 將分配到 4/5 的 negative free space，所以最後寬度為 120px。 算法： 4 * 200/(1 * 200 + 4 * 200 + 0 * 200)= 4/5 item 3 將分配到 0/5 的 negative free space，所以最後寬度為 200px。 算法： 0 * 200/(1 * 200 + 4 * 200 + 0 * 200)= 0 1234567891011.item1 { flex: 0 1 auto; /* 佔 1*200/(1*200+4*200+0*200)= 1/5 等份 */}.item2 { flex: 0 4 auto; /* 佔 4*200/(1*200+4*200+0*200)= 4/5 等份 */}.item3 { flex: 0 0 auto; /* 佔 0*200/(1*200+4*200+0*200)= 0 等份 */} flex-basis 決定 flex item 在尚未 grow 或 shrink 前的原始尺寸。 預設值為 auto。 若有指定尺寸 width、height (視主軸 main axis 而定)，則依照所指定的尺寸。 若無指定尺寸 width、height (視主軸 main axis 而定)，則由其內容大小決定。 若為 0，則 flex item 不被納入空間計算。例如有一個 container 寬度 400px，裡面有 item1 與 item2，寬度各為 200px，此時 flex-basis 為預設的 auto，故沒有剩餘空間。但若將 item2 的 flex-basis 設為 0，則會有 200px 的剩餘空間，原因是 flex-basis 優先級高於 width 與 height。 除了 auto 之外，尚有 content、max-content、min-content 等屬性值，不過多數瀏覽器不支援。 可給定有單位的數值，例如 100px 或 10%，若同時設定 flex-basis (非 auto) 和尺寸(width 或 height，視主軸 main axis 而定)，則以 flex-basis 為優先。 例如： 有三個 flex items，指定第一個 flex item 的 width 為 200px， 在 flex-direction: row 且 flex-grow 與 flex-shrink 皆為 0 的前提下，設定 flex-basis 值為 auto，此時 第一個 flex item 的寬度為 200px。 第二與第三個 flex item 的寬度為其內容尺寸。 12345&lt;div class=\"container\"&gt; &lt;div&gt;flex item 1&lt;/div&gt; &lt;div&gt;flex item 2&lt;/div&gt; &lt;div&gt;flex item 3&lt;/div&gt;&lt;/div&gt; 123456789101112131415div { outline: 1px solid #333;}.container { display: flex;}.container :first-child { width: 200px; /* 第一個子元素給定寬度 200px */}.container &gt; * { flex: 0 0 auto; /* 所有子元素的 flex basis 為 auto*/} flex 屬性另類寫法 flex 屬性除了直接給定 flex-grow、flex-shrink、flex-basis 三個值之外，還有以下幾種寫法。 flex: initial flex: auto flex: none flex: &lt;正數&gt; 註：&lt;正數&gt; 可不必為整數，例如可為 0.5。 以下分別說明這四種屬性值的意義。 flex: initial 1flex： initial; 等同於 1flex： 0 1 auto; flex item 會依照 width 或 height (視主軸 main axis 而定)屬性決定其尺寸，即使 container 中有剩餘空間，flex item 仍無法延伸，但當空間不足時，元素可收縮。 flex: auto 1flex: auto; 等同於 1flex: 1 1 auto; flex item 可延伸與收縮，會依照 width 或 height (視主軸 main axis 而定)屬性決定其尺寸。若所有 flex items 均設定 flex: auto 或 flex: none，則在 flex items 尺寸決定後，剩餘空間會被平分給 flex: auto 的 flex items。 flex: none 1flex: none; 等同於 1flex: 0 0 auto; flex item 不可延伸與收縮，會依照 width 或 height (視主軸 main axis 而定)屬性決定其尺寸。 flex: positive-number 1flex: &lt;正數&gt;; 等同於 1flex: &lt;正數&gt; 1 0; flex item 可延伸與收縮，flex-basis 為 0，故 flex item 會依據所設定的比例佔用 container 中的剩餘空間。 例如 1flex: 2; 等同於 1flex: 2 1 0; 可利用此種屬性值的指定方式，輕易地決定 flex items 在 flex container 中所佔的尺寸比例 (width 或 height，視主軸 main axis 而定)。 例如，一個 flex container 裡面有三個 flex items，希望不管 container 如何變化，這三個 items 的尺寸皆一樣大，則可設定每個 items 的 flex 屬性有相同的正數(positive-number)。 12345&lt;div class=\"container\"&gt; &lt;div class=\"item1\"&gt;&lt;/div&gt; &lt;div class=\"item2\"&gt;&lt;/div&gt; &lt;div class=\"item3\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516.container { display: flex; height: 120px;}.item1 { flex: 1; /* 將得到容器中剩餘空間的 1/(1+1+1)＝1/3 等份 */}.item2 { flex: 1; /* 將得到容器中剩餘空間的 1/(1+1+1)＝1/3 等份 */}.item3 { flex: 1; /* 將得到容器中剩餘空間的 1/(1+1+1)＝1/3 等份 */} 註：只要是相同正數即可，其僅代表比例關係。 且不論容器如何變動(例如縮放視窗時)，比例皆為 1 : 1 : 1。 同理，若希望這三個 flex items 的尺寸比例分別為 3 : 2 : 1，則可設定： 1234567891011.item1 { flex: 3; /* 將得到容器中剩餘空間的 3/(3+2+1)＝3/6 等份 */}.item2 { flex: 2; /* 將得到容器中剩餘空間的 2/(3+2+1)＝2/6 等份 */}.item3 { flex: 1; /* 將得到容器中剩餘空間的 1/(3+2+1)＝1/6 等份 */} 且不論容器如何變動(例如縮放視窗時)，比例皆為 3 : 2 : 1。 有關於 flex 屬性以及伸縮的計算方式就介紹到此，下一篇將繼續介紹 flex 的各種對齊方式。 參考資源 W3C-CSS Flexible Box Layout Module Level 1 MDN-Controlling Ratios of Flex Items Along the Main Axis 前端新手村 flex grow &amp; shrink 演算法","link":"/article/Flex2.html"},{"title":"CSS 原理 - Formatting Context","text":"每個元素都是一個個的盒子(box)，這些盒子在 in flow 下會如何排列就要看該盒子處在什麼樣的佈局環境，而 formatting context (格式化上下文) 指的就是佈局環境，不同類型的佈局環境會有不同的佈局規則，換句話說，處在不同類型佈局環境裡的盒子，排列方式會有所不同。 什麼是 Formatting Context 先來看一段 W3C 規範對於 formatting context (格式化上下文) 的敘述。 摘自 W3C A formatting context is the environment into which a set of related boxes are laid out. Different formatting contexts lay out their boxes according to different rules. A box either establishes a new independent formatting context or continues the formatting context of its containing block. The type of formatting context established by the box is determined by its inner display type. Additionally, some types of formatting contexts interleave and co-exist. 也就是說，formatting context 指的是一個「佈局環境」，處在什麼佈局環境裡的元素(盒子)，就得遵守什麼環境的佈局規則，盒子也可以自立門戶，建立新的 formatting context，再繼續裝其它盒子，而會建立什麼類型的 formatting context，取決於 display 屬性的 inner display type。可參考先前文章 你所不知道的 display。 有些類型的 formatting contexts 可以同時交互並存，像是 BFC 與 IFC 或是 FFC 與 IFC 等。 Formatting Context 類型 Formatting context 大致有以下幾種，其中，BFC 與 IFC 對於排版來說最為重要，而除了 BFC 較為特殊之外，其餘的 formatting context 取決於元素的 display 屬性。 Block Formatting Context (BFC) Inline Formatting Context (IFC) Flex Formatting Context (FFC) Grid Formatting Context (GFC) Ruby Formatting Contect (RFC) Independent Formatting Context 剛提到盒子可以自立門戶，為其後裔元素建立自己的 formatting context，而當一個元素(盒子)建立了獨立的 formatting context，不論所建立的類型是否與該元素所處的 formatting context 相同，都是為其後裔元素建立了一個新的佈局環境，所以其後裔元素的佈局通常不必再遵守該元素所處的佈局環境規則。 值得留意的是，除了 display 之外，有些屬性也會使元素建立獨立的 formatting context，像是 float、position: absolute 或 fixed 這些會使元素脫離正常流(out-of-flow)的屬性皆會建立獨立的 formatting context。 圖解 Formatting Context 「Formatting context 是個佈局環境，不同的 formatting context 有不同的佈局方式」，用圖形或許可以幫助理解，以下將舉三個例子，主要為 BFC 與 IFC，其他類型的 formatting context 概念皆相同，可以此類推。 下圖截取部分 W3C 規範中的 display 表格，若對於這個表格感到陌生的讀者，建議先看先前文章 你所不知道的 display。 圖片來源: W3C Case1: BFC &lt;html&gt; 就是個超級大盒子，裡面裝著其他盒子，且會建立一個 BFC，由上方 display 表可知，其後裔元素 &lt;body&gt; 與三個橘色的 block 元素皆會生成 block-level box，且處在 BFC 裡(或說是參與 BFC)，所以會呈現垂直排列。 Case2: IFC 由上方 display 表可知，&lt;body&gt; 對內會生成 block container，可以建立 IFC，而其兩個橘色的 inline 後裔元素會生成 inline box(為一種 inline-level box)，且處在此 IFC 中(或說是參與該 IFC)，所以呈現水平排列。 Case3: 混合 inline-block 元素會生成inline-level box，該元素本身處在 &lt;body&gt; 所建立的 IFC 中(或說是參與該 IFC)，且兩個 inline-block 元素分別為其後裔元素建立了新的獨立佈局環境──BFC 與 IFC，所以其後裔元素不會與 inline-block 元素一同參與外部 IFC。 結語 說穿了，formatting context 就真的只是「佈局環境」而已，花了一個篇幅解釋 formatting context 其實是在替後面的文章鋪路，接下來將介紹在排版中最為重要的 block formatting context(BFC)。 參考資料 W3C - Appendix A: Glossary W3C - Box Layout Modes: the display property W3C - Block-level elements and block boxes W3C - Inline-level elements and inline boxes","link":"/article/Formatting-context.html"},{"title":"CSS 原理 - position","text":"這篇要介紹的是 position，\b顧名思義，它與元素的位置或定位方式有關，了解它的各種屬性值肯定是必要的，像是常見的彈跳視窗或固定導覽列，也都需要它。 position 語法 position 的屬性值有 static、relative、absolute、fixed 與 sticky。 1position: static | relative | absolute | fixed | sticky static 1position: static; 為預設值。 元素為 in-flow。 top、right、bottom 與 left 屬性皆無效。 z-index 屬性無效。 relative 1position: relative; 元素仍為 in-flow，為元素預留原本的空間。 top、right、bottom 與 left 屬性可指定元素相對於自身原本的位置做偏移，不影響其他元素的位置。 此屬性值對 display 值為 table-row-group、table-header-group、table-footer-group、table-row、table-column-group、 table-column、table-cell 與 table-caption 的元素無效。 absolute 1position: absolute; 元素 out-of-flow，不為元素預留原本的空間。 相對於祖譜中最接近且 position 值非 static 的containing block(包含塊)做定位，若無，則追溯至 initial containing block (初始包含塊)，在連續媒體下即為 veiwport (視口)。 top、right、bottom 與 left 屬性可指定其對於containing block(包含塊)的偏移量，不影響其他元素的位置。 不會與其他元素發生 margin collapsing(外距重疊)，因為會建立一個新的 BFC。 建立 Block Formatting Context(BFC)。 fixed 1position: fixed; 元素 out-of-flow，不為元素預留原本的空間。 containing block(包含塊)為 veiwport，所以會以 veiwport 做定位，滾動時，元素相對於 viewport 仍處於同一位置。 上層元素中若有 transform 屬性非 none 的祖先時，containing block(包含塊)由 veiwport 改為該祖先，即針對該祖先定位。 top、right、bottom 與 left 屬性可指定其對於containing block的偏移量。 不會與其他元素發生 margin collapsing(外距重疊)。 建立 Block Formatting Context(BFC)。 sticky 為相對定位(relative)和固定定位(fixed)的混合體。元素在跨越特定門檻(specified threshold)之前屬於相對定位，之後屬於固定定位。 1position: sticky; 元素為 in-flow。 必須指定 top、right、bottom 或 left 其中一個做為特定門檻(specified threshold)，sticky 才有效，即使是 top: 0。 相對於最近的可滾動祖先和 containing block 做定位。 top、right、bottom 與 left 屬性可指定其偏移量，不影響其他元素的位置。 建立 Block Formatting Context(BFC)。 例如: 12345&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;1&lt;/div&gt; &lt;div class=\"box\"&gt;2&lt;/div&gt; &lt;div class=\"box\"&gt;3&lt;/div&gt;&lt;/div&gt; 123456789101112.container{ width: 280px; height: 1850px; /* 可滾動 */}.box{ position: sticky; top: 150px; /* 門檻值(必要條件) */ width: 70px; height: 70px; margin-bottom: 100px;} 參考資源 W3C-hoosing a positioning scheme: ‘position’ property MDN-position MDN-Block formatting context","link":"/article/Position.html"},{"title":"CSS 原理 - Box model","text":"想像每個元素都是個盒子，而 &lt;html&gt; 就像是個超級大盒子，裡面裝了許許多多大小不一的盒子，像是 &lt;div&gt;、&lt;p&gt;、&lt;span&gt;、&lt;button&gt;…等等，而每個盒子由四個部分組成。 如下圖所示，box model 由四個部分組成，由內至外依序為 content area (內容區) padding (內距) border (邊框) margin (外距) content area 內容區域，也就是盒子裡裝的東西，可能是文字、圖片或是又裝了其它元素(其他盒子)，例如 &lt;div&gt;、&lt;p&gt;、&lt;span&gt;、&lt;button&gt;…等等。 padding (內距) 可想像成盒子和其內容物的距離，介於 content area(內容區) 與 border(邊框)之間的部分。其特色為 厚度取決於 padding 屬性， 不能為負值。 預設下，padding 不包含在屬性 width 的範圍，因 box-sizing 預設值為 content-box，當然只包含最裡面的 content 部分。 border (邊框) 介於 margin (外距)與 padding(內距) 之間的範圍。 可以使用 border 屬性來設置邊框的寬度、樣式與顏色。 三合一縮寫語法 (三個值的順序可以互換)： 1border: border-width｜border-style｜border-color 亦可單獨指 定border 的寬度、樣式與顏色。個別屬性如下： border-width (邊框寬度) border-style (邊框樣式) border-color (邊框顏色) 預設情況下，不包含在 width 與 height 的範圍內。 margin (外距) margin 圍繞於 border 之外，用於推開元素與其它元素之間的距離。其特色為 厚度取決於 margin 屬性。 可以是正值或負值，但若為負值，可能會與其它元素重疊。 元素本身的背景設定無法渲染至 margin 部分，例如 background-color 或 background-image。 不包含在 width 與 height 範圍內。 box-sizing 一個新手常遇見的問題：奇怪，明明指定了元素的 width 與 height，但元素渲染於畫面上的寬度與高度卻比自己設定的值來得大？ 這問題通常與 box-sizing 有關。 box-sizing 屬性決定如何計算一個元素渲染於畫面上的總寬度與總高度，也就是 size，有 content-box 與 border-box 兩種屬性值。 (一) content-box 1box-sizing: content-box； content-box 為預設值，如同字面上的意思，若該元素可以指定 width 與 height，則在設定 width 或 height 時，其指定的僅為最內層的 content 部分，例如 width: 100px，則代表元素的 content area 寬度為 100px。 如果同時還設定了 padding 或是 border，則必須再加上 padding 與 border，才是最終渲染於畫面上的寬度或高度。 例如： 給定一個 div 的設定如下： codepen 範例連結 12345678div { box-sizing: content-box; /*預設值*/ width: 200px; height: 100px; padding: 20px; margin: 30px; border: 10px solid black;} 則在 content-box 下： 最終渲染寬度 ≠ width 200px 而是 ( width 200 + 左右 padding 20*2 + 左右 border 10*2 )px = 260px ; 最終渲染高度 ≠ height 100px 而是( height 100 + 上下 padding 20*2 + 上下 border 10*2 )px = 160px。 (二) border-box 1box-sizing: border-box; 如同字面上的意思，若該元素可以指定 width 與 height，則 width 和 height 屬性值涵蓋的範圍為 border 以內，也就是 content、padding 和 border，注意，不包括 margin。 border-box 可以使元素渲染於畫面上的總寬度與總高度的計算變得較直覺簡單，不必再額外加上 padding 和 border，連 bootstrap 也對所有元素做了此設定。 例如： 給定一個 div 的設定如下： 在 border-box 下： 最終渲染寬度即為 width 200px ; 最終渲染高度即為 height 100px。 12345678div { box-sizing: border-box; width: 200px; height: 100px; padding: 20px; margin: 30px; border: 10px solid black;} 參考資料 W3C - CSS Box Model Module Level 3 MDN - The box model MDN - box-sizing","link":"/article/box-model.html"},{"title":"CSS 原理 - Line box","text":"Line box 就像筆記本上的線框，一行一行的垂直堆疊，裡面裝著文字或是 inline-level boxes，而我們可以利用 text-align 與 vertical-align 屬性操控 inline-level boxes 在 line box 裡的水平與垂直對齊。 什麼是 line box 圖片來源：visualhunt line box 是用來裝文字與所有 inline-level box 的，換句話說，只要有文字或是 inline-level box 的地方，就會出現 line box，就像「行」的概念，一個 line box 就是一行。這篇將說明 line box 的範圍是如何決定的。 若對於哪些元素會生成 inline-level box 不太清楚，可複習上一篇 display 文章。 line box 寬度 line box 是「行」的概念，也是一個矩形範圍，正常情況下，line box 的寬度取決於 Containing block(包含塊)，但若有 float 元素，則 line box 會受到壓縮(shrink)。 直接用實例來看會較具體一點，以下將比較正常情況下與在有 float 元素下，line box 的寬度會如何變化。 Case: 無 float 元素時 以 display: inline-block 為例，該元素屬於 inline-level box，故會產生 line box，而 line box 寬度取決於其 containing block(包含塊)。 12345&lt;div class=\"block-container\"&gt; &lt;div class=\"inline-level-box\"&gt; display: inline-block &lt;/div&gt;&lt;/div&gt; 12345678910111213.block-container { width: 600px; height: 250px; border: 10px solid #333;}.inline-level-box { display: inline-block; /* 為一種 inline-level-box */ height: 100px; color: white; font-size: 20px; background-color: orange;} 此時設定 text-align: center，則橘色的 inline-level box 會水平置中於 line box 裡，這結果應該毫不令人意外。 123.block-container { text-align: center;} Case: 有 float 元素時 當有 float 元素時，line box 會受到 float 元素的擠壓，若擠壓到 line box 無法容納裡面的文字或是 inline-level box 時，line box 就會自動「換行」。 12345678910111213141516171819202122.block-container { width: 600px; height: 250px; border: 10px solid #333; margin: 100px;}.float { float: left; /* float 會擠壓 line box */ width: 100px; height: 150px; color: white; background-color: #F75848;}.inline-level-box { display: inline-block; /* 為一種 inline-level-box */ color: white; font-size: 20px; height: 100px; background-color: orange;} 此時 line box 已經被 float 元素壓縮了。範例連結 設定 text-align: center，讓橘色的 inline-level box 水平置中於被壓縮後的 line box 裡。 123.block-container { text-align: center;} 接著，若 float 元素變更寬，擠壓 line box 更多，多到該行無法再容納橘黃色的 inline-level box 時，line box 就會「換行」。 123.float { width: 500px; /* 變超胖 */} line box 高度 如同上述，line box 是用來裝文字或 inline-levle box 的，所以一個 line box (同一行)高度由位置最高的 inline-level box 頂部與位置最低的 inline-level box 底部的距離。 其中 inline-level box 又可二分為 inline box 與 atomic inline-level box 兩種，像是替換元素 &lt;img&gt; 或 display: inline-block 皆屬於 atomic inline-level box，下一篇文章會說明兩種有何差別(應該會吧)。 Case: 若是 inline box Inline box 僅有 box model 中的 content area 會影響 line box 高度。 Line box 僅取決於 inline box 的 content area (像是 line-height 或 font-size 皆會影響 content area)，不包含 padding、border、margin。 例子 &lt;span&gt; 預設為 display: inline，且非替換元素(nonreplaced elememt)，為 inline-level element 中的 inline element，故其僅有 line-height 會影響 line box，padding、border、margin 皆不會影響 line box 高度。 1234&lt;div&gt;Lorem ipsum, dolor sit add &lt;span&gt;我在 inline box 裡面&lt;/span&gt; Lorem ipsum, dolor sit amet consectetur .&lt;/div&gt; 12345678910div { width: 220px; margin: 200px; border: 1px solid #000;}span { background-color: orange; padding: 10px;} 為方便觀察，給 &lt;span&gt; 背景橘色的顏色，並給 &lt;span&gt; 上下左右 padding 各 10px。 反白區域為一個 line box 高度。可以清楚看見，line box 並沒有被撐高，上下方的文字沒有被推開(但左右有)。 Case: 若是 atomic inline-level box Atomic inline-level box 的整個 box model 會影響 line box 高度。 Line box 取決於 atomic inline-level box 的整個 box model 高度，即包含 padding、border 與 margin 部分。 例子 現在將 &lt;span&gt; 設定為 display: inline-block，&lt;span&gt; 仍然屬於 inline-level element，但由 inline element 變成 atomic inline-level element。 12345span { display: inline-block; /* 變成 atomic inline-level */ background-color: orange; padding: 10px;} 反白區域為一個 line box 高度。可以清楚看見，line box 長高了，所以上下方文字的距離也隔開了！ 註： ① box model 高度為內容區高度 + 上下內距 +上下邊框 + 上下外距，可參考先前文章。 ② 其它替換元素 參考資源 W3C - Inline formatting contexts W3C - Line height calculations W3C - Floats 鉄人28号FX 鉄人2号「文本士」content area","link":"/article/LineBox.html"},{"title":"CSS 原理 - 你所不知道的 display","text":"Visual formatting model (視覺格式化模型) 對於排版來說是很重要的觀念，但不是那麼平易近人且有點抽象，在初次看 W3C 規範 時一定是霧煞煞，強烈建議先釐清幾個重要名詞的定義，會發現繞來繞去，講的其實都是相同的概念。 display 為什麼 display: block 的元素們會呈現垂直排列？為什麼 display: inline 的元素們會呈現水平排列？又為什麼 display: inline-block 的元素是呈現水平排列呢？其實答案都與元素生成(generate)何種類型的 box 有關。 在先前 box model 文章中曾介紹，元素就像一個個的盒子 (box)，這篇將介紹在 in flow 下，這些「 盒子如何排列」，或說是「元素如何佈局」。 元素在 in flow 下如何佈局的主要關鍵為該元素「生成 (generate)了什麼類型的 box」，而這會取決於元素的 display 屬性。其實我們所熟悉的 display 同時定義了元素的兩種 display type： outer display type：決定元素「本身」在 in flow 下如何佈局，即元素本身參與的是何種 formatting context (格式化上下文)。 inner display type：決定元素為它的後裔元素建立何種 formatting context，與其後裔元素的佈局有關。 outer display type 在 outer display type 方面，box 類型可分成 inline-level box 與 block-level box 兩大類，所有 inline-level box 皆會參與 IFC，呈現水平排列，而所有 block-level box 皆會參與 BFC，呈現垂直排列。 inline-level box (行內級盒子) inline box (行內盒子) atomic inline-level box (原子行內級盒) block-level box (塊級盒子) inner display type 在 inner display type 方面，因其描述的是元素本身與其內容或後裔元素的關係，可以想像成元素像個容器 (container)，裝著文字內容或後裔元素。常見的 container box 類型有 block container box、flex container box 與 grid container box 等等。 而什麼類型的 container box，就會為其內容或後裔元素建立什麼類型的 formatting context，例如： flex container 建立 flex formatting context (FFC) grid container 建立 grid formatting context (GFC) block container 可建立 block formatting context (BFC) 或 inline formatting context (IFC) 順帶一提，替換元素\b (replaced element)，例如 &lt;img&gt;，display 的預設值為 inline，不論將其 display 屬性值改成什麼，皆不會有 container box，因為它就是路徑來源的圖片，不是用來裝像是 &lt;span&gt;、&lt;div&gt; 或其他元素的容器。 圖片來源: W3C 了解 display 的好處 講了這麼多，了解 display 到底有什麼好處？ 個人認為至少有三大優點。 秒殺元素排列方式 即使遇到一個從來沒用過的 display 屬性值，也能夠馬上知道在 in flow 下，元素會如何排列，例如，你有聽過或用過 display: flow-root 或 inline-flex 嗎？ 在沒有用過，甚至從沒聽過的情況下，一看 display 表就可以得知 display: flow-root 的元素會生成 block-level box，故元素本身參與 BFC，在 in flow 下會呈現垂直排列。而 display: inline-flex 會生成 inline-level box，故元素本身參與 IFC，在 in flow 下會呈現水平排列。 秒殺屬性的適用對象 例如常用的 vertical-align 與 text-align 對齊，你知道他們能操控的對象總共有哪些嗎？ 其實他們是在操控 inline-level 的垂直與水平對齊。 vertical-align 屬性可以適用於所有 inline-level boxes，也就是可以操控 display 表上所有會生成 inline-level box 元素的垂直對齊。 圖片來源：W3C 而 text-align 的屬性則是須設定在 inline-level 外層的 block container，它可操控 display 表上所有會生成 inline-level box 元素的水平對齊。 圖片來源：W3C 再例如，margin: 0 auto，常用在 display: block 元素的水平置中，但除此之外，還可以用在哪些元素上呢？ 其實 display 表上會生成 block-level box 的皆適用。 何種 display 會產生 BFC 就如同剛剛提及的，什麼類型的 container box 就會建立什麼類型的 formatting context，所以 block container box 可以建立 BFC，這時就可以由 dispaly 表中得知 display: inline-block 與 flow-root 皆會建立 BFC (display: block 例外)。 另外，其實 display: table 與 inline-table 亦會建立 BFC，因生成的 table wrapper box 也是一種 block container。 block formatting context (BFC) 在排版中是非常重要的一環，這部分的介紹留在之後文章再詳細說明。 參考資源 W3C-Controlling box generation W3C-Appendix A: Glossary W3C-Box Layout Modes: the display property","link":"/article/display.html"},{"title":"三種改變函式內部 this 的方式：apply()、call()、bind()","text":"在 JavaScript 中，改變函數內部 this 的指向常見的方式有 call()、apply()、bind()，而這三種方式又存在些微差異。 call() call() 方法會呼叫(執行)一個函數，且可以同時改變函數內部的 this 指向。 語法： 1fun.call(thisArg ,arg1, arg2, ...); 參數說明： thisArg：在函式運行時的 this 指向，若省略則僅執行函式而不改變 this 指向。 arg1, arg2, …：傳遞的參數(可省略)。 例如： 在非嚴格模式下，函式 foo 中的 this 指向的原本是 window，因在此例子中，foo 其實是屬於 window 物件的一個方法。(若在嚴格模式下，則為 undefined) 123456789var obj = { name: 'yachen'}function foo(){ console.log(this);} foo(); // window，其實這裡的 foo() 是 window.foo() 剛提到，call() 會呼叫(執行)函式，但若無給第一個參數，則僅會呼叫函式而不會改變 this 指向，所以除了用 foo() 執行 foo 函式之外，也可以透過 call() 來呼叫(當然不需要多此一舉)。 1foo.call(); // window 現在除了呼叫 foo 函式，同時想要將函式 foo 裡的 this 指向改為 obj，可以使用 call() 來達成。 1foo.call(obj); // obj 還可以傳遞一些參數。 123456789101112var obj = { name: 'yachen'}function foo(a, b){ console.log(this); console.log(a + b);} foo.call(obj, 1, 2); // obj // 3 實現繼承 call() 也可以用來實現繼承。 123456789101112131415function Person(name, age){ this.name = name; this.age = age; this.say = function(){ console.log(`${this.name} is ${this.age} years old`);}};function Taiwanese(name, age){ // this 指向 me Person.call(this, name, age);}var me = new Taiwanese('yachen', 18);me.say(); // \"yachen is 18 years old\" apply() 使用 apply() 會呼叫一個函數，同時可以改變函數內部 this 指向，apply() 與 call() 幾乎一樣，最大的不同是 call() 接受一連串的參數，而 apply() 接受一組陣列(或類陣列)形式的參數。 語法： 1fun.apply(thisArg, [argsArray]); 參數說明： thisArg：在函式運行時的 this 指向。 [argsArray]：傳遞的參數必須為陣列或類陣列(可省略)。 bind() bind() 能改變 this 指向，但不會呼叫(執行)函數，會 copy 並返回一個新的函數。 語法： 1fun.bind(thisArg, arg1, arg2, ...) 參數說明： thisArg：在 fun 函數運行時指定的 this 值。 arg1, arg2, …：傳遞其他參數(可省略)。 例如： 使用 bind() 將函式 foo 裡的 this 指向改為 obj，同時傳遞 1 和 2 兩個引數，有別於 call() 與 apply()，bind() 並不會呼叫執行 foo 函式，僅會返回一個新的函式。 12345678910var obj = { name: 'yachen'}function foo(a, b){ console.log(this); console.log(a + b);}foo.bind(obj, 1, 2); // 並未執行，而使返回一個新的函式 因 bind() 並不會呼叫執行 foo 函式，而是返回一個新的函式，若想要同時執行 foo，則需手動加上 ()。 123foo.bind(obj, 1, 2)(); // obj// 3 現在來看看返回的新函式長什麼樣子，可以打開瀏覽器，並輸入以下代碼。 1234567891011var obj = { name: 'yachen'}function foo(a, b){ console.log(this); console.log(a + b);}var newFoo = foo.bind(obj, 1, 2); // 並未執行，而使返回一個新的函式console.log(newFoo); 印出 newFoo： 咦？ newFoo 不就是 foo 嗎？ 再試著輸入以下代碼，事實證明 newFoo 不等於 foo。 1console.log(newFoo === foo); // false 在開發中，最常使用的應該是 bind()，因為很多情況下我們只是想改變 this，不想同時執行函數。 例如現在有一個按鈕，想要在用戶點擊後，禁用此按鈕 3 秒。 1&lt;button&gt;按鈕&lt;/button&gt; 若直接在定時器裡使用匿名 function(){} 形式的 callback，則在非嚴格模式下，定時器裡的 this 指向的是 window。 123456789101112const btn = document.querySelector('button');btn.addEventListener('click', eventHandler);function eventHandler(){ // this 指向按鈕 btn this.disabled = true; setTimeout(function(){ // this 指向 window this.disabled = false; },3000)} 這時候 bind() 就可以派上用場了，因為不想要在改變 this 的同時執行 this.disabled = false，而是希望透過定時器 3 秒後執行，此時就不適用 call() 與 apply()。 1234567891011const btn = document.querySelector('button');btn.addEventListener('click', eventHandler);function eventHandler(){ // this 指向按鈕 btn this.disabled = true; setTimeout(function(){ this.disabled = false; }.bind(this),3000) // this 改指向按鈕 btn} 當然，也可以直接將定時器裡的 callback function 改成箭頭函式(arrow function)的形式來解決。 123456789101112const btn = document.querySelector('button');btn.addEventListener('click', eventHandler);function eventHandler(){ this.disabled = true; // 改為箭頭函式 setTimeout(()=&gt;{ // this 指向 btn this.disabled = false; },3000)} 總結 call()、apply()、bind() 皆可以改變函數內部的 this ，三者的差異在於： 自動呼叫函數 參數(可省略) call() ⭕️ arg1, arg2, … apply() ⭕️ [arg1, arg2, …] bind() ❌ arg1, arg2, … 參考資料： MDN - Function.prototype.call MDN - Function.prototype.apply() MDN - Function.prototype.bind() MDN - setTimeout","link":"/article/%E6%94%B9%E8%AE%8A%E5%87%BD%E5%BC%8F%E7%9A%84this.html"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"w3HexSchool","slug":"w3HexSchool","link":"/tags/w3HexSchool/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"}],"categories":[{"name":"web","slug":"web","link":"/categories/web/"}]}