{"pages":[{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"About","text":"","link":"/about/index.html"},{"title":"Project","text":"","link":"/project/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"CSS 原理 - Flex(上)","text":"接下來將介紹 flex，從先前 formatting context 的觀念開始，再詳細介紹每個屬性的用法以及 flex box 伸縮的計算方式。 display: flex | inline-flex flex container 顧名思義就是一個容器(container)，描述 flex 元素與其後裔元素之間的關係，當對一個元素設定 display: flex 時，此元素稱為 flex container，而其直接子元素則稱為 flex item。 display: flex 的元素會生成 block-level box 與 flex container，所以該元素本身會參與 BFC 佈局，呈現垂直排列，另一方面，為其內容建立 FFC。 display: inline-flex 的元素會生成 inline-level box 與 flex container，所以該元素本身會參與 IFC 佈局，且會為其內容建立 FFC。 flex container display 為 flex 或 inline-flex 的元素。 flex container 會建立 flex formatting contex(FFC)，所以此元素不會與 float 元素重疊。 column-* 屬性不適用。 flex item display 為 flex 或 inline-flex 元素的子元素稱為 flex item。 建立 BFC，所以 flex items 之間不會發生 margin collapsing，也不會與其父元素(flex container)發生 margin collapsing。 參與 FFC。 vertical-align 不適用。 float 與 clear 不適用。 即使 flex item 是 display: inline 的元素，仍然可以透過 width 與 height 屬性調整寬高。因 flex item 是 blockified。 主軸(main axis)與副軸(cross axis) flex items 可以透過 flex-direction 屬性來決定排列方向，flex-direction 同時也會決定主軸(main axis)與副軸(cross axis)。 圖片來源：W3C flex-direction 共有四個屬性值，會受到書寫方向 writing-mode 影響。 以橫向且由左至右的書寫方式來說，此時 row 為橫向，column 為直向。 flex-direction: row 主軸為 row 方向。 副軸為 column 方向。 由 main start 至 main end 排列。 flex-direction: row-reverse 主軸為 row 方向。 副軸為 column 方向。 由 main end 至 main start 排列。 flex-direction: column 主軸為 column 方向。 副軸為 row 方向。 由 main start 至 main end 排列。 flex-direction:column-reverse 主軸為 column 方向。 副軸為 row 方向。 由 main end 至 main start 排列。 flex-wrap flex-wrap 屬性適用於 flex container，有 nowrap、wrap 與 wrap-reverse 三種屬性值。 圖片來源：W3C nowrap 1flex-wrap: nowrap 不換行，為預設值。 wrap 1flex-wrap: wrap; 換行，由 cross start 開始向 cross end 堆疊。 wrap-reverse 1flex-wrap: wrap-reverse; 可換行，由 cross end 開始向 cross start 堆疊。 flex-flow 屬性 flex-direction 屬性與 flex-wrap 屬性的縮寫。 例如： 1flex-flow: row wrap; 上式等同於 12flex-direction: row; /* 預設值 */flex-wrap: wrap; 又例如： 1flex-flow: row-reverse wrap-reverse; 上式等同於 12flex-direction: row-reverse;flex-wrap: wrap-reverse; order 屬性 order 屬性可以控制 flex items 的順序，會從 order 最小的開始排序。 僅適用於 flex items，屬性值須為整數(可為負數)， 預設下皆為 0。 圖片來源：W3C 直接看圖比較快～ 例如在書寫方向為橫向且由左至右的前提下，若主軸(main axis)為 row，即 flex-direction: row，則 flex items 的會依照其 order 由左至右排序(order 愈小愈優先)。 1 &lt; 3 &lt; 4 -5 &lt; -2 &lt; 4 &lt; 8 若主軸(main axis)為 column，即 flex-direction: column，則 flex items 會依照其 order 由上至下排序(order 愈小愈優先)。 1 &lt; 3 &lt; 4 -10 &lt; 4 &lt; 7 &lt; 13 參考資料 W3C-CSS Flexible Box Layout Module Level 1 MDN-Controlling Ratios of Flex Items Along the Main Axis CSS TRICKS-A Complete Guide to Flexbox","link":"/article/Flex.html"},{"title":"CSS 原理 - Collapsing margins","text":"什麼是 Collapsing margins？ 先來看一段 W3C 規範 的敘述： In CSS, the adjoining margins of two or more boxes (which might or might not be siblings) can combine to form a single margin. Margins that combine this way are said to collapse, and the resulting combined margin is called a collapsed margin. 簡單來說，當相鄰(adjoining)的 margin 相遇時，若合併成一個 margin，這種情況稱為 Collapsing margins。其中，W3C 對於相鄰(adjoining)的定義為： 僅發生於垂直方向 皆為在文檔流中(in flow)的塊級元素(block-level)元素，且參與同一個塊格式化上下文(block formatting context，BFC)。 例如，若是元素會創建新的 BFC，像是根元素 &lt;html&gt; 、float、position: absolute…等等，該元素就不會有 margin collapsing，至於什麼情況下會創建新的 BFC，可參考 MDN-block formatting context。 什麼時候會發生 margin collapsing？ margin collapsing 可分為兩種情況，一種是同層元素之間，另一種是元素與其父(母)容器之間，但並非所有 block-level 元素皆會發生 margin collapsing，而是有前提條件的。 (一) 相鄰的兄弟姊妹 同層且相鄰的 block 元素的 margin-bottom 與 margin-top 相遇時，發生重疊，僅發生於垂直方向。 前提條件： block 須符合相鄰(adjoining)的定義： 皆為在文檔流中(in flow)的塊級元素(block-level)元素，且參與同一個塊格式化上下文(BFC)。 例如：兩個相鄰的 block 元素，紅色 block 的 margin-bottom = 30px，黑色 block 的 margin-top = 30px，最終兩個 block 元素之間的距離為 30px，而非 60px。 範例連結 12&lt;div class=\"block1\"&gt;我有 margin-bottom：30px&lt;/div&gt;&lt;div class=\"block2\"&gt;我有 margin-top：30px&lt;/div&gt; 123456789.block1 { margin-bottom: 30px; background-color: red;}.block2 { margin-bottom: 30px; background-color: black;} (二) 容器與其第一個/最後一個子元素 亦僅發生於垂直方向，且有其前提條件。 前提條件: 皆為在文檔流中(in flow)的塊級元素(block-level)元素，且參與同一個塊格式化上下文(BFC)。 容器無設定邊框(border)、內距(padding)或加上 clear-fix 的屬性。 例如： 虛線為容器的 outline，紅色區塊為容器內的第一個子元素，現在子元素頂部緊貼著容器頂部。若想利用 margin-top 屬性，讓子元素的頂部距離容器頂部 50px。 結果會發現，子元素的頂部並沒有與容器頂部分離！ 範例連結 123&lt;div class=\"container\"&gt; &lt;div class=\"first_child\"&gt;容器中的第一個子元素&lt;/div&gt;&lt;/div&gt; 123.first_child { margin-top: 50px;} 打開開發人員工具檢視一下，會發現子元素的 margin-top 竟然跑出容器外了，這結果與直接在父容器上設定 margin-top: 50px 是一樣的。 解決方法： 使其不再符合前提條件，例如不再是 block 或是創建 BFC。 margin 計算方式 當發生 margin collapsing 時，由於外距(margin)可為負數，故會有三種情況： 兩個 margin 皆為正 ⇒ 取大值 一個 margin 為正，一個 margin 為負 ⇒ 相加 兩個 margin 皆為負 ⇒ 取最小 (最負) 參考資料 W3C - Collapsing Margins W3C - Box Model MDN - Mastering margin collapsing MDN - Block formatting context","link":"/article/Collapsing-margins.html"},{"title":"CSS 原理 - Containing block","text":"Containing block，中文常被翻譯為包含塊，它其實代表的是一個「區域」，一個由 box model 的 content edge 或 padding edge (若有設定 padding)所圍繞的範圍，它攸關元素的定位、寬高、內距與外距的計算，所以必須清楚知道元素的 containing block 是誰，才不會使畫面失控。 例如，在元素設定 width、height、padding、margin 屬性時，若屬性值給予的單位為百分比(％)，則將會以該元素的 containing block 為基準去做計算，再例如，元素的 position定位，也與該元素的 containing block 有關。 如何尋找包含塊： 一個容易犯的錯誤是直接將元素的「父層」視為該元素的 containing block，事實上，在有些情況下並非如此，像是 position: absolute 與 fixed 時。大致情況如下： 根元素 &lt;html&gt; 的 containing block 稱為 initial containing block (初始包含塊)，而在連續媒體下，initial containing block 即為 viewport (視口)。 若元素的 position 屬性值為 static、relative 或 sticky，則 containing block 為距離該元素最近的祖先 block container 或 formatting context (格式化上下文)的 contnet edge (內容區邊緣)組成。 其中，block container 並不完全等於 display: block，像是 display: inline-block 與 list-item 也會形成 block container，這部分有興趣可參考 W3C display 表格。 至於 formatting context ，其實它只是一個「環境」，大致可分為幾種環境，像是 block formatting context、flex formatting context 或 grid formatting context，之後有機會再介紹。 若元素 position 屬性值為 absolute，則其 containing block 為距離它最近且 position 屬性值非 static（即為 fixed、absolute、relative 或 sticky）的祖先元素的 padding edge(內距邊緣)組成。 若元素 position 屬性值為 fixed，則其 containing block 在連續媒體下為 viewport。 如果 position 屬性值為 absolute 或 fixed，containing block 也可能是由滿足以下條件的最接近祖先元素的內容區邊緣組成： transform 或 perspective 屬性值不為 none。 filter 屬性值不為 none。 來看幾個例子吧 例 1. 找出 &lt;p&gt; 的包含塊，並且計算出 &lt;p&gt; 最終的寬、高、內距與外距。 在此例子中，因為 &lt;p&gt; 的 position 值為預設的 static，故其包含塊為距離它最近的 block container 的 padding edge(內距邊緣)所圍繞範圍，又因 &lt;p&gt; 的 width、 height、margin 與 padding 單位皆為百分比(%)，所以會以 containing block，即 &lt;section&gt; 為基準來計算。 12345&lt;body&gt; &lt;section&gt; &lt;p&gt;This is a paragraph!&lt;/p&gt; &lt;/section&gt;&lt;/body&gt; 123456789101112section { display: block; width: 400px; height: 160px;}p { width: 50%; /* == 400px * .5 = 200px */ height: 25%; /* == 160px * .25 = 40px */ margin: 5%; /* == 400px * .05 = 20px */ padding: 5%; /* == 400px * .05 = 20px */} 例 2. 現在將 &lt;section&gt; 改為 display: inline。 找出 &lt;p&gt; 的包含塊，並且計算出 &lt;p&gt; 最終的寬度。 在此例子中，&lt;p&gt; 的 position 依舊是預設的 static，但是 &lt;section&gt; 不再是 block container，沒有形成一個格式化上下文，故 &lt;p&gt; 的包含塊為 &lt;body&gt; 內距邊緣所圍範圍。 &lt;p&gt; 的寬度將以 &lt;body&gt; 為基準計算。 12345&lt;body&gt; &lt;section&gt; &lt;p&gt;This is a paragraph!&lt;/p&gt; &lt;/section&gt;&lt;/body&gt; 12345678section { display: inline;}p { width: 50%; /* == half the &lt;body&gt;'s width */ height: 200px; /* Note: a percentage would be 0 */} 例 3. 包含塊有內距(padding)。 找出 &lt;p&gt; 的包含塊，並且計算出 &lt;p&gt; 的最終寬度、高度、外距與內距。 在此例中，P元素的包含塊是 &lt;section&gt;，因為 &lt;section&gt; 的 position 值非 static。 &lt;p&gt; 百分值會受其包含塊 &lt;section&gt; 的 padding 所影響。若將包含塊的 box-sizing 值設置為 border-box，就可以避免這個問題。 12345&lt;body&gt; &lt;section&gt; &lt;p&gt;This is a paragraph!&lt;/p&gt; &lt;/section&gt;&lt;/body&gt; 12345678910111213141516section { position: absolute; left: 30px; top: 30px; width: 400px; height: 160px; padding: 30px 20px;}p { position: absolute; width: 50%; /* == (400px + 20px + 20px) * 50% = 220px */ height: 25%; /* == (160px + 30px + 30px) * 25% = 55px */ margin: 5%; /* == (400px + 20px + 20px) * 5% = 22px */ padding: 5%; /* == (400px + 20px + 20px) * 5% = 22px */} 參考資源 W3C-Containing blocks MDN-Layout and the containing block 每天來點 CSS Specification-Visual Formatting Model - 定義、containing block","link":"/article/Containing-block.html"},{"title":"CSS 原理 - Formatting Context","text":"每個元素都是一個個的盒子(box)，這些盒子在 in flow 下會如何排列就要看該盒子處在什麼樣的佈局環境，而 formatting context (格式化上下文) 指的就是佈局環境，不同類型的佈局環境會有不同的佈局規則，換句話說，處在不同類型佈局環境裡的盒子，排列方式會有所不同。 什麼是 Formatting Context 先來看一段 W3C 規範對於 formatting context (格式化上下文) 的敘述。 摘自 W3C A formatting context is the environment into which a set of related boxes are laid out. Different formatting contexts lay out their boxes according to different rules. A box either establishes a new independent formatting context or continues the formatting context of its containing block. The type of formatting context established by the box is determined by its inner display type. Additionally, some types of formatting contexts interleave and co-exist. 也就是說，formatting context 指的是一個「佈局環境」，處在什麼佈局環境裡的元素(盒子)，就得遵守什麼環境的佈局規則，盒子也可以自立門戶，建立新的 formatting context，再繼續裝其它盒子，而會建立什麼類型的 formatting context，取決於 display 屬性的 inner display type。可參考先前文章 你所不知道的 display。 有些類型的 formatting contexts 可以同時交互並存，像是 BFC 與 IFC 或是 FFC 與 IFC 等。 Formatting Context 類型 Formatting context 大致有以下幾種，其中，BFC 與 IFC 對於排版來說最為重要，而除了 BFC 較為特殊之外，其餘的 formatting context 取決於元素的 display 屬性。 Block Formatting Context (BFC) Inline Formatting Context (IFC) Flex Formatting Context (FFC) Grid Formatting Context (GFC) Ruby Formatting Contect (RFC) Independent Formatting Context 剛提到盒子可以自立門戶，為其後裔元素建立自己的 formatting context，而當一個元素(盒子)建立了獨立的 formatting context，不論所建立的類型是否與該元素所處的 formatting context 相同，都是為其後裔元素建立了一個新的佈局環境，所以其後裔元素的佈局通常不必再遵守該元素所處的佈局環境規則。 值得留意的是，除了 display 之外，有些屬性也會使元素建立獨立的 formatting context，像是 float、position: absolute 或 fixed 這些會使元素脫離正常流(out-of-flow)的屬性皆會建立獨立的 formatting context。 圖解 Formatting Context 「Formatting context 是個佈局環境，不同的 formatting context 有不同的佈局方式」，用圖形或許可以幫助理解，以下將舉三個例子，主要為 BFC 與 IFC，其他類型的 formatting context 概念皆相同，可以此類推。 下圖截取部分 W3C 規範中的 display 表格，若對於這個表格感到陌生的讀者，建議先看先前文章 你所不知道的 display。 圖片來源: W3C Case1: BFC &lt;html&gt; 就是個超級大盒子，裡面裝著其他盒子，且會建立一個 BFC，由上方 display 表可知，其後裔元素 &lt;body&gt; 與三個橘色的 block 元素皆會生成 block-level box，且處在 BFC 裡(或說是參與 BFC)，所以會呈現垂直排列。 Case2: IFC 由上方 display 表可知，&lt;body&gt; 對內會生成 block container，可以建立 IFC，而其兩個橘色的 inline 後裔元素會生成 inline box(為一種 inline-level box)，且處在此 IFC 中(或說是參與該 IFC)，所以呈現水平排列。 Case3: 混合 inline-block 元素會生成inline-level box，該元素本身處在 &lt;body&gt; 所建立的 IFC 中(或說是參與該 IFC)，且兩個 inline-block 元素分別為其後裔元素建立了新的獨立佈局環境──BFC 與 IFC，所以其後裔元素不會與 inline-block 元素一同參與外部 IFC。 結語 說穿了，formatting context 就真的只是「佈局環境」而已，花了一個篇幅解釋 formatting context 其實是在替後面的文章鋪路，接下來將介紹在排版中最為重要的 block formatting context(BFC)。 參考資料 W3C - Appendix A: Glossary W3C - Box Layout Modes: the display property W3C - Block-level elements and block boxes W3C - Inline-level elements and inline boxes","link":"/article/Formatting-context.html"},{"title":"CSS 原理 - Line box","text":"Line box 就像筆記本上的線框，一行一行的垂直堆疊，裡面裝著文字或是 inline-level boxes，而我們可以利用 text-align 與 vertical-align 屬性操控 inline-level boxes 在 line box 裡的水平與垂直對齊。 什麼是 line box 圖片來源：visualhunt line box 是用來裝文字與所有 inline-level box 的，換句話說，只要有文字或是 inline-level box 的地方，就會出現 line box，就像「行」的概念，一個 line box 就是一行。這篇將說明 line box 的範圍是如何決定的。 若對於哪些元素會生成 inline-level box 不太清楚，可複習上一篇 display 文章。 line box 寬度 line box 是「行」的概念，也是一個矩形範圍，正常情況下，line box 的寬度取決於 Containing block(包含塊)，但若有 float 元素，則 line box 會受到壓縮(shrink)。 直接用實例來看會較具體一點，以下將比較正常情況下與在有 float 元素下，line box 的寬度會如何變化。 Case: 無 float 元素時 以 display: inline-block 為例，該元素屬於 inline-level box，故會產生 line box，而 line box 寬度取決於其 containing block(包含塊)。 12345&lt;div class=\"block-container\"&gt; &lt;div class=\"inline-level-box\"&gt; display: inline-block &lt;/div&gt;&lt;/div&gt; 12345678910111213.block-container { width: 600px; height: 250px; border: 10px solid #333;}.inline-level-box { display: inline-block; /* 為一種 inline-level-box */ height: 100px; color: white; font-size: 20px; background-color: orange;} 此時設定 text-align: center，則橘色的 inline-level box 會水平置中於 line box 裡，這結果應該毫不令人意外。 123.block-container { text-align: center;} Case: 有 float 元素時 當有 float 元素時，line box 會受到 float 元素的擠壓，若擠壓到 line box 無法容納裡面的文字或是 inline-level box 時，line box 就會自動「換行」。 12345678910111213141516171819202122.block-container { width: 600px; height: 250px; border: 10px solid #333; margin: 100px;}.float { float: left; /* float 會擠壓 line box */ width: 100px; height: 150px; color: white; background-color: #F75848;}.inline-level-box { display: inline-block; /* 為一種 inline-level-box */ color: white; font-size: 20px; height: 100px; background-color: orange;} 此時 line box 已經被 float 元素壓縮了。範例連結 設定 text-align: center，讓橘色的 inline-level box 水平置中於被壓縮後的 line box 裡。 123.block-container { text-align: center;} 接著，若 float 元素變更寬，擠壓 line box 更多，多到該行無法再容納橘黃色的 inline-level box 時，line box 就會「換行」。 123.float { width: 500px; /* 變超胖 */} line box 高度 如同上述，line box 是用來裝文字或 inline-levle box 的，所以一個 line box (同一行)高度由位置最高的 inline-level box 頂部與位置最低的 inline-level box 底部的距離。 其中 inline-level box 又可二分為 inline box 與 atomic inline-level box 兩種，像是替換元素 &lt;img&gt; 或 display: inline-block 皆屬於 atomic inline-level box，下一篇文章會說明兩種有何差別(應該會吧)。 Case: 若是 inline box Inline box 僅有 box model 中的 content area 會影響 line box 高度。 Line box 僅取決於 inline box 的 content area (像是 line-height 或 font-size 皆會影響 content area)，不包含 padding、border、margin。 例子 &lt;span&gt; 預設為 display: inline，且非替換元素(nonreplaced elememt)，為 inline-level element 中的 inline element，故其僅有 line-height 會影響 line box，padding、border、margin 皆不會影響 line box 高度。 1234&lt;div&gt;Lorem ipsum, dolor sit add &lt;span&gt;我在 inline box 裡面&lt;/span&gt; Lorem ipsum, dolor sit amet consectetur .&lt;/div&gt; 12345678910div { width: 220px; margin: 200px; border: 1px solid #000;}span { background-color: orange; padding: 10px;} 為方便觀察，給 &lt;span&gt; 背景橘色的顏色，並給 &lt;span&gt; 上下左右 padding 各 10px。 反白區域為一個 line box 高度。可以清楚看見，line box 並沒有被撐高，上下方的文字沒有被推開(但左右有)。 Case: 若是 atomic inline-level box Atomic inline-level box 的整個 box model 會影響 line box 高度。 Line box 取決於 atomic inline-level box 的整個 box model 高度，即包含 padding、border 與 margin 部分。 例子 現在將 &lt;span&gt; 設定為 display: inline-block，&lt;span&gt; 仍然屬於 inline-level element，但由 inline element 變成 atomic inline-level element。 12345span { display: inline-block; /* 變成 atomic inline-level */ background-color: orange; padding: 10px;} 反白區域為一個 line box 高度。可以清楚看見，line box 長高了，所以上下方文字的距離也隔開了！ 註： ① box model 高度為內容區高度 + 上下內距 +上下邊框 + 上下外距，可參考先前文章。 ② 其它替換元素 參考資源 W3C - Inline formatting contexts W3C - Line height calculations W3C - Floats 鉄人28号FX 鉄人2号「文本士」content area","link":"/article/LineBox.html"},{"title":"CSS 原理 - Block Formatting Context","text":"或許你沒聽過 Block Formatting Context，但你肯定有用過！其實在切版時，常常會使用到 BFC，只是你沒有意識到而已，如果能夠有意識的使用 BFC，對於版面的掌控非常有幫助。 什麼是 Block Formatting Context 如同上一篇 CSS 原理 - Formatting Context 所說，Formatting Context 指的是佈局環境，而佈局環境有許多種，不同的佈局環境會有不同的佈局規則，Block Formatting Context (BFC)是其中一種。 下方為一段 W3C 對於 BFC 的敘述： In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse. In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). 簡單來說，處在同一個 BFC 中的元素(盒子)，會有以下現象： 元素(盒子)從其 containing block(包含塊)的頂部開始，一個接一個呈現垂直排列。 若書寫方向為預設的由左至右，則元素(盒子)會貼齊其 containing block(包含塊)左側。 相鄰元素(盒子)之間的垂直距離，由元素的 margin 屬性決定。 相鄰的 block-level box(塊級盒子)垂直方向會發生 margin collapsing(邊距重疊)。 圖示 將上述現象用圖形表示： 1234567&lt;html&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 首先，&lt;html&gt; 會建立一個 BFC (先破梗了)，而 &lt;body&gt; 與三個 &lt;div&gt; 參與的是 &lt;html&gt; 建立的 BFC，也就是說， &lt;body&gt; 與三個 &lt;div&gt; 處於同一個 BFC 中，因此元素會： 呈現垂直排列。 可以用 margin 來推開彼此。 垂直方向會發生 margin collapsing(邊距重疊)，其中 margin collapsing 又分為兩種(同層元素間以及元素與其容器間)，可參考先前文章 CSS 原理 - Collapsing margins。 注意，以上現象強調的是處於同一個 BFC 裡的元素(盒子)，若元素自立門戶創建新的 BFC，則不完全適用，所以了解什麼情況會建立新的 BFC 很重要。 何時會建立 BFC 對於「什麼時候會建立一個 BFC」，其實 W3C 並沒有一個非常正式的定義，有些條件是非常不嚴謹的，而在 MDN 上則有逐一詳細列出，可供參考。 根據 MDN，以下情況的元素會創建 Block Formatting Context(BFC)： &lt;html&gt; float 元素 position: absolute、fixed 的元素 overflow: hidden、scroll、auto 的元素 display: inline-block 的元素 display: flow-root 的元素 display: flex 或 inline-flex 元素的直接子元素，即 flex items display: grid 或 inline-grid 元素的直接子元素，即 grid items display: table、table-caption、table-cell、table-rowtable-row-group、table-header-group、table-footer-groupinline-table contain: layout、content 或 paint 的元素 column-count 或 column-width 不為 auto 的元素 column-span 為 all 的元素 BFC 功用 可以解決： float 元素的外層容器塌陷問題。 元素間的 margin collapsing(外邊距重疊)問題 float 元素與其他元素的重疊問題 (float 元素遮住其他元素)。 解決 float 元素造成外容器塌陷問題 float 元素會導致外層容器的高度塌陷(若外層容器高度為 auto 且無其它比 float 元素高的子元素)。 例如：範例連結 1234&lt;div class=\"container\"&gt; &lt;span&gt;我是裝著 float 元素的容器&lt;/span&gt; &lt;div class=\"float\"&gt;我是 float 元素&lt;/div&gt;&lt;/div&gt; 1234567891011121314.container { width: 600px; background-color: grey; border: 5px solid #333;}.float { float: left; width: 200px; height: 150px; background-color: yellow; border:1px solid black; padding: 10px;} 此時可以使外層容器建立 BFC 來恢復高度，例如在外層容器加上 overflow: hidden 或 display: flow-root。 123.container{ display: flow-root;} 登愣～外層容器撐開了。 解決 margin collapsing 問題 當元素與元素之間發生 margin collapsing 時，可使元素建立 BFC 來解決 margin collapsing 的問題。 解決 float 元素遮住其他元素的問題 在先前文章 CSS 原理 - Line box 曾提到，float 元素會擠壓 line box，除此之外，float 元素還可能遮住其它元素！ 如果你有用過 float，應該有遇過 float 元素遮住其它非 float 元素的情況，例如： 12&lt;div class=\"float\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt; 12345678910111213.float{ float: left; width: 200px; height: 200px; background-color: orange;}.box{ display: block; width: 300px; height: 300px; background-color: yellow;} 橘色的 float 元素蓋住了黃色元素。 只要讓黃色元素建立 BFC 即可解決重疊問題，例如加上 overflow: hidden 或 display: flow-root。 123.box{ display: flow-root;} 參考資源 W3C-Appendix A: Glossary W3C-Box Layout Modes: the display property W3C-Collapsing margins MDN-Block formatting context","link":"/article/Block-formatting-context.html"},{"title":"CSS 原理 - Box model","text":"想像每個元素都是個盒子，而 &lt;html&gt; 就像是個超級大盒子，裡面裝了許許多多大小不一的盒子，像是 &lt;div&gt;、&lt;p&gt;、&lt;span&gt;、&lt;button&gt;…等等，而每個盒子由四個部分組成。 如下圖所示，box model 由四個部分組成，由內至外依序為 content area (內容區) padding (內距) border (邊框) margin (外距) content area 內容區域，也就是盒子裡裝的東西，可能是文字、圖片或是又裝了其它元素(其他盒子)，例如 &lt;div&gt;、&lt;p&gt;、&lt;span&gt;、&lt;button&gt;…等等。 padding (內距) 可想像成盒子和其內容物的距離，介於 content area(內容區) 與 border(邊框)之間的部分。其特色為 厚度取決於 padding 屬性， 不能為負值。 預設下，padding 不包含在屬性 width 的範圍，因 box-sizing 預設值為 content-box，當然只包含最裡面的 content 部分。 border (邊框) 介於 margin (外距)與 padding(內距) 之間的範圍。 可以使用 border 屬性來設置邊框的寬度、樣式與顏色。 三合一縮寫語法 (三個值的順序可以互換)： 1border: border-width｜border-style｜border-color 亦可單獨指 定border 的寬度、樣式與顏色。個別屬性如下： border-width (邊框寬度) border-style (邊框樣式) border-color (邊框顏色) 預設情況下，不包含在 width 與 height 的範圍內。 margin (外距) margin 圍繞於 border 之外，用於推開元素與其它元素之間的距離。其特色為 厚度取決於 margin 屬性。 可以是正值或負值，但若為負值，可能會與其它元素重疊。 元素本身的背景設定無法渲染至 margin 部分，例如 background-color 或 background-image。 不包含在 width 與 height 範圍內。 box-sizing 一個新手常遇見的問題：奇怪，明明指定了元素的 width 與 height，但元素渲染於畫面上的寬度與高度卻比自己設定的值來得大？ 這問題通常與 box-sizing 有關。 box-sizing 屬性決定如何計算一個元素渲染於畫面上的總寬度與總高度，也就是 size，有 content-box 與 border-box 兩種屬性值。 (一) content-box 1box-sizing: content-box； content-box 為預設值，如同字面上的意思，若該元素可以指定 width 與 height，則在設定 width 或 height 時，其指定的僅為最內層的 content 部分，例如 width: 100px，則代表元素的 content area 寬度為 100px。 如果同時還設定了 padding 或是 border，則必須再加上 padding 與 border，才是最終渲染於畫面上的寬度或高度。 例如： 給定一個 div 的設定如下： codepen 範例連結 12345678div { box-sizing: content-box; /*預設值*/ width: 200px; height: 100px; padding: 20px; margin: 30px; border: 10px solid black;} 則在 content-box 下： 最終渲染寬度 ≠ width 200px 而是 ( width 200 + 左右 padding 20*2 + 左右 border 10*2 )px = 260px ; 最終渲染高度 ≠ height 100px 而是( height 100 + 上下 padding 20*2 + 上下 border 10*2 )px = 160px。 (二) border-box 1box-sizing: border-box; 如同字面上的意思，若該元素可以指定 width 與 height，則 width 和 height 屬性值涵蓋的範圍為 border 以內，也就是 content、padding 和 border，注意，不包括 margin。 border-box 可以使元素渲染於畫面上的總寬度與總高度的計算變得較直覺簡單，不必再額外加上 padding 和 border，連 bootstrap 也對所有元素做了此設定。 例如： 給定一個 div 的設定如下： 在 border-box 下： 最終渲染寬度即為 width 200px ; 最終渲染高度即為 height 100px。 12345678div { box-sizing: border-box; width: 200px; height: 100px; padding: 20px; margin: 30px; border: 10px solid black;} 參考資料 W3C - CSS Box Model Module Level 3 MDN - The box model MDN - box-sizing","link":"/article/box-model.html"},{"title":"CSS 原理 - position","text":"這篇要介紹的是 position，\b顧名思義，它與元素的位置或定位方式有關，了解它的各種屬性值肯定是必要的，像是常見的彈跳視窗或固定導覽列，也都需要它。 position 語法 position 的屬性值有 static、relative、absolute、fixed 與 sticky。 1position: static | relative | absolute | fixed | sticky static 1position: static; 為預設值。 元素為 in-flow。 top、right、bottom 與 left 屬性皆無效。 z-index 屬性無效。 relative 1position: relative; 元素仍為 in-flow，為元素預留原本的空間。 top、right、bottom 與 left 屬性可指定元素相對於自身原本的位置做偏移，不影響其他元素的位置。 此屬性值對 display 值為 table-row-group、table-header-group、table-footer-group、table-row、table-column-group、 table-column、table-cell 與 table-caption 的元素無效。 absolute 1position: absolute; 元素 out-of-flow，不為元素預留原本的空間。 相對於祖譜中最接近且 position 值非 static 的containing block(包含塊)做定位，若無，則追溯至 initial containing block (初始包含塊)，在連續媒體下即為 veiwport (視口)。 top、right、bottom 與 left 屬性可指定其對於containing block(包含塊)的偏移量，不影響其他元素的位置。 不會與其他元素發生 margin collapsing(外距重疊)，因為會建立一個新的 BFC。 建立 Block Formatting Context(BFC)。 fixed 1position: fixed; 元素 out-of-flow，不為元素預留原本的空間。 containing block(包含塊)為 veiwport，所以會以 veiwport 做定位，滾動時，元素相對於 viewport 仍處於同一位置。 上層元素中若有 transform 屬性非 none 的祖先時，containing block(包含塊)由 veiwport 改為該祖先，即針對該祖先定位。 top、right、bottom 與 left 屬性可指定其對於containing block的偏移量。 不會與其他元素發生 margin collapsing(外距重疊)。 建立 Block Formatting Context(BFC)。 sticky 為相對定位(relative)和固定定位(fixed)的混合體。元素在跨越特定門檻(specified threshold)之前屬於相對定位，之後屬於固定定位。 1position: sticky; 元素為 in-flow。 必須指定 top、right、bottom 或 left 其中一個做為特定門檻(specified threshold)，sticky 才有效，即使是 top: 0。 相對於最近的可滾動祖先和 containing block 做定位。 top、right、bottom 與 left 屬性可指定其偏移量，不影響其他元素的位置。 建立 Block Formatting Context(BFC)。 例如: 12345&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;1&lt;/div&gt; &lt;div class=\"box\"&gt;2&lt;/div&gt; &lt;div class=\"box\"&gt;3&lt;/div&gt;&lt;/div&gt; 123456789101112.container{ width: 280px; height: 1850px; /* 可滾動 */}.box{ position: sticky; top: 150px; /* 門檻值(必要條件) */ width: 70px; height: 70px; margin-bottom: 100px;} 參考資源 W3C-hoosing a positioning scheme: ‘position’ property MDN-position MDN-Block formatting context","link":"/article/Position.html"},{"title":"CSS 原理 - 你所不知道的 display","text":"Visual formatting model (視覺格式化模型) 對於排版來說是很重要的觀念，但不是那麼平易近人且有點抽象，在初次看 W3C 規範 時一定是霧煞煞，強烈建議先釐清幾個重要名詞的定義，會發現繞來繞去，講的其實都是相同的概念。 display 為什麼 display: block 的元素們會呈現垂直排列？為什麼 display: inline 的元素們會呈現水平排列？又為什麼 display: inline-block 的元素是呈現水平排列呢？其實答案都與元素生成(generate)何種類型的 box 有關。 在先前 box model 文章中曾介紹，元素就像一個個的盒子 (box)，這篇將介紹在 in flow 下，這些「 盒子如何排列」，或說是「元素如何佈局」。 元素在 in flow 下如何佈局的主要關鍵為該元素「生成 (generate)了什麼類型的 box」，而這會取決於元素的 display 屬性。其實我們所熟悉的 display 同時定義了元素的兩種 display type： outer display type：決定元素「本身」在 in flow 下如何佈局，即元素本身參與的是何種 formatting context (格式化上下文)。 inner display type：決定元素為它的後裔元素建立何種 formatting context，與其後裔元素的佈局有關。 outer display type 在 outer display type 方面，box 類型可分成 inline-level box 與 block-level box 兩大類，所有 inline-level box 皆會參與 IFC，呈現水平排列，而所有 block-level box 皆會參與 BFC，呈現垂直排列。 inline-level box (行內級盒子) inline box (行內盒子) atomic inline-level box (原子行內級盒) block-level box (塊級盒子) inner display type 在 inner display type 方面，因其描述的是元素本身與其內容或後裔元素的關係，可以想像成元素像個容器 (container)，裝著文字內容或後裔元素。常見的 container box 類型有 block container box、flex container box 與 grid container box 等等。 而什麼類型的 container box，就會為其內容或後裔元素建立什麼類型的 formatting context，例如： flex container 建立 flex formatting context (FFC) grid container 建立 grid formatting context (GFC) block container 可建立 block formatting context (BFC) 或 inline formatting context (IFC) 順帶一提，替換元素\b (replaced element)，例如 &lt;img&gt;，display 的預設值為 inline，不論將其 display 屬性值改成什麼，皆不會有 container box，因為它就是路徑來源的圖片，不是用來裝像是 &lt;span&gt;、&lt;div&gt; 或其他元素的容器。 圖片來源: W3C 了解 display 的好處 講了這麼多，了解 display 到底有什麼好處？ 個人認為至少有三大優點。 秒殺元素排列方式 即使遇到一個從來沒用過的 display 屬性值，也能夠馬上知道在 in flow 下，元素會如何排列，例如，你有聽過或用過 display: flow-root 或 inline-flex 嗎？ 在沒有用過，甚至從沒聽過的情況下，一看 display 表就可以得知 display: flow-root 的元素會生成 block-level box，故元素本身參與 BFC，在 in flow 下會呈現垂直排列。而 display: inline-flex 會生成 inline-level box，故元素本身參與 IFC，在 in flow 下會呈現水平排列。 秒殺屬性的適用對象 例如常用的 vertical-align 與 text-align 對齊，你知道他們能操控的對象總共有哪些嗎？ 其實他們是在操控 inline-level 的垂直與水平對齊。 vertical-align 屬性可以適用於所有 inline-level boxes，也就是可以操控 display 表上所有會生成 inline-level box 元素的垂直對齊。 圖片來源：W3C 而 text-align 的屬性則是須設定在 inline-level 外層的 block container，它可操控 display 表上所有會生成 inline-level box 元素的水平對齊。 圖片來源：W3C 再例如，margin: 0 auto，常用在 display: block 元素的水平置中，但除此之外，還可以用在哪些元素上呢？ 其實 display 表上會生成 block-level box 的皆適用。 何種 display 會產生 BFC 就如同剛剛提及的，什麼類型的 container box 就會建立什麼類型的 formatting context，所以 block container box 可以建立 BFC，這時就可以由 dispaly 表中得知 display: inline-block 與 flow-root 皆會建立 BFC (display: block 例外)。 另外，其實 display: table 與 inline-table 亦會建立 BFC，因生成的 table wrapper box 也是一種 block container。 block formatting context (BFC) 在排版中是非常重要的一環，這部分的介紹留在之後文章再詳細說明。 參考資源 W3C-Controlling box generation W3C-Appendix A: Glossary W3C-Box Layout Modes: the display property","link":"/article/display.html"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"w3HexSchool","slug":"w3HexSchool","link":"/tags/w3HexSchool/"}],"categories":[{"name":"web","slug":"web","link":"/categories/web/"}]}