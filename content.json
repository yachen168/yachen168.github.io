{"pages":[{"title":"About","text":"","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Project","text":"","link":"/project/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"CSS 原理 - Block Formatting Context","text":"或許你沒聽過 Block Formatting Context，但你肯定有用過！其實在切版時，常常會使用到 BFC，只是你沒有意識到而已，如果能夠有意識的使用 BFC，對於版面的掌控非常有幫助。 什麼是 Block Formatting Context 如同上一篇 CSS 原理 - Formatting Context 所說，Formatting Context 指的是佈局環境，而佈局環境有許多種，不同的佈局環境會有不同的佈局規則，Block Formatting Context (BFC)是其中一種。 下方為一段 W3C 對於 BFC 的敘述： In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse. In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). 簡單來說，處在同一個 BFC 中的元素(盒子)，會有以下現象： 元素(盒子)從其 containing block(包含塊)的頂部開始，一個接一個呈現垂直排列。 若書寫方向為預設的由左至右，則元素(盒子)會貼齊其 containing block(包含塊)左側。 相鄰元素(盒子)之間的垂直距離，由元素的 margin 屬性決定。 相鄰的 block-level box(塊級盒子)垂直方向會發生 margin collapsing(邊距重疊)。 圖示 將上述現象用圖形表示： 1234567&lt;html&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 首先，&lt;html&gt; 會建立一個 BFC (先破梗了)，而 &lt;body&gt; 與三個 &lt;div&gt; 參與的是 &lt;html&gt; 建立的 BFC，也就是說， &lt;body&gt; 與三個 &lt;div&gt; 處於同一個 BFC 中，因此元素會： 呈現垂直排列。 可以用 margin 來推開彼此。 垂直方向會發生 margin collapsing(邊距重疊)，其中 margin collapsing 又分為兩種(同層元素間以及元素與其容器間)，可參考先前文章 CSS 原理 - Collapsing margins。 注意，以上現象強調的是處於同一個 BFC 裡的元素(盒子)，若元素自立門戶創建新的 BFC，則不完全適用，所以了解什麼情況會建立新的 BFC 很重要。 何時會建立 BFC 對於「什麼時候會建立一個 BFC」，其實 W3C 並沒有一個非常正式的定義，有些條件是非常不嚴謹的，而在 MDN 上則有逐一詳細列出，可供參考。 根據 MDN，以下情況的元素會創建 Block Formatting Context(BFC)： &lt;html&gt; float 元素 position: absolute、fixed 的元素 overflow: hidden、scroll、auto 的元素 display: inline-block 的元素 display: flow-root 的元素 display: flex 或 inline-flex 元素的直接子元素，即 flex items display: grid 或 inline-grid 元素的直接子元素，即 grid items display: table、table-caption、table-cell、table-rowtable-row-group、table-header-group、table-footer-groupinline-table contain: layout、content 或 paint 的元素 column-count 或 column-width 不為 auto 的元素 column-span 為 all 的元素 BFC 功用 可以解決： float 元素的外層容器塌陷問題。 元素間的 margin collapsing(外邊距重疊)問題 float 元素與其他元素的重疊問題 (float 元素遮住其他元素)。 解決 float 元素造成外容器塌陷問題 float 元素會導致外層容器的高度塌陷(若外層容器高度為 auto 且無其它比 float 元素高的子元素)。 例如：範例連結 1234&lt;div class=\"container\"&gt; &lt;span&gt;我是裝著 float 元素的容器&lt;/span&gt; &lt;div class=\"float\"&gt;我是 float 元素&lt;/div&gt;&lt;/div&gt; 1234567891011121314.container { width: 600px; background-color: grey; border: 5px solid #333;}.float { float: left; width: 200px; height: 150px; background-color: yellow; border:1px solid black; padding: 10px;} 此時可以使外層容器建立 BFC 來恢復高度，例如在外層容器加上 overflow: hidden 或 display: flow-root。 123.container{ display: flow-root;} 登愣～外層容器撐開了。 解決 margin collapsing 問題 當元素與元素之間發生 margin collapsing 時，可使元素建立 BFC 來解決 margin collapsing 的問題。 解決 float 元素遮住其他元素的問題 在先前文章 CSS 原理 - Line box 曾提到，float 元素會擠壓 line box，除此之外，float 元素還可能遮住其它元素！ 如果你有用過 float，應該有遇過 float 元素遮住其它非 float 元素的情況，例如： 12&lt;div class=\"float\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt; 12345678910111213.float{ float: left; width: 200px; height: 200px; background-color: orange;}.box{ display: block; width: 300px; height: 300px; background-color: yellow;} 橘色的 float 元素蓋住了黃色元素。 只要讓黃色元素建立 BFC 即可解決重疊問題，例如加上 overflow: hidden 或 display: flow-root。 123.box{ display: flow-root;} 參考資源 W3C-Appendix A: Glossary W3C-Box Layout Modes: the display property W3C-Collapsing margins MDN-Block formatting context","link":"/article/Block-formatting-context.html"},{"title":"CSS 原理 - Containing block","text":"Containing block，中文常被翻譯為包含塊，它其實代表的是一個「區域」，一個由 box model 的 content edge 或 padding edge (若有設定 padding)所圍繞的範圍，它攸關元素的定位、寬高、內距與外距的計算，所以必須清楚知道元素的 containing block 是誰，才不會使畫面失控。 例如，在元素設定 width、height、padding、margin 屬性時，若屬性值給予的單位為百分比(％)，則將會以該元素的 containing block 為基準去做計算，再例如，元素的 position定位，也與該元素的 containing block 有關。 如何尋找包含塊： 一個容易犯的錯誤是直接將元素的「父層」視為該元素的 containing block，事實上，在有些情況下並非如此，像是 position: absolute 與 fixed 時。大致情況如下： 根元素 &lt;html&gt; 的 containing block 稱為 initial containing block (初始包含塊)，而在連續媒體下，initial containing block 即為 viewport (視口)。 若元素的 position 屬性值為 static、relative 或 sticky，則 containing block 為距離該元素最近的祖先 block container 或 formatting context (格式化上下文)的 contnet edge (內容區邊緣)組成。 其中，block container 並不完全等於 display: block，像是 display: inline-block 與 list-item 也會形成 block container，這部分有興趣可參考 W3C display 表格。 至於 formatting context ，其實它只是一個「環境」，大致可分為幾種環境，像是 block formatting context、flex formatting context 或 grid formatting context，之後有機會再介紹。 若元素 position 屬性值為 absolute，則其 containing block 為距離它最近且 position 屬性值非 static（即為 fixed、absolute、relative 或 sticky）的祖先元素的 padding edge(內距邊緣)組成。 若元素 position 屬性值為 fixed，則其 containing block 在連續媒體下為 viewport。 如果 position 屬性值為 absolute 或 fixed，containing block 也可能是由滿足以下條件的最接近祖先元素的內容區邊緣組成： transform 或 perspective 屬性值不為 none。 filter 屬性值不為 none。 來看幾個例子吧 例 1. 找出 &lt;p&gt; 的包含塊，並且計算出 &lt;p&gt; 最終的寬、高、內距與外距。 在此例子中，因為 &lt;p&gt; 的 position 值為預設的 static，故其包含塊為距離它最近的 block container 的 padding edge(內距邊緣)所圍繞範圍，又因 &lt;p&gt; 的 width、 height、margin 與 padding 單位皆為百分比(%)，所以會以 containing block，即 &lt;section&gt; 為基準來計算。 12345&lt;body&gt; &lt;section&gt; &lt;p&gt;This is a paragraph!&lt;/p&gt; &lt;/section&gt;&lt;/body&gt; 123456789101112section { display: block; width: 400px; height: 160px;}p { width: 50%; /* == 400px * .5 = 200px */ height: 25%; /* == 160px * .25 = 40px */ margin: 5%; /* == 400px * .05 = 20px */ padding: 5%; /* == 400px * .05 = 20px */} 例 2. 現在將 &lt;section&gt; 改為 display: inline。 找出 &lt;p&gt; 的包含塊，並且計算出 &lt;p&gt; 最終的寬度。 在此例子中，&lt;p&gt; 的 position 依舊是預設的 static，但是 &lt;section&gt; 不再是 block container，沒有形成一個格式化上下文，故 &lt;p&gt; 的包含塊為 &lt;body&gt; 內距邊緣所圍範圍。 &lt;p&gt; 的寬度將以 &lt;body&gt; 為基準計算。 12345&lt;body&gt; &lt;section&gt; &lt;p&gt;This is a paragraph!&lt;/p&gt; &lt;/section&gt;&lt;/body&gt; 12345678section { display: inline;}p { width: 50%; /* == half the &lt;body&gt;'s width */ height: 200px; /* Note: a percentage would be 0 */} 例 3. 包含塊有內距(padding)。 找出 &lt;p&gt; 的包含塊，並且計算出 &lt;p&gt; 的最終寬度、高度、外距與內距。 在此例中，P元素的包含塊是 &lt;section&gt;，因為 &lt;section&gt; 的 position 值非 static。 &lt;p&gt; 百分值會受其包含塊 &lt;section&gt; 的 padding 所影響。若將包含塊的 box-sizing 值設置為 border-box，就可以避免這個問題。 12345&lt;body&gt; &lt;section&gt; &lt;p&gt;This is a paragraph!&lt;/p&gt; &lt;/section&gt;&lt;/body&gt; 12345678910111213141516section { position: absolute; left: 30px; top: 30px; width: 400px; height: 160px; padding: 30px 20px;}p { position: absolute; width: 50%; /* == (400px + 20px + 20px) * 50% = 220px */ height: 25%; /* == (160px + 30px + 30px) * 25% = 55px */ margin: 5%; /* == (400px + 20px + 20px) * 5% = 22px */ padding: 5%; /* == (400px + 20px + 20px) * 5% = 22px */} 參考資源 W3C-Containing blocks MDN-Layout and the containing block 每天來點 CSS Specification-Visual Formatting Model - 定義、containing block","link":"/article/Containing-block.html"},{"title":"CSS 原理 - Formatting Context","text":"每個元素都是一個個的盒子(box)，這些盒子在 in flow 下會如何排列就要看該盒子處在什麼樣的佈局環境，而 formatting context (格式化上下文) 指的就是佈局環境，不同類型的佈局環境會有不同的佈局規則，換句話說，處在不同類型佈局環境裡的盒子，排列方式會有所不同。 什麼是 Formatting Context 先來看一段 W3C 規範對於 formatting context (格式化上下文) 的敘述。 摘自 W3C A formatting context is the environment into which a set of related boxes are laid out. Different formatting contexts lay out their boxes according to different rules. A box either establishes a new independent formatting context or continues the formatting context of its containing block. The type of formatting context established by the box is determined by its inner display type. Additionally, some types of formatting contexts interleave and co-exist. 也就是說，formatting context 指的是一個「佈局環境」，處在什麼佈局環境裡的元素(盒子)，就得遵守什麼環境的佈局規則，盒子也可以自立門戶，建立新的 formatting context，再繼續裝其它盒子，而會建立什麼類型的 formatting context，取決於 display 屬性的 inner display type。可參考先前文章 你所不知道的 display。 有些類型的 formatting contexts 可以同時交互並存，像是 BFC 與 IFC 或是 FFC 與 IFC 等。 Formatting Context 類型 Formatting context 大致有以下幾種，其中，BFC 與 IFC 對於排版來說最為重要，而除了 BFC 較為特殊之外，其餘的 formatting context 取決於元素的 display 屬性。 Block Formatting Context (BFC) Inline Formatting Context (IFC) Flex Formatting Context (FFC) Grid Formatting Context (GFC) Ruby Formatting Contect (RFC) Independent Formatting Context 剛提到盒子可以自立門戶，為其後裔元素建立自己的 formatting context，而當一個元素(盒子)建立了獨立的 formatting context，不論所建立的類型是否與該元素所處的 formatting context 相同，都是為其後裔元素建立了一個新的佈局環境，所以其後裔元素的佈局通常不必再遵守該元素所處的佈局環境規則。 值得留意的是，除了 display 之外，有些屬性也會使元素建立獨立的 formatting context，像是 float、position: absolute 或 fixed 這些會使元素脫離正常流(out-of-flow)的屬性皆會建立獨立的 formatting context。 圖解 Formatting Context 「Formatting context 是個佈局環境，不同的 formatting context 有不同的佈局方式」，用圖形或許可以幫助理解，以下將舉三個例子，主要為 BFC 與 IFC，其他類型的 formatting context 概念皆相同，可以此類推。 下圖截取部分 W3C 規範中的 display 表格，若對於這個表格感到陌生的讀者，建議先看先前文章 你所不知道的 display。 圖片來源: W3C Case1: BFC &lt;html&gt; 就是個超級大盒子，裡面裝著其他盒子，且會建立一個 BFC，由上方 display 表可知，其後裔元素 &lt;body&gt; 與三個橘色的 block 元素皆會生成 block-level box，且處在 BFC 裡(或說是參與 BFC)，所以會呈現垂直排列。 Case2: IFC 由上方 display 表可知，&lt;body&gt; 對內會生成 block container，可以建立 IFC，而其兩個橘色的 inline 後裔元素會生成 inline box(為一種 inline-level box)，且處在此 IFC 中(或說是參與該 IFC)，所以呈現水平排列。 Case3: 混合 inline-block 元素會生成inline-level box，該元素本身處在 &lt;body&gt; 所建立的 IFC 中(或說是參與該 IFC)，且兩個 inline-block 元素分別為其後裔元素建立了新的獨立佈局環境──BFC 與 IFC，所以其後裔元素不會與 inline-block 元素一同參與外部 IFC。 結語 說穿了，formatting context 就真的只是「佈局環境」而已，花了一個篇幅解釋 formatting context 其實是在替後面的文章鋪路，接下來將介紹在排版中最為重要的 block formatting context(BFC)。 參考資料 W3C - Appendix A: Glossary W3C - Box Layout Modes: the display property W3C - Block-level elements and block boxes W3C - Inline-level elements and inline boxes","link":"/article/Formatting-context.html"},{"title":"CSS 原理 - Flex(上)","text":"接下來將介紹 flex，從先前 formatting context 的觀念開始，再詳細介紹每個屬性的用法以及 flex box 伸縮的計算方式。 display: flex | inline-flex flex container 顧名思義就是一個容器(container)，描述 flex 元素與其後裔元素之間的關係，當對一個元素設定 display: flex 時，此元素稱為 flex container，而其直接子元素則稱為 flex item。 display: flex 的元素會生成 block-level box 與 flex container，所以該元素本身會參與 BFC 佈局，呈現垂直排列，另一方面，為其內容建立 FFC。 display: inline-flex 的元素會生成 inline-level box 與 flex container，所以該元素本身會參與 IFC 佈局，且會為其內容建立 FFC。 flex container display 為 flex 或 inline-flex 的元素。 flex container 會建立 flex formatting contex(FFC)，所以此元素不會與 float 元素重疊。 column-* 屬性不適用。 flex item display 為 flex 或 inline-flex 元素的子元素稱為 flex item。 建立 BFC，所以 flex items 之間不會發生 margin collapsing，也不會與其父元素(flex container)發生 margin collapsing。 參與 FFC。 vertical-align 不適用。 float 與 clear 不適用。 即使 flex item 是 display: inline 的元素，仍然可以透過 width 與 height 屬性調整寬高。因 flex item 是 blockified。 主軸(main axis)與副軸(cross axis) flex items 可以透過 flex-direction 屬性來決定排列方向，flex-direction 同時也會決定主軸(main axis)與副軸(cross axis)。 圖片來源：W3C flex-direction 共有四個屬性值，會受到書寫方向 writing-mode 影響。 以橫向且由左至右的書寫方式來說，此時 row 為橫向，column 為直向。 flex-direction: row 主軸為 row 方向。 副軸為 column 方向。 由 main start 至 main end 排列。 flex-direction: row-reverse 主軸為 row 方向。 副軸為 column 方向。 由 main end 至 main start 排列。 flex-direction: column 主軸為 column 方向。 副軸為 row 方向。 由 main start 至 main end 排列。 flex-direction:column-reverse 主軸為 column 方向。 副軸為 row 方向。 由 main end 至 main start 排列。 flex-wrap flex-wrap 屬性適用於 flex container，有 nowrap、wrap 與 wrap-reverse 三種屬性值。 圖片來源：W3C nowrap 1flex-wrap: nowrap 不換行，為預設值。 wrap 1flex-wrap: wrap; 換行，由 cross start 開始向 cross end 堆疊。 wrap-reverse 1flex-wrap: wrap-reverse; 可換行，由 cross end 開始向 cross start 堆疊。 flex-flow 屬性 flex-direction 屬性與 flex-wrap 屬性的縮寫。 例如： 1flex-flow: row wrap; 上式等同於 12flex-direction: row; /* 預設值 */flex-wrap: wrap; 又例如： 1flex-flow: row-reverse wrap-reverse; 上式等同於 12flex-direction: row-reverse;flex-wrap: wrap-reverse; order 屬性 order 屬性可以控制 flex items 的順序，會從 order 最小的開始排序。 僅適用於 flex items，屬性值須為整數(可為負數)， 預設下皆為 0。 圖片來源：W3C 直接看圖比較快～ 例如在書寫方向為橫向且由左至右的前提下，若主軸(main axis)為 row，即 flex-direction: row，則 flex items 的會依照其 order 由左至右排序(order 愈小愈優先)。 1 &lt; 3 &lt; 4 -5 &lt; -2 &lt; 4 &lt; 8 若主軸(main axis)為 column，即 flex-direction: column，則 flex items 會依照其 order 由上至下排序(order 愈小愈優先)。 1 &lt; 3 &lt; 4 -10 &lt; 4 &lt; 7 &lt; 13 參考資料 W3C-CSS Flexible Box Layout Module Level 1 MDN-Controlling Ratios of Flex Items Along the Main Axis CSS TRICKS-A Complete Guide to Flexbox","link":"/article/Flex.html"},{"title":"CSS 原理 - Flex(中)","text":"這篇將介紹 flex 屬性，並且深入探討 flex 究竟是如何計算伸縮的比例。 名詞介紹 若要理解 flex 是如何計算伸縮比例，首先需要了解一下 positive free space 與 negative free space 這兩個名詞。 positive free space 若 flex items 在主軸(main axis)方向上的尺寸總和小於 flex container 的尺寸，此時會出現 flex container 的空間沒有被填滿，這些剩餘空間就稱為 positive free space。 例如，在主軸(main axis)為 row 下，若 flex container 的寬度為 500px，而 a、b、c 三個 flex items 寬度各為 100px，此時 flex container 還有 200px 的 positive free space。 圖片來源 MDN negative free space 若 flex items 在主軸(main axis)方向上的尺寸總和大於 flex container 的尺寸，此時 flex container 的空間不夠用，而 flex items 的尺寸總和與 flex container 尺寸的差額就稱為 negative free space。 例如，在主軸(main axis)為 row 下，若 flex container 的寬度為 500px，而 a、b、c 三個 flex items 寬度各為 200px，此時 flex container 的寬度 500px 小於 flex items 的寬度總和 600px，negative free space 為 600px 減 500px，等於 100px。 圖片來源 MDN flex 屬性 圖片來源：W3C 1flex: flex-grow ｜ flex-shrink ｜ flex-basis; 為三個屬性 flex-grow、flex-shrink 與 flex-basis 的縮寫。 flex-grow: 決定 flex item 將得到多少比例的 positive free space。 flex-shrink: 決定 flex item 將得到多少比例的 negative free space。 flex-basis: 決定 flex item 在尚未 grow 與 shrink 前的原始尺寸。 預設值為 flex: 0 1 auto flex-grow 以 flex-basis 為基礎，決定 positive free space 的分配比例，所以有 positive free space 才有作用。 必須為 ≥ 0 的值。 若為 0 (預設值)，則不會延伸。 計算方式 在 flex-direction: row 下，有一個寬度為 500px 的 flex container，與三個寬度各為 100px、80px、70px 的 flex items，則在預設下會有 500px - 250px = 250px 的 positive free space 。 123456&lt;div class=\"container\"&gt; &lt;div class=\"item1\"&gt;item1&lt;/div&gt; &lt;div class=\"item2\"&gt;item2&lt;/div&gt; &lt;div class=\"item3\"&gt;item3&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021.container { display: flex; outline: 3px solid #444; width: 500px; height: 120px; } .item1 { width: 100px; flex: 0 1 auto; /* 此為預設值 */}.item2 { width: 80px; flex: 0 1 auto; /* 此為預設值 */}.item3 { width: 70px; flex: 0 1 auto; /* 此為預設值 */} 現在將三個 flex items 的 flex-grow 分別設定為 1、2、2。 item1 將分配到 1/(1+2+2) = 1/5 的 positive free space。最終寬度為 150px。 item2 將分配到 2/(1+2+2) = 2/5 的 positive free space。最終寬度為 180px。 item3 將分配到 2/(1+2+2) = 2/5 的 positive free space。最終寬度為 170px。 123456789101112131415.item1 { width: 100px; flex: 1 1 auto; /* 將 flex-grow 改為 1，將佔 1/5 等分 */}.item2 { width: 80px; flex: 2 1 auto; /* 將 flex-grow 改為 2，將佔 2/5 等分 */} .item3 { width: 70px; flex: 2 1 auto; /* 將 flex-grow 改為 2，將佔 2/5 等分 */} flex-shrink 以 flex-basis 為基礎，決定 negative free space 的分配比例，所以有 negative free space 才有作用。 必須為 ≥ 0 的值。 若為 0，則不會收縮，此時若 container 空間不夠，會發生 overflow。 預設值為 1。 flex items 不會縮短至小於 min-content 的尺寸，除非設定 min-width 或 min-height 屬性。 計算方式 flex container 寬度為 500px，其三個 flex items 寬度各為 200px，故此時有 100px 的 negative free space，若將所有 flex items 的 flex-shrink 皆設定為 0，則將發生 overflow。 12345&lt;div class=\"container\"&gt; &lt;div class=\"item1\"&gt;item1&lt;/div&gt; &lt;div class=\"item2\"&gt;item2&lt;/div&gt; &lt;div class=\"item3\"&gt;item3&lt;/div&gt;&lt;/div&gt; 1234567891011.container { display: flex; width: 500px; height: 120px; outline: 3px solid #333;}.container &gt; * { width: 200px; /* 所有 flex items 寬度皆為 200px */ flex: 0 0 auto; /* 將所有的 flex-shrink 設定為 0 */} 現在將第一個與第二個 flex item 的 flex-shrink 分別設定為 1 與 4，第三個 flex item 的 flex-shrink 依然為 0。 注意，shrink 與 grow 的計算方法並不相同，公式可參考 前端新手村 flex grow &amp; shrink 演算法。 negative free space = 500px - 200 *3 = -100px item 1 將分配到 1/5 的 negative free space，所以最後寬度為 180px。 算法： 1 * 200/(1 * 200 + 4 * 200 + 0 * 200)= 1/5 item 2 將分配到 4/5 的 negative free space，所以最後寬度為 120px。 算法： 4 * 200/(1 * 200 + 4 * 200 + 0 * 200)= 4/5 item 3 將分配到 0/5 的 negative free space，所以最後寬度為 200px。 算法： 0 * 200/(1 * 200 + 4 * 200 + 0 * 200)= 0 1234567891011.item1 { flex: 0 1 auto; /* 佔 1*200/(1*200+4*200+0*200)= 1/5 等份 */}.item2 { flex: 0 4 auto; /* 佔 4*200/(1*200+4*200+0*200)= 4/5 等份 */}.item3 { flex: 0 0 auto; /* 佔 0*200/(1*200+4*200+0*200)= 0 等份 */} flex-basis 決定 flex item 在尚未 grow 或 shrink 前的原始尺寸。 預設值為 auto。 若有指定尺寸 width、height (視主軸 main axis 而定)，則依照所指定的尺寸。 若無指定尺寸 width、height (視主軸 main axis 而定)，則由其內容大小決定。 若為 0，則 flex item 不被納入空間計算。例如有一個 container 寬度 400px，裡面有 item1 與 item2，寬度各為 200px，此時 flex-basis 為預設的 auto，故沒有剩餘空間。但若將 item2 的 flex-basis 設為 0，則會有 200px 的剩餘空間，原因是 flex-basis 優先級高於 width 與 height。 除了 auto 之外，尚有 content、max-content、min-content 等屬性值，不過多數瀏覽器不支援。 可給定有單位的數值，例如 100px 或 10%，若同時設定 flex-basis (非 auto) 和尺寸(width 或 height，視主軸 main axis 而定)，則以 flex-basis 為優先。 例如： 有三個 flex items，指定第一個 flex item 的 width 為 200px， 在 flex-direction: row 且 flex-grow 與 flex-shrink 皆為 0 的前提下，設定 flex-basis 值為 auto，此時 第一個 flex item 的寬度為 200px。 第二與第三個 flex item 的寬度為其內容尺寸。 12345&lt;div class=\"container\"&gt; &lt;div&gt;flex item 1&lt;/div&gt; &lt;div&gt;flex item 2&lt;/div&gt; &lt;div&gt;flex item 3&lt;/div&gt;&lt;/div&gt; 123456789101112131415div { outline: 1px solid #333;}.container { display: flex;}.container :first-child { width: 200px; /* 第一個子元素給定寬度 200px */}.container &gt; * { flex: 0 0 auto; /* 所有子元素的 flex basis 為 auto*/} flex 屬性另類寫法 flex 屬性除了直接給定 flex-grow、flex-shrink、flex-basis 三個值之外，還有以下幾種寫法。 flex: initial flex: auto flex: none flex: &lt;正數&gt; 註：&lt;正數&gt; 可不必為整數，例如可為 0.5。 以下分別說明這四種屬性值的意義。 flex: initial 1flex： initial; 等同於 1flex： 0 1 auto; flex item 會依照 width 或 height (視主軸 main axis 而定)屬性決定其尺寸，即使 container 中有剩餘空間，flex item 仍無法延伸，但當空間不足時，元素可收縮。 flex: auto 1flex: auto; 等同於 1flex: 1 1 auto; flex item 可延伸與收縮，會依照 width 或 height (視主軸 main axis 而定)屬性決定其尺寸。若所有 flex items 均設定 flex: auto 或 flex: none，則在 flex items 尺寸決定後，剩餘空間會被平分給 flex: auto 的 flex items。 flex: none 1flex: none; 等同於 1flex: 0 0 auto; flex item 不可延伸與收縮，會依照 width 或 height (視主軸 main axis 而定)屬性決定其尺寸。 flex: positive-number 1flex: &lt;正數&gt;; 等同於 1flex: &lt;正數&gt; 1 0; flex item 可延伸與收縮，flex-basis 為 0，故 flex item 會依據所設定的比例佔用 container 中的剩餘空間。 例如 1flex: 2; 等同於 1flex: 2 1 0; 可利用此種屬性值的指定方式，輕易地決定 flex items 在 flex container 中所佔的尺寸比例 (width 或 height，視主軸 main axis 而定)。 例如，一個 flex container 裡面有三個 flex items，希望不管 container 如何變化，這三個 items 的尺寸皆一樣大，則可設定每個 items 的 flex 屬性有相同的正數(positive-number)。 12345&lt;div class=\"container\"&gt; &lt;div class=\"item1\"&gt;&lt;/div&gt; &lt;div class=\"item2\"&gt;&lt;/div&gt; &lt;div class=\"item3\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516.container { display: flex; height: 120px;}.item1 { flex: 1; /* 將得到容器中剩餘空間的 1/(1+1+1)＝1/3 等份 */}.item2 { flex: 1; /* 將得到容器中剩餘空間的 1/(1+1+1)＝1/3 等份 */}.item3 { flex: 1; /* 將得到容器中剩餘空間的 1/(1+1+1)＝1/3 等份 */} 註：只要是相同正數即可，其僅代表比例關係。 且不論容器如何變動(例如縮放視窗時)，比例皆為 1 : 1 : 1。 同理，若希望這三個 flex items 的尺寸比例分別為 3 : 2 : 1，則可設定： 1234567891011.item1 { flex: 3; /* 將得到容器中剩餘空間的 3/(3+2+1)＝3/6 等份 */}.item2 { flex: 2; /* 將得到容器中剩餘空間的 2/(3+2+1)＝2/6 等份 */}.item3 { flex: 1; /* 將得到容器中剩餘空間的 1/(3+2+1)＝1/6 等份 */} 且不論容器如何變動(例如縮放視窗時)，比例皆為 3 : 2 : 1。 有關於 flex 屬性以及伸縮的計算方式就介紹到此，下一篇將繼續介紹 flex 的各種對齊方式。 參考資源 W3C-CSS Flexible Box Layout Module Level 1 MDN-Controlling Ratios of Flex Items Along the Main Axis 前端新手村 flex grow &amp; shrink 演算法","link":"/article/Flex2.html"},{"title":"CSS 原理 - Flex(下)","text":"vertical-align、text-align 甚至 float 都是控制不了 flex items 的，flex 有自己專屬的對齊屬性，而因對齊分為水平對齊與垂直對齊，所以首先要先認清楚誰是主軸(main axis)誰是副軸(cross axis)，才不會精神分裂。 先稍微複習一下，主軸(main axis)與副軸(cross axis)的方向取決於 flex direction 屬性與書寫模式 writing-mode，可參考先前文章 CSS 原理 - Flex(上)。 flex 的對齊 要小心的是，有些屬性是適用於 flex container，有些屬性則適用於 flex items，用錯地方是沒反應的唷。 適用於 flex container 的對齊屬性 justify-content align-items align-content 適用於 flex items 的對齊屬性 align-self justify-content 屬性 控制 flex items 在主軸(main axis)方向的對齊方式，僅適用於 flex container。以下為幾個常用且瀏覽器支援度較高的屬性值： • flex-start 為預設值，flex items 由主軸的始端開始排列。 • flex-end flex items 由主軸的末端開始排列。 • center flex items 置中於主軸。 • space-between 第一個 flex item 對齊主軸的始端，最後一個 flex item 對齊主軸的末端，其餘空間平均分佈於 flex items 之間。 • space-around 以 flex-direction: row 來看，每個 flex item 左右像自備 x 空間，第一個與最後一個 flex item 與 container 的之間有 x 空間，而 flex items 兩兩之間有 2x 空間。 • pace-evenly 以 flex-direction: row 來看，每個 flex item 左右各有 x 空間，第一個與最後一個 flex item 與 container 的之間的空間亦為 x。 圖形輔助 用圖形非常好理解，在水平且由左至右的書寫模式下，若主軸為 row (flex-direction：row)，使用此六種屬性值會呈現下圖中的結果。 圖片來源：CSS TRICKS align-items 屬性 控制 flex items 在副軸(cross axis)方向上的對齊方式，僅適用於 flex container。以下為幾個常用且瀏覽器支援度較高的值。 • flex-start flex items 由副軸的始端開始排列。 • flex-end flex items 由副軸的末端開始排列。 • center flex items 置中於副軸。 • stretch 為預設值，這也是為什麼 flex item 在預設下會撐滿容器在副軸上的空間。 • baseline flex items 依照 baseline 對齊。 圖形輔助 在水平且由左至右的書寫模式下，若副軸為 column (flex-direction：row)，使用此五種屬性值會呈現下圖中的結果。 圖片來源：CSS TRICKS align-content 屬性 控制「多行(multi-line)主軸」在副軸上的對齊方式，也就是前提為 flex container 的 flex-wrap 屬性值須為 wrap 或 wrap-reverse，而非預設的 flex-wrap: nowrap。僅適用於 flex container。 以下圖形範例以主軸(main axis)為 row(橫向)，副軸(cross axis)為 column(縱向)來說，即 flex-direction: row 下： • flex-start 「多行(multi-line)主軸」對齊副軸的始端。 • flex-end 「多行(multi-line)主軸」對齊副軸的末端。 • center 「多行(multi-line)主軸」置中於副軸。 • space-between 第一個與最後一個 line 對齊副軸的始端與末端，其餘空間平均分佈於 flex items 之間。 • stretch 延伸撐滿副軸。 • space-around 每個 line 兩旁像自備 x 空間，第一個與最後一個 line 與 container 的之間有 x 空間，而 lines 兩兩之間有 2x 空間。 • space-evenly 每個 line 左右各有 x 空間，第一個與最後一個 line 與 container 的之間的空間亦為 x。 align-self 屬性 也可以單獨控制個別 flex item 在副軸上的對齊方式。僅適用於 flex items。 以主軸(main axis)為 row(橫向)，副軸(cross axis)為 column(縱向)來說，即 flex-direction: row 下： • flex-start flex item 由副軸的始端開始排列。 • flex-end flex item 由副軸的末端開始排列。 • center flex item 置中於副軸。 • stretch flex item 撐滿副軸。 • baseline flex item 對齊 baseline。 總整理 適用於 flex container justify-content 控制主軸上所有 flex items 的對齊。 align-items 控制副軸上所有 flex items 的對齊。 align-content 控制「多行(multi-line)主軸」在副軸上的對齊方式。 適用於 flex items align-self 控制副軸上個別 flex item 的對齊。 參考資料 W3C - Flexible Box Layout Module Level 1 MDN - Aligning Items in a Flex Container CSS TRICKS - A Complete Guide to Flexbox","link":"/article/Flex3.html"},{"title":"JavaScript 閉包與範圍 ── Execution Context","text":"閉包(closure)在 JavaScript 中佔著重要的地位，但閉包本人其實不太好搞，先從與閉包密不可分的 ── 作用範圍(Scope)開始下手吧！這篇將從執行背景空間(execution context)開始介紹，一步步看 JavaScript 引擎是如何追蹤程式碼的執行，然後…等時機到了就會知道什麼是閉包了(吧)。 如果不相信閉包本人很難搞的話，可以打開 MDN，你會看到閉包的定義為： 英版 MDN： A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time. 中版 MDN： 閉包（Closure）是函式以及該函式被宣告時所在的作用域環境（lexical environment）的組合。 如果你看不懂 MDN 在說什麼，別鐵齒了~還是先繞過閉包本人吧！ Execution Context (執行背景空間) 由於 JavaScript 屬於單執行緒(Single Thread)，也就是它「一次只能做一件事」，所以當它要去執行另一件任務 B 時，就勢必得先暫停手上正在進行的任務 A，等待任務 B 執行完畢後，再回過頭繼續完成任務 A。若是在執行任務 B 時，又被叫去做任務 Ｃ，這時又得停下手邊的任務 B，先去執行完任務 C，接著回頭處理完任務 B，最後再回到任務 A。以此類推，因此所有一連串的任務都需要被追蹤。 每個任務都有一個執行背景空間(execution context)，JavaScript 引擎用 call stack 來追蹤它們。 在 JavaScript 中，有兩種執行背景空間(execution context)： 全域執行背景空間 只有一個，且總是最早被建立的，負責處理全域中的程式碼。 函式執行背景空間 每呼叫函式一次，就會建立一個新的函式執行背景空間，負責處理函式中的程式碼。 call stack (呼叫堆疊) JavaScript 引擎利用call stack(呼叫堆疊)來追蹤所有任務， 現在用個例子來看看執行背景空間(execution context)究竟是如何堆疊(被追蹤)的。 12345678910function a(){ b(); // 呼叫函式 b}function b(){ console.log('函式 b 被執行了')}a(); // 第一次呼叫函式 aa(); // 第二次呼叫函式 a 最先被創建的永遠是全域執行背景空間。 在全域下，定義了函式 a 與函式 b，接著呼叫了函式 a (第 9 行)，於是建立 a 函式執行背景空間，並堆放至 stack 中，由於 JavaScript 一次只能做一件事，所以此時全域執行背景空間會被暫停。 因在函式 a 中又呼叫了函式 b，於是建立 b 函式執行背景空間，並堆放至 stack 中，此時 a 函式執行背景空間會被暫停。 印出「函式 b 被執行了」後，b 函式執行完畢，於是 b 函式執行背景空間從 stack 中移出(pop)，回到了 a 函式執行背景空間繼續執行。 a 函式執行完畢(a 函式中也已經沒有其他程式碼需要被執行了)，a 函式執行背景空間從 stack 中移出，回到全域執行背景空間繼續執行。 在全域下，第 10 行中又再次呼叫函式 a，以上 2~5 的過程又重複一次。 可以發現，stack 中的執行背景空間會「後進先出」，也就是較晚被堆疊進來的執行背景空間，會先被執行完然後 pop 出去。 我們也可以在瀏覽器的除錯工具中觀察 call stack 的變化，來驗證一下過程是不是如上述一樣。 首先在 VScode 中開啟 live server，接著打開開發者工具(按 F12)，點選 Source，然後選擇要觀察的 js 檔案。 點擊左邊的行數來下中斷點，一個紅點代表一個中斷點(範例中將中斷點下在第 9 行)。 然後重新整理一下頁面。 會發現在 call stack 欄位中，出現一個 (anonymous)，它就是全域執行背景空間(global execution context)。要注意的是，此時第 9 行的程式碼尚未被執行。 接著按下一步，開始執行第 9 行程式碼，也就是呼叫函式 a。 會發現 call stack 中被疊加了 a 函式執行背景空間。 接著繼續按下一步，執行函式 a 中的程式碼，也就是呼叫函式 b。會發現 call stack 中又被疊加了 b 函式執行背景空間，此時 a 函式執行背景空間被暫停。 接著再按下一步，執行完函式 b 中的程式碼(console.log)，b 函式執行背景空間從 call stack 中彈出，恢復執行 a 函式執行背景空間。 接著繼續按下一步，因函式 a 中，在呼叫函式 b 之後，已經無其他程式碼需要被執行，所以函式 a 也執行完畢，a 函式執行背景空間彈出 call stack，恢復執行全域執行背景空間。 因全域執行背景空間中，第 10 行程式碼還沒被執行(再次呼叫函式 a)，所以繼續按下一步，會發現剛剛的過程又會重複一遍。 除了 call stack 之外， Web API、Task Queue、Event Loop 也扮演著重要的角色，推薦參考影片 What the heck is the event loop anyway?，該影片將 JS 引擎的運作流程解釋得非常淺顯易懂。 執行背景空間(execution context) 就簡單的介紹到此，在這篇文章中，瞭解到 JavaScript 引擎如何透過執行背景空間來追蹤程式碼的執行，下一篇將繼續介紹 JavaScript 如何透過字彙環境(lexical environment)來追蹤變數和函式的作用範圍。 參考資料 忍者：JavaScript開發技巧探秘第二版 MDN - closure JavaScript: Understanding the Weird Parts What the heck is the event loop anyway?","link":"/article/JavaScript%E9%96%89%E5%8C%85%E8%88%87%E7%AF%84%E5%9C%8Dexecution-context.html"},{"title":"CSS 原理 - position","text":"這篇要介紹的是 position，\b顧名思義，它與元素的位置或定位方式有關，了解它的各種屬性值肯定是必要的，像是常見的彈跳視窗或固定導覽列，也都需要它。 position 語法 position 的屬性值有 static、relative、absolute、fixed 與 sticky。 1position: static | relative | absolute | fixed | sticky static 1position: static; 為預設值。 元素為 in-flow。 top、right、bottom 與 left 屬性皆無效。 z-index 屬性無效。 relative 1position: relative; 元素仍為 in-flow，為元素預留原本的空間。 top、right、bottom 與 left 屬性可指定元素相對於自身原本的位置做偏移，不影響其他元素的位置。 此屬性值對 display 值為 table-row-group、table-header-group、table-footer-group、table-row、table-column-group、 table-column、table-cell 與 table-caption 的元素無效。 absolute 1position: absolute; 元素 out-of-flow，不為元素預留原本的空間。 相對於祖譜中最接近且 position 值非 static 的containing block(包含塊)做定位，若無，則追溯至 initial containing block (初始包含塊)，在連續媒體下即為 veiwport (視口)。 top、right、bottom 與 left 屬性可指定其對於containing block(包含塊)的偏移量，不影響其他元素的位置。 不會與其他元素發生 margin collapsing(外距重疊)，因為會建立一個新的 BFC。 建立 Block Formatting Context(BFC)。 fixed 1position: fixed; 元素 out-of-flow，不為元素預留原本的空間。 containing block(包含塊)為 veiwport，所以會以 veiwport 做定位，滾動時，元素相對於 viewport 仍處於同一位置。 上層元素中若有 transform 屬性非 none 的祖先時，containing block(包含塊)由 veiwport 改為該祖先，即針對該祖先定位。 top、right、bottom 與 left 屬性可指定其對於containing block的偏移量。 不會與其他元素發生 margin collapsing(外距重疊)。 建立 Block Formatting Context(BFC)。 sticky 為相對定位(relative)和固定定位(fixed)的混合體。元素在跨越特定門檻(specified threshold)之前屬於相對定位，之後屬於固定定位。 1position: sticky; 元素為 in-flow。 必須指定 top、right、bottom 或 left 其中一個做為特定門檻(specified threshold)，sticky 才有效，即使是 top: 0。 相對於最近的可滾動祖先和 containing block 做定位。 top、right、bottom 與 left 屬性可指定其偏移量，不影響其他元素的位置。 建立 Block Formatting Context(BFC)。 例如: 12345&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;1&lt;/div&gt; &lt;div class=\"box\"&gt;2&lt;/div&gt; &lt;div class=\"box\"&gt;3&lt;/div&gt;&lt;/div&gt; 123456789101112.container{ width: 280px; height: 1850px; /* 可滾動 */}.box{ position: sticky; top: 150px; /* 門檻值(必要條件) */ width: 70px; height: 70px; margin-bottom: 100px;} 參考資源 W3C-hoosing a positioning scheme: ‘position’ property MDN-position MDN-Block formatting context","link":"/article/Position.html"},{"title":"CSS 原理 - Line box","text":"Line box 就像筆記本上的線框，一行一行的垂直堆疊，裡面裝著文字或是 inline-level boxes，而我們可以利用 text-align 與 vertical-align 屬性操控 inline-level boxes 在 line box 裡的水平與垂直對齊。 什麼是 line box 圖片來源：visualhunt line box 是用來裝文字與所有 inline-level box 的，換句話說，只要有文字或是 inline-level box 的地方，就會出現 line box，就像「行」的概念，一個 line box 就是一行。這篇將說明 line box 的範圍是如何決定的。 若對於哪些元素會生成 inline-level box 不太清楚，可複習上一篇 display 文章。 line box 寬度 line box 是「行」的概念，也是一個矩形範圍，正常情況下，line box 的寬度取決於 Containing block(包含塊)，但若有 float 元素，則 line box 會受到壓縮(shrink)。 直接用實例來看會較具體一點，以下將比較正常情況下與在有 float 元素下，line box 的寬度會如何變化。 Case: 無 float 元素時 以 display: inline-block 為例，該元素屬於 inline-level box，故會產生 line box，而 line box 寬度取決於其 containing block(包含塊)。 12345&lt;div class=\"block-container\"&gt; &lt;div class=\"inline-level-box\"&gt; display: inline-block &lt;/div&gt;&lt;/div&gt; 12345678910111213.block-container { width: 600px; height: 250px; border: 10px solid #333;}.inline-level-box { display: inline-block; /* 為一種 inline-level-box */ height: 100px; color: white; font-size: 20px; background-color: orange;} 此時設定 text-align: center，則橘色的 inline-level box 會水平置中於 line box 裡，這結果應該毫不令人意外。 123.block-container { text-align: center;} Case: 有 float 元素時 當有 float 元素時，line box 會受到 float 元素的擠壓，若擠壓到 line box 無法容納裡面的文字或是 inline-level box 時，line box 就會自動「換行」。 12345678910111213141516171819202122.block-container { width: 600px; height: 250px; border: 10px solid #333; margin: 100px;}.float { float: left; /* float 會擠壓 line box */ width: 100px; height: 150px; color: white; background-color: #F75848;}.inline-level-box { display: inline-block; /* 為一種 inline-level-box */ color: white; font-size: 20px; height: 100px; background-color: orange;} 此時 line box 已經被 float 元素壓縮了。範例連結 設定 text-align: center，讓橘色的 inline-level box 水平置中於被壓縮後的 line box 裡。 123.block-container { text-align: center;} 接著，若 float 元素變更寬，擠壓 line box 更多，多到該行無法再容納橘黃色的 inline-level box 時，line box 就會「換行」。 123.float { width: 500px; /* 變超胖 */} line box 高度 如同上述，line box 是用來裝文字或 inline-levle box 的，所以一個 line box (同一行)高度由位置最高的 inline-level box 頂部與位置最低的 inline-level box 底部的距離。 其中 inline-level box 又可二分為 inline box 與 atomic inline-level box 兩種，像是替換元素 &lt;img&gt; 或 display: inline-block 皆屬於 atomic inline-level box，下一篇文章會說明兩種有何差別(應該會吧)。 Case: 若是 inline box Inline box 僅有 box model 中的 content area 會影響 line box 高度。 Line box 僅取決於 inline box 的 content area (像是 line-height 或 font-size 皆會影響 content area)，不包含 padding、border、margin。 例子 &lt;span&gt; 預設為 display: inline，且非替換元素(nonreplaced elememt)，為 inline-level element 中的 inline element，故其僅有 line-height 會影響 line box，padding、border、margin 皆不會影響 line box 高度。 1234&lt;div&gt;Lorem ipsum, dolor sit add &lt;span&gt;我在 inline box 裡面&lt;/span&gt; Lorem ipsum, dolor sit amet consectetur .&lt;/div&gt; 12345678910div { width: 220px; margin: 200px; border: 1px solid #000;}span { background-color: orange; padding: 10px;} 為方便觀察，給 &lt;span&gt; 背景橘色的顏色，並給 &lt;span&gt; 上下左右 padding 各 10px。 反白區域為一個 line box 高度。可以清楚看見，line box 並沒有被撐高，上下方的文字沒有被推開(但左右有)。 Case: 若是 atomic inline-level box Atomic inline-level box 的整個 box model 會影響 line box 高度。 Line box 取決於 atomic inline-level box 的整個 box model 高度，即包含 padding、border 與 margin 部分。 例子 現在將 &lt;span&gt; 設定為 display: inline-block，&lt;span&gt; 仍然屬於 inline-level element，但由 inline element 變成 atomic inline-level element。 12345span { display: inline-block; /* 變成 atomic inline-level */ background-color: orange; padding: 10px;} 反白區域為一個 line box 高度。可以清楚看見，line box 長高了，所以上下方文字的距離也隔開了！ 註： ① box model 高度為內容區高度 + 上下內距 +上下邊框 + 上下外距，可參考先前文章。 ② 其它替換元素 參考資源 W3C - Inline formatting contexts W3C - Line height calculations W3C - Floats 鉄人28号FX 鉄人2号「文本士」content area","link":"/article/LineBox.html"},{"title":"讓網頁平滑滾動!","text":"在網頁開發中，錨點算是個常見的需求，例如：在點擊按鈕後，畫面想要蝦趴的「滑」到頂部。 這種平滑的滾動效果，其實只要加一行 CSS 就可以辦得到，無需勞動到 JS，也就是今天要介紹的 scroll-behavior 屬性，直接進入實作吧! 實作範例 情境： 現在頁面上有很多區塊(達到可滾動的狀態)，而不管畫面在哪，只要點擊右下角橘色按鈕，就要滑動到最上方。 codepen 原始碼範例 HTML 如下: 1234567891011121314&lt;a id=\"top\"&gt;&lt;/a&gt;&lt;section&gt;1&lt;/section&gt;&lt;section&gt;2&lt;/section&gt;&lt;section&gt;3&lt;/section&gt;&lt;section&gt;4&lt;/section&gt;&lt;section&gt;5&lt;/section&gt;&lt;section&gt;6&lt;/section&gt;&lt;section&gt;7&lt;/section&gt;&lt;section&gt;8&lt;/section&gt;&lt;section&gt;9&lt;/section&gt;&lt;section&gt;10&lt;/section&gt;&lt;a class=\"btn-back\" href=\"#top\"&gt; ↑&lt;/a&gt; CSS 的部分，在 html 加上 scroll-behavior: smooth 即可。 123html { scroll-behavior: smooth;} 實際效果如下： 最後，順帶看一下瀏覽器兼容性: 圖片來源: MDN 結束XD 參考資源 MDN-scroll-behavior","link":"/article/Smooth-Scrolling.html"},{"title":"CSS 原理 - Box model","text":"想像每個元素都是個盒子，而 &lt;html&gt; 就像是個超級大盒子，裡面裝了許許多多大小不一的盒子，像是 &lt;div&gt;、&lt;p&gt;、&lt;span&gt;、&lt;button&gt;…等等，而每個盒子由四個部分組成。 如下圖所示，box model 由四個部分組成，由內至外依序為 content area (內容區) padding (內距) border (邊框) margin (外距) content area 內容區域，也就是盒子裡裝的東西，可能是文字、圖片或是又裝了其它元素(其他盒子)，例如 &lt;div&gt;、&lt;p&gt;、&lt;span&gt;、&lt;button&gt;…等等。 padding (內距) 可想像成盒子和其內容物的距離，介於 content area(內容區) 與 border(邊框)之間的部分。其特色為 厚度取決於 padding 屬性， 不能為負值。 預設下，padding 不包含在屬性 width 的範圍，因 box-sizing 預設值為 content-box，當然只包含最裡面的 content 部分。 border (邊框) 介於 margin (外距)與 padding(內距) 之間的範圍。 可以使用 border 屬性來設置邊框的寬度、樣式與顏色。 三合一縮寫語法 (三個值的順序可以互換)： 1border: border-width｜border-style｜border-color 亦可單獨指 定border 的寬度、樣式與顏色。個別屬性如下： border-width (邊框寬度) border-style (邊框樣式) border-color (邊框顏色) 預設情況下，不包含在 width 與 height 的範圍內。 margin (外距) margin 圍繞於 border 之外，用於推開元素與其它元素之間的距離。其特色為 厚度取決於 margin 屬性。 可以是正值或負值，但若為負值，可能會與其它元素重疊。 元素本身的背景設定無法渲染至 margin 部分，例如 background-color 或 background-image。 不包含在 width 與 height 範圍內。 box-sizing 一個新手常遇見的問題：奇怪，明明指定了元素的 width 與 height，但元素渲染於畫面上的寬度與高度卻比自己設定的值來得大？ 這問題通常與 box-sizing 有關。 box-sizing 屬性決定如何計算一個元素渲染於畫面上的總寬度與總高度，也就是 size，有 content-box 與 border-box 兩種屬性值。 (一) content-box 1box-sizing: content-box； content-box 為預設值，如同字面上的意思，若該元素可以指定 width 與 height，則在設定 width 或 height 時，其指定的僅為最內層的 content 部分，例如 width: 100px，則代表元素的 content area 寬度為 100px。 如果同時還設定了 padding 或是 border，則必須再加上 padding 與 border，才是最終渲染於畫面上的寬度或高度。 例如： 給定一個 div 的設定如下： codepen 範例連結 12345678div { box-sizing: content-box; /*預設值*/ width: 200px; height: 100px; padding: 20px; margin: 30px; border: 10px solid black;} 則在 content-box 下： 最終渲染寬度 ≠ width 200px 而是 ( width 200 + 左右 padding 20*2 + 左右 border 10*2 )px = 260px ; 最終渲染高度 ≠ height 100px 而是( height 100 + 上下 padding 20*2 + 上下 border 10*2 )px = 160px。 (二) border-box 1box-sizing: border-box; 如同字面上的意思，若該元素可以指定 width 與 height，則 width 和 height 屬性值涵蓋的範圍為 border 以內，也就是 content、padding 和 border，注意，不包括 margin。 border-box 可以使元素渲染於畫面上的總寬度與總高度的計算變得較直覺簡單，不必再額外加上 padding 和 border，連 bootstrap 也對所有元素做了此設定。 例如： 給定一個 div 的設定如下： 在 border-box 下： 最終渲染寬度即為 width 200px ; 最終渲染高度即為 height 100px。 12345678div { box-sizing: border-box; width: 200px; height: 100px; padding: 20px; margin: 30px; border: 10px solid black;} 參考資料 W3C - CSS Box Model Module Level 3 MDN - The box model MDN - box-sizing","link":"/article/box-model.html"},{"title":"Vue3 Composition API - Teleport 瞬移!","text":"Vue3 Composition API 新增了 Teleport 功能，讓我們可以輕鬆的將組件傳送到指定的地方，很酷的是，它還能夠保存狀態! 為什麼需要 Teleport？ 最常見的情境是彈跳視窗，在開發時，我們會希望把彈跳視窗的開關邏輯封裝在 component 裡面，而不是裸露在頁面上。以程式碼來說，就是將控制開關的變數 isModalOpen: false(true) 設置在 component 裡。 一個極端的例子是：有 6 張 HTML 和 CSS 樣式皆相同的 Cards，但裡面的資料不同，點擊這 6 張 Cards，會分別跳出各自的彈跳視窗，而 6 個彈跳視窗的 HTML 和 CSS 樣式皆相同，但裡面的資料不同。 在這樣的情境下，應該沒有人想要在頁面上設定 6 個變數，分別控制這 6 個彈跳視窗吧! 較好的作法是將彈跳視窗開關的邏輯封裝在 Card component 中，然後在頁面上用 v-for 產生 6 張 Card，這時每張 Card 裡控制彈跳視窗開關的變數 isModalOpen 都是獨立的，不會互相干擾。 但是這樣的方式其實會有隱患，因為一般來說會將彈跳視窗用 position: fixed 固定在視窗(viewport)，在大多數情況下，彈跳視窗會如我們所願的針對視窗做定位，但仔細看 MDN 上對於 position: fixed 的定義： 圖片來源: MDN-position 簡單來說，若彈跳視窗(position: fixed)的祖譜鏈中有一個祖先元素設定了 transform、perspective 或 filter 屬性時，那麼彈跳視窗將不再以視窗(viewport) 做定位，而是以該祖先元素做定位，那麼彈跳視窗就會壞掉！ 有了 Teleport，就可以開閃現，讓彈跳視窗在 DOM tree 中瞬移到 body 節點(整個 &lt;app&gt; 外)的尾部，如此一來我們就可以安心的把開關的邏輯封裝在 Card 中，因為不管是 Card 或是 Card 外層元素使用了 transform、perspective 或 filter，都不再關彈跳視窗的事了，因為這時彈跳視窗的祖先元素就是 &lt;body&gt; → &lt;html&gt; → viewport。這樣還有另一個好處是，不用再微調 z-index 了，因為彈跳視窗被傳送到 &lt;app&gt; 後方(&lt;body&gt; 尾部)。 Teleport 語法 在 Vue 的 &lt;template&gt; 中可以直接使用 &lt;Teleport&gt;，無需特別引入。 &lt;Teleport&gt; 有兩個屬性： to: 用 query selector 指定要傳送到哪裡，也可以使用動態指定 :to。 1234&lt;teleport to=\"#some-id\" /&gt; &lt;teleport to=\".some-class\" /&gt;&lt;teleport to=\"body\" /&gt;&lt;teleport to=\"[data-teleport]\" /&gt; disabled: 決定是不是要傳送出去。 false: 傳出去(預設)。 true: 不要傳出去，將 &lt;Teleport&gt; 裡的東西留在原本的地方 範例 使用 Teleport 前 現在有 Card 與 Modal 組件，點擊 Card 裡面的按鈕，會打開彈跳視窗(Modal)，Modal 以 position: fixed 固定在視窗(viewport)。 在 Card 中引入 Modal 組件，並且把控制 Modal 開關的邏輯封裝在 Card 中。這時的畫面是可以正常運行的。 程式碼範例 在 Card.vue 中: 12345678&lt;template&gt; &lt;div class=\"card\"&gt; &lt;h4&gt;這是 Card component&lt;/h4&gt; &lt;button @click=\"isModalOpen = true\"&gt;確認送出訂單&lt;/button&gt; &lt;Modal v-if=\"isModalOpen\" /&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718&lt;script&gt;import { ref } from 'vue';import Modal from './Modal.vue';export default { name: 'Card', components: { Modal }, setup() { const isModalOpen = ref(false); // 控制 Modal 開關 return { isModalOpen } }}&lt;/script&gt; 123456789&lt;style scoped&gt; .card { width: 200px; height: 300px; margin: 0 auto; border: 1px solid #000; text-align: center; }&lt;/style&gt; 在 Modal.vue 中: 1234567&lt;template&gt; &lt;div class=\"modal-background\"&gt; &lt;div class=\"modal\"&gt; OH! Modal 被打開了 &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 12345&lt;script&gt;export default { name: 'Modal'}&lt;/script&gt; 12345678910111213141516171819202122&lt;style scoped&gt; .modal-background { display: flex; justify-content: center; align-items: center; position: fixed; background: rgba(0, 0, 0, 0.3); width: 100%; height: 100vh; top: 0; left: 0; } .modal { width: 200px; height: 100px; padding: 20px 0; border-radius: 5px; background: #eee; text-align: center; }&lt;/style&gt; 效果如下 打開開發者工具檢視一下 DOM 結構，可以看到在尚未使用 &lt;Teleport&gt; 之前，Modal 是長在 Card 裡面。 如剛剛所說，這樣的問題是，只要上層元素中有一個設定了 transform、perspective 或 filter，那麼 Modal 將不再針對視窗做定位，且有時可能會需要微調 z-index。 證明方式很簡單，可以在 Card 的 style 中加入 transform: translateY(20%) 來做測試。程式碼範例 1234567891011&lt;style scoped&gt; .card { width: 200px; height: 300px; margin: 0 auto; border: 1px solid #000; text-align: center; /* 在 Modal 的祖先元素 Card 中加上 transform */ transform: translateY(20%); }&lt;/style&gt; 會發現 Modal 壞掉了，因為這時 Modal 將以 Card 做定位，而非視窗。 使用 Teleport 後 現在使用 &lt;Teleport&gt;，將 Modal 瞬移到 body 節點的尾部。程式碼範例 1234567891011&lt;template&gt; &lt;div class=\"card\"&gt; &lt;h4&gt;這是 Card component&lt;/h4&gt; &lt;button @click=\"isModalOpen = true\"&gt;點我打開 Modal&lt;/button&gt; &lt;-- 使用 Teleport 將 Modal 傳送到 body 尾部 --&gt; &lt;Teleport to=\"body\" v-if=\"isModalOpen\"&gt; &lt;Modal /&gt; &lt;/Teleport&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718&lt;script&gt;import { ref } from 'vue';import Modal from './Modal.vue';export default { name: 'Card', components: { Modal }, setup() { const isModalOpen = ref(false); return { isModalOpen } }}&lt;/script&gt; 1234567891011&lt;style scoped&gt; .card { width: 200px; height: 300px; margin: 0 auto; border: 1px solid #000; text-align: center; /* card 不再是 Modal 的祖先元素，所以再也無法影響 Modal */ transform: translateY(20%); }&lt;/style&gt; 再次打開開發者工具檢視，可以看到 Modal 出現在 body 內的尾部(在 之後)，如此以來，即使在 Card 的 style 中設定了 transform、perspective 或 filter，Modal 皆不會受到影響，也不會有煩人的 z-index 問題。 Teleport 特性 - 保留狀態 Teleport 還有一個特別之處是：裡面的狀態會被保存，就像是 &lt;keep-alive&gt; 那樣，不會被 destroyed(或 unmounted)。 範例 利用 &lt;Teleport&gt; 的 disabled 屬性來證明： 首先讓 isNumTeleport 預設值為 true(表示 Teleport 內的東西不會被傳送出去)，當點擊按鈕時，就會 toggle isNumTeleport 變數，使 &lt;Teleport&gt; 內東西可以在 &lt;Card&gt; 與 &lt;body&gt; 之間來回穿梭。 而 &lt;Teleport&gt; 內為 num，每 1 秒會增加 1。 範例程式碼 1234567891011&lt;template&gt; &lt;div class=\"card\"&gt; &lt;h4&gt;這是 Card component&lt;/h4&gt; &lt;button @click=\"toggleNumTeleport\"&gt;傳送&lt;/button&gt; /* Teleport 狀態會像 keep-alive 那樣保留。 */ &lt;Teleport to=\"body\" :disabled=\"isNumTeleport\"&gt; &lt;p&gt;num: {{ num }}&lt;/p&gt; &lt;/Teleport&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627&lt;script&gt;import { ref, onMounted } from 'vue';export default { name: 'Card', setup(){ const num = ref(0); const isNumTeleport = ref(true); onMounted(() =&gt; { setInterval(() =&gt; { num.value++; }, 1000); }); const toggleNumTeleport = () =&gt; { isNumTeleport.value = !isNumTeleport.value; } return { num, isNumTeleport, toggleNumTeleport } }}&lt;/script&gt; 123456&lt;style scoped&gt; .card { height: 370px; border: 1px solid #000; }&lt;/style&gt; 實現效果如下，可以清楚看到，無論怎麼切換，&lt;Teleport&gt; 裡面的狀態都會被保留(num 不會重頭計算)。 Facebook 和 Youtube 的縮小影片功能，感覺就很適合用 Teleport 實現呢XD 結論 使用 &lt;Teleport&gt; 將彈跳視窗傳送到 &lt;body&gt; 尾部(&lt;app&gt; 後方)的好處是可以避開 CSS 中 fixed 定位的雷，也不用再調 z-index 了，讓開發者可以安心地的把邏輯封裝在 component 裡面。 &lt;Teleport&gt; 除了瞬移之外，還有保留狀態的特性，所以總覺得 &lt;Teleport&gt; 還可以拿來應用在其它有趣的地方，但是暫時想不到其它案例哈，如果讀者有遇到其它適合使用 &lt;Teleport&gt; 的情境，歡迎留言告訴我XD 參考資料 Vue3 文件 - Teleport MDN - position","link":"/article/composition-api-teleport.html"},{"title":"CSS 原理 - 你所不知道的 display","text":"Visual formatting model (視覺格式化模型) 對於排版來說是很重要的觀念，但不是那麼平易近人且有點抽象，在初次看 W3C 規範 時一定是霧煞煞，強烈建議先釐清幾個重要名詞的定義，會發現繞來繞去，講的其實都是相同的概念。 display 為什麼 display: block 的元素們會呈現垂直排列？為什麼 display: inline 的元素們會呈現水平排列？又為什麼 display: inline-block 的元素是呈現水平排列呢？其實答案都與元素生成(generate)何種類型的 box 有關。 在先前 box model 文章中曾介紹，元素就像一個個的盒子 (box)，這篇將介紹在 in flow 下，這些「 盒子如何排列」，或說是「元素如何佈局」。 元素在 in flow 下如何佈局的主要關鍵為該元素「生成 (generate)了什麼類型的 box」，而這會取決於元素的 display 屬性。其實我們所熟悉的 display 同時定義了元素的兩種 display type： outer display type：決定元素「本身」在 in flow 下如何佈局，即元素本身參與的是何種 formatting context (格式化上下文)。 inner display type：決定元素為它的後裔元素建立何種 formatting context，與其後裔元素的佈局有關。 outer display type 在 outer display type 方面，box 類型可分成 inline-level box 與 block-level box 兩大類，所有 inline-level box 皆會參與 IFC，呈現水平排列，而所有 block-level box 皆會參與 BFC，呈現垂直排列。 inline-level box (行內級盒子) inline box (行內盒子) atomic inline-level box (原子行內級盒) block-level box (塊級盒子) inner display type 在 inner display type 方面，因其描述的是元素本身與其內容或後裔元素的關係，可以想像成元素像個容器 (container)，裝著文字內容或後裔元素。常見的 container box 類型有 block container box、flex container box 與 grid container box 等等。 而什麼類型的 container box，就會為其內容或後裔元素建立什麼類型的 formatting context，例如： flex container 建立 flex formatting context (FFC) grid container 建立 grid formatting context (GFC) block container 可建立 block formatting context (BFC) 或 inline formatting context (IFC) 順帶一提，替換元素\b (replaced element)，例如 &lt;img&gt;，display 的預設值為 inline，不論將其 display 屬性值改成什麼，皆不會有 container box，因為它就是路徑來源的圖片，不是用來裝像是 &lt;span&gt;、&lt;div&gt; 或其他元素的容器。 圖片來源: W3C 了解 display 的好處 講了這麼多，了解 display 到底有什麼好處？ 個人認為至少有三大優點。 秒殺元素排列方式 即使遇到一個從來沒用過的 display 屬性值，也能夠馬上知道在 in flow 下，元素會如何排列，例如，你有聽過或用過 display: flow-root 或 inline-flex 嗎？ 在沒有用過，甚至從沒聽過的情況下，一看 display 表就可以得知 display: flow-root 的元素會生成 block-level box，故元素本身參與 BFC，在 in flow 下會呈現垂直排列。而 display: inline-flex 會生成 inline-level box，故元素本身參與 IFC，在 in flow 下會呈現水平排列。 秒殺屬性的適用對象 例如常用的 vertical-align 與 text-align 對齊，你知道他們能操控的對象總共有哪些嗎？ 其實他們是在操控 inline-level 的垂直與水平對齊。 vertical-align 屬性可以適用於所有 inline-level boxes，也就是可以操控 display 表上所有會生成 inline-level box 元素的垂直對齊。 圖片來源：W3C 而 text-align 的屬性則是須設定在 inline-level 外層的 block container，它可操控 display 表上所有會生成 inline-level box 元素的水平對齊。 圖片來源：W3C 再例如，margin: 0 auto，常用在 display: block 元素的水平置中，但除此之外，還可以用在哪些元素上呢？ 其實 display 表上會生成 block-level box 的皆適用。 何種 display 會產生 BFC 就如同剛剛提及的，什麼類型的 container box 就會建立什麼類型的 formatting context，所以 block container box 可以建立 BFC，這時就可以由 dispaly 表中得知 display: inline-block 與 flow-root 皆會建立 BFC (display: block 例外)。 另外，其實 display: table 與 inline-table 亦會建立 BFC，因生成的 table wrapper box 也是一種 block container。 block formatting context (BFC) 在排版中是非常重要的一環，這部分的介紹留在之後文章再詳細說明。 參考資源 W3C-Controlling box generation W3C-Appendix A: Glossary W3C-Box Layout Modes: the display property","link":"/article/display.html"},{"title":"一起成為 MDN 的貢獻者吧!","text":"身為一個 web developer，查找 MDN 應該是家常便飯，如果想對 MDN 文件內容進行勘誤或是幫忙更新文件，可以參考一下這篇文章XD 故事是這樣的…某天在查找 MDN docs 時，突然注意到最底下這個區塊(以前都視而不見)…那天滑鼠不知為何就這樣點了進去，然後突然覺得發現新大陸🐒，加上原本正打算好好的看一下某個主題的 MDN API docs，於是就興起了一邊看 MDN docs 一邊幫忙翻譯的衝動。後來發 PR(Pull Request) 也意外的順利通過，決定來整理一下重點和注意事項給有興趣跳坑的人做參考。 整個過程大致可分為四個步驟: 一、fork &amp; clone MDN 的 repo 二、詳細閱讀格式規範和注意事項 三、進行一些設置，在 local 即時預覽正在編輯的 MDN 頁面 四、編輯 &amp; 發送 PR 接下來會針對以上四個步驟進一步說明 一、Fork &amp; Clone repo MDN 的文件內容分為以下二個 repo，如果要編輯英文版文件，fork content repo 即可; 如果想要編輯「非」英文版的 MDN 文件， 則以下二個 repo 都要 fork : content：這個 repo 只存放英文版的文件內容 translated-content：這個 repo 存放所有「非」英文版的文件內容 fork 完成後，再從自己的 Github 把 fork 來的 repo clone 下來。 二、閱讀格式規範和注意事項 在開始編輯之前，務必先看過 repo 說明，確認自己的編輯有符合規範後再發送 PR，減少審核人員的負擔。 以下整理幾個大重點: 英文版最大！所有的翻譯都是向英文版看齊，所以請直接拿英文版(content 資料夾)的 .html 或 .md 檔案內容的進行翻譯，因為其他語言(translated-content 資料夾)的內容不一定是最新的。 在 content 和 translated-content 下的 /files 資料夾中，可能會看到夾雜著 .html 或 .md 的檔案，MDN 團隊計畫慢慢將 .html(舊) 更新成 .md(新)，所以如果要翻譯的話建議可直接使用 .md 檔。 可以看到在 content 和 translated-content 下的 /files 資料夾中，還有巢狀的資料夾，在 translated-content 編輯時，如果需要新增 .html 或是 .md 檔案(可能之前沒人翻譯過，你是 NO.1)，須確認巢狀結構、資料夾名稱以及檔案名稱和 content 資料夾的一致。 參考格式規範：MDN guidelines、Writing style guide、guide to writing Markdown for MDN 需注意有些語言可能會有額外的格式規範，例如以「繁體中文」來說，可以在 translated-content 資料夾的 /docs/zh-tw/translation-guide.md 看到針對繁體中文格式的額外規範說明，像是標點符號、空白修飾、術語等等。 務必自己另開一個新的 branch 來進行編輯，不要在 main branch 進行任何修改。 注意 git commit 的拆分以及 commit message。 📌 更多細節請詳見 content 和 translated-content 三、設置 &amp; 預覽編輯畫面 📍 content 資料夾 👉 在 local 端跑起來可預覽編輯的 MDN 頁面(也可以預覽 translated-content 資料夾的東西，很酷!🧞‍♂️) 📍 translated-content 資料夾 👉 在這個資料夾可編輯「非」英文版本的 MDN 文件內容 clone 之後，先在編輯器打開 content，接著進行下設定: 讓 git 也連到 mdn/content 的 repo，之後就可以在 local 端 pull mdn/content 的最新內容，執行: 1git remote add mdn git@github.com:mdn/content.git 確認有添加成功，執行: 1git remote -v 建立自己的 branch: 1git branch your-branch-name 切換到自己的 branch: 1git checkout your-branch-name 在 content 目錄下添加 .env 檔案，.env 檔案裡放上 EDITOR 和 CONTENT_TRANSLATED_ROOT ，CONTENT_TRANSLATED_ROOT 後面放路徑，指向 translated-content 下的 files 資料夾: ❗️ 如果只想編輯英文版的文件，沒有要在本地端預覽其他語言的文件，則不需要 CONTENT_TRANSLATED_ROOT 12EDITOR = code;CONTENT_TRANSLATED_ROOT=/Users/yachen/Desktop/translated-content/files 👉 不要複製貼上，這個是我的路徑，記得改成你自己的 執行 yarn start，之後可以在 local 端(local:5042)預覽編輯頁面，稍後在步驟四會進一步說明 1yarn start (如果只要編輯英文版文件，以下 7.8.9 的設定可省略) 7. 在編輯器打開 translated-content，讓 git 也連到 mdn/translated-content 的 repo，之後就可以在 local 端 pull mdn/translated-content 的最新內容，執行: 1git remote add mdn git@github.com:mdn/translated-content.git 建立自己的 branch: 1git branch your-branch-name 切換到自己的 branch: 1git checkout your-branch-name 四、編輯 &amp; 發送 PR 首先在編輯器打開 content 和 translated-content ，並且完成步驟二的設定，確定 yarn start 已經成功執行。 在編輯時，一定會想要即時預覽編輯的畫面，以下分享我的小撇步~ 直接舉例子來做說明，假設「我想翻譯 getUserMedia 的繁體中文文件」： 可直接打開 google 搜尋「getUserMedia mdn」，就可找到這份線上的文件，接著複製 domain url 後方的路由 /en-US/docs/Web/API/MediaDevices/getUserMedia。注意這個巢狀路由，和巢狀的資料夾結構是一樣的，可以利用它快速找到某個文件檔案。 然後貼到 local:5042 後方，也就是 http://localhost:5042/en-US/docs/Web/API/MediaDevices/getUserMedia，就可以在 local 端即時預覽英文版的 getUserMedia API 文件的編輯畫面。 可以從下拉選單切換不同語言，同時可快速看出這份文件目前有哪些語言翻譯 (可以看出這份文件目前還沒有人翻成繁體中文) 從 3. 下拉選單切換語言的動作可看出只要將 /en-US/docs/Web/API/MediaDevices/getUserMedia 的 en-US 改成其他語言，例如: ja(日文) 或 ko(韓文)，就可以切換到其他語言的 getUserMedia 文件(如果該語言有人翻譯這份文件的話) 從 3. 也可以看出，目前 getUserMedia API 沒有繁體中文的文件，所以如果「我想幫忙翻譯成繁體中文(zh-tw)」的話，就需要在 translated-content 資料夾下的 /files/zh-tw/web/api/mediaDevices/getUserMedia 建立一個 index.md 檔案。如果是第一個翻譯的人，就會需要自己建立相關的資料夾和 .md 檔案，注意！在 translated-content 所新增的資料夾/檔案結構和名稱都要和英文版(content 資料夾)的一樣! 完成了 5. 之後，到英文版的 content 資料夾的 /files/en-US/web/api/mediaDevices/getUserMedia 的 .md 檔案，直接複製並貼到 translated-content 裡相同位置的 .md 檔案，就可以在 local 端看到語言切換的下拉選單，多出了「繁體中文」的選項！點擊切換到繁體中文！ 開始進行編輯，可以即時預覽畫面 編輯完成後，push 到自己的 github，並發送 PR，等待該語系的審核人員審查。 結語 第一次在大型的開源專案發 PR，也意外的順利，覺得開心哈哈 在過程中也發現，MDN docs 的繁體中文資源相對少很多，雖然說看英文版才能獲得第一手最新的資訊，但還是希望繁體中文的勢力可以日益壯大XD 以這次的經驗來說，總結了以下五大收穫(優點)： 看了自己想看的某部分 MDN API docs，獲得相關知識 在翻譯的過程中，加深自己對於 docs 內容的印象 (怕被退件 &amp; 翻錯誤人子弟所以看得更仔細) 可以順便練英文 體驗大型開源專案的 PR 流程 讓閱讀 MDN docs 的人們可以多一個語言切換的選擇 是不是助人助己~ 好處多多~😆 (缺點:需要時間XD) 最後還有一個 bonus! 就是 Github 個人頁面上會出現一個閃亮亮的酷東西😍，趕緊入坑吧各位！ 參考資源: Content of MDN Web Docs Translated content of MDN Web Docs","link":"/article/pr-mdn.html"},{"title":"React Native - 打包 AAB(APK)","text":"這系列文章將一步步介紹如何在 mac 上搭建 Android 和 ios 的開發環境(React Native ClI)、如何在模擬器和實體裝置中運行、如何打包 AAB(APK) 和 IPA。 而這篇將介紹如何將你的 RN 專案打包成 AAB(APK)！，如果你還沒建置好 Android 的開發環境，請先跟著: React Native 開發環境建置 - Android 篇(上) React Native 開發環境建置 - Android 篇(下) 的步驟設定 Android 開發環境和建立 RN 專案。 生成簽名密鑰 首先，用 VSCode 打開你的 RN 專案，在專案的根目錄下，執行以下指令: 1sudo keytool -genkey -v -keystore my-upload-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000 上方指令中的 my-upload-key.keystore 可以任意改成 xxxx.keystore 上方指令中的 my-key-alias 可以任意改成 xxxx，但請務必記得你設定的 alias! 接著需要填寫一些設定: 輸入金鑰儲存庫密碼: yachen168 (自行設定，必須記住!) 再次輸入新密碼: yachen168 您的名字與姓氏為何: yachen (自行設定) 您的組織單位名稱為何: front-end (自行設定) 您的組織名稱為何: yachen (自行設定) 您所在的城市或地區名稱為何: tainan (自行設定) 您所在的州及省份名稱為何: tainan (自行設定) 此單位的兩個字母國別代碼為何: TW (自行設定) CN=yachen, OU=front-end, O=yachen, L=tainan, ST=tainan, C=TW 正確嗎？: 是 輸入 的金鑰密碼 (如果要和金鑰儲存庫密碼相同 👉 直接按 Enter) : 按 enter 或另外設定密碼(必須記住!) 完成上述動作後，會看到專案下多了一個 xxxx.keystore 的檔案: 設置 Gradle variables 將剛剛生成的 xxxx.keystore 檔案移到專案中的 android/app 資料夾下: 在 ~/.gradle/gradle.properties(全域，將套用到所有專案) 或你的 RN 專案中的 android/gradle.properties 加上 (下方 4 個等號後面改成你剛剛填寫的設定): 1234MYAPP_UPLOAD_STORE_FILE=my-upload-key.keystoreMYAPP_UPLOAD_KEY_ALIAS=my-key-aliasMYAPP_UPLOAD_STORE_PASSWORD=你設定的密碼MYAPP_UPLOAD_KEY_PASSWORD=你設定的密碼 將簽名配置加到專案中的 Gradle config 在專案下的 android/app/build.gradle 中添加以下配置(參考下圖): 1234567891011121314151617181920android { ... defaultConfig { ... } signingConfigs { release { if (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) { storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD } } } buildTypes { release { ... signingConfig signingConfigs.release } }} 生成 ABB cd 進到 RN 專案的 android 資料夾中，然後執行 ./gradlew bundleRelease 打包 ABB: 12cd android./gradlew bundleRelease 生成的 ABB 檔案會在 android/app/build/outputs/bundle/release 中，之後可以上架到 Google Play 商店。 生成 APK 如果你還不想上架到 Google Play 商店，只是想直接傳給親朋好友做測試，那可以選擇打包 APK: 12cd android./gradlew assembleRelease 生成的 APK 檔案會在 android/app/build/outputs/apk/release 中，將 app-release.apk 的檔案傳給朋友，朋友直接在手機上下載安裝後就可以使用你的 app 了！ 打開 APP: 結語 這篇文章主要目的為「如何打包 ABB(APK)」，因筆者目前自學 RN 還不到 1 個禮拜，所以有關於 APK 效能的一些進階設定，選擇先略過 &gt;&lt;，有興趣的讀者可以先參考 RN 文件 上較詳細的說明。如果文章中有描述不正確的地方，也歡迎留言指正 😆。 最後，如果在打包過程中有發生任何 error，請先耐心的回頭檢查 Android 開發環境、keystore 是否有正確設置，任何一個小環節沒設置好都可能發生問題! Android 篇就暫時告一段落了，接下來將進入 ios 囉! 參考資源 RN Docs - signed-apk-android Android developer - app-signing React Native 開發環境建置 - Android 篇(上) React Native 開發環境建置 - Android 篇(下)","link":"/article/rn-apk.html"},{"title":"React Native 開發環境建置 - Android 篇(上)","text":"這系列文章將一步步介紹如何在 mac 上搭建 Android 和 ios 的開發環境(React Native ClI)、如何在模擬器和實體裝置中運行、如何打包 AAB(APK) 和 IPA。因為筆者覺得 ios 比較複(機)雜(車)，所以會先從 Android 開始介紹。 會選擇 React Native ClI 而不是較友善的 Expo ClL 是因為筆者之後想要在 RN 上用 WebRTC，考慮到支援度的問題，所以選擇 React Native ClI。 安裝 dependencies 在建置 Android 開發環境之前，需要先安裝的 dependencies 有： Node Watchman JDK (Java Development Kit) Android Studio Node &amp; Watchman &amp; JDK 使用 Homebrew 安裝 Node、Watchman、JDK： 123brew install nodebrew install watchmanbrew install --cask adoptopenjdk/openjdk/adoptopenjdk8 如果你以前就安裝過 Node，請確保 Node 版本為 12 以上。 如果你以前就安裝過 JDK，請確保 JDK 版本為 8 以上。 建置 Android 開發環境 安裝 Android Studio 安裝完 Node、Watchman 和 JDK 後，就可以開始建置 Android 的開發環境了！ 下載並安裝 Android Studio，需注意的是，在安裝 Android Studio 時，記得要將以下三個勾選起來： Android SDK Android SDK Platform Android Virtual Device 安裝 Android SDK Android Studio 預設會安裝最新版的 SDK，而 React Native 需要的是 Android 10 (Q) 版本的 SDK，可以在 Android Studio 中的 SDK Manager 選擇 SDK 版本。 可以在 Android Studio menu 中的 Preferences → Appearance &amp; Behavior → System Settings → Android SDK 找到: 勾選 Android 10 (Q): 接著繼續在 SDK Platform 的 tab 下，勾選右下角的 Show Package Details，確認在 Android 10 (Q) 下有勾選： Android SDK Platform 29 Intel x86 Atom_64 System Image 或 Google APIs Intel x86 Atom System Image 在 SDK Tools 的 tab 中，勾選右下方的 Show Package Details，確認 Android SDK Build-Tools 下的 29.0.2 有被勾選起來: 將 Android SDK Command-line Tools (latest) 勾選起來: 最後按下 Apply 開始下載並安裝以上的設定!!! 配置 ANDROID_HOME 的環境變量 打開終端機，在 $HOME/.bash_profile 或 $HOME/.bashrc (如果你是使用 zsh 則為 ~/.zprofile 或 ~/.zshrc) 添加： 12345export ANDROID_HOME=$HOME/Library/Android/sdkexport PATH=$PATH:$ANDROID_HOME/emulatorexport PATH=$PATH:$ANDROID_HOME/toolsexport PATH=$PATH:$ANDROID_HOME/tools/binexport PATH=$PATH:$ANDROID_HOME/platform-tools 之後執行 source $HOME/.bash_profile 或 source $HOME/.zprofile (zsh 則為 source ~/.zprofile 或 source ~/.zshrc) 來生效上方的環境變量設定 在終端機執行 echo $ANDROID_HOME，檢查環境變量是否已經正確配置: 1echo $ANDROID_HOME 再次確認在 Android Studio menu 中的 Preferences → Appearance &amp; Behavior → System Settings → Android SDK 的路徑: 終於!!! 經過這些繁瑣的設定之後，就可以建立 RN 專案並在 Android Studio 上運行了!!!(下集待續) 🎉🎉🎉 結語 雖然 RN 建置開發環境的過程很枯燥乏味，但每個步驟都不能少，否則之後很容易出現各種奇怪的問題 🐛。 下一篇 React Native 開發環境建置 - Android 篇(下) 將繼續介紹如何在模擬器(Android Studio)和實體裝置中運行你的 RN 專案！ 參考資源 RN Docs - Setting up the development environment","link":"/article/rn-environment-android.html"},{"title":"解決 Vue.js-devtools 無法開啟問題","text":"相信用過 Vue.js 的應該都有裝 Vue.js-devtools (吧)。 最近發現若是單純以引入 CDN 的方式使用 Vue，而非用 Vue CLI，會出現 Vue.js-devtools 無法正常開啟的情況。 查了一下文件，原因是： 總之，解決辦法是需要手動進行設定，需要在 js 檔案中添加以下程式碼： 1Vue.config.devtools = true; 像這樣： 1234567Vue.config.devtools = true; // 手動添加這行程式碼Vue.component('todo-item', { template: '&lt;li&gt;...&lt;/li&gt;'})var app = new Vue(...) 然後重新開啟 live server，就可以看到 Vue.js-devtools 正常運作囉！ 參考資料 Vue 官方文件","link":"/article/vue-devtools%E7%84%A1%E6%B3%95%E9%96%8B%E5%95%9F.html"},{"title":"React Native 開發環境建置 - Android 篇(下)","text":"這系列文章將一步步介紹如何在 mac 上搭建 Android 和 ios 的開發環境(React Native ClI)、如何在模擬器和實體裝置中運行、如何打包 AAB(APK) 和 IPA。 會選擇 React Native ClI 而不是較友善的 Expo ClL 是因為筆者之後想要在 RN 上用 WebRTC，考慮到支援度的問題，所以選擇 React Native ClI。 而這篇將介紹如何在模擬器(Android Studio)和實體裝置中運行你的 RN 專案！在閱讀這篇文章之前，請先確實按照上一篇 React Native 開發環境建置 - Android 篇(上) 的步驟進行相關的 Android 開發環境設定。 Hello World! 現在可以開始建立 RN 專案了！ ❗️❗️注意: 如果你之前有在全域安裝過 react-native-cli，記得要先 npm uninstall -g react-native-cli，否則可能會出現一些無法預期的問題。 建立一個名叫 AwesomeProject 的 RN 專案: 1npx react-native init AwesomeProject 或是建立 Typescript 的 template: 1npx react-native init AwesomeTSProject --template react-native-template-typescript 建立 RN 專案後，可以透過兩種方式查看 android 的運行結果: 模擬器 - Android Studio 實體裝置 (需要 USB 連接電腦和手機) 在模擬器(Android Studio)上運行 使用 Android Studio 打開剛剛建立好的 AwesomeProject，然後打開 AVD Manager (AVD Manager 的 icon: 如果你是剛安裝好 Android Studio，你需要先建立 AVD (Android Virtual Device): 點擊 Create Virtual Device 選擇你要的虛擬裝置，然後按 Next: 選擇 Q API Level 29 image，然後按 Next: 再按 Finish: 新增完 AVD 後，就可以按綠色三角形的按鈕來啟動: 在 VSCode 中打開 RN 專案，並在專案下執行 yarn android: 1yarn android 就可以看到 RN 專案運行在 Android Studio 上了: 可以在 App.js 修改幾行程式碼看效果(記得按 command + s 儲存變更): USB 連接實體裝置 很多時候會需要連接實體裝置來運行，例如當你的專案需要使用到手機的 camera 時，就會需要使用真的實體機來看效果。 要在實體手機上運行，需要以下步驟: 在實體手機上點選 設定 → 關於手機 → 軟體資訊，找到轉體資訊中的版本號碼，連續點擊版本號碼 7 下，手機就會啟動開發者模式。 回到手機上的 設定 畫面，會看到多出一個 開發人員選項，點擊進入開發人員選項。 在開發人員選項中，找到 USB 偵錯 並開啟。 用 USB 連接電腦和手機裝置，然後在 RN 專案下執行 adb devices，查看裝置有無連接成功: 1234$ adb devices List of devices attached 14ed2fcc device # 實體裝置 ❗️❗️注意: 一次只能連接一個裝置(包含 Android Studio)，也就是需要確保 adb devices 回傳的 List of devices attached 中只有 1 個是連線狀態，否則後續操作可能會失敗。如果你要使用實體裝置，就斷開 Android Studio; 要使用 Android Studio，就斷開實體裝置! 執行 yarn android，就可以看到它在實體裝置上運行了: 1yarn android 結束後記得關閉實體手機的開發者模式: 設定 → 開發者模式 → 關閉 結語 …筆者身為一個 Web 開發者，覺得 App 的開發者也太有耐性了吧! 🤔 參考資源 RN Docs - Setting up the development environment RN Docs - Running On Device","link":"/article/rn-hello-world.html"},{"title":"用純 CSS 做定格動畫","text":"什麼是定格動畫？簡單來說，是一種動畫技術，它的原理是將每幀不同的圖像快速播放，因人眼有視覺暫留，所以會產生動畫效果。小時候玩的手翻書就是以這樣的原理來達成動畫的效果！ 事前準備 要用 CSS 完成定格動畫，首先需要有雪碧圖(Sprite)素材，當然，還需要會 CSS animation 的基本操作。 雪碧圖(Sprite) CSS animation 什麼是雪碧圖(Sprite) 將多張圖像整合為單一圖像，然後利用定位的方式顯示各部分圖的技術，早期網頁常以這種方式來減少圖片加載的次數，以便提高網頁顯示速度。 CSS animation 在 CSS animation 包含了以下幾種屬性，其中，若要做定格動畫，timing-function 的設定為關鍵，需要將 timing-function 設定為 steps。 動畫名稱 animation-name 持續時間 animation-duration 時間函數 animation-timing-function ease (預設值) ease-in ease-in-out ease-out linear steps(n, step position) 延遲時間 animation-delay 播放次數 animation-iteration-count 播放方向 animation-direction 前後狀態 animation-fill-mode 運行停止 animation-play-state steps(n, step position) steps 第一個參數 n 為一正整數，至於第二個參數 step position，這裡僅介紹 start 與 end(預設值) 兩個值。 n： 正整數 step position start：動畫一開始就跳一階 end (預設值) 與其他多數 timing-function 不一樣的是，step 像是階梯(step) 一樣，一階一階，而非完全連續型函數。 下圖左方為 start 的 timing-function，右方為 end 的 timing-function\b，若看不懂 timing-function 其實也沒關係，會用就好XD 用一個簡單的小範例可看出 start 與 end 的差異。 若要做定格動畫，我們需要利用 end 的特性。 See the Pen PowbBxq by yachen (@yachen) on CodePen. 開始做定格動畫 有了一些預備知識之後，就可以來動手做定格動畫了！只要依照以下 3 個步驟就可以完成。 step1 確認雪碧圖有幾幀 ⇒ 決定 steps(n) 中的 n，完整寫法為 steps(n, end)，可省略 end 不寫(因為是預設值)。 例如： 下方雪碧圖有 8 幀 ⇒ steps(8)。 step2 確認雪碧圖的總寬度(或總高度) ⇒ 決定總共要移動多少距離。 例如：下方雪碧圖的總寬度為 2880px ⇒ 圖片將移動(translateX) 2880px。 step3 計算每一幀的寬度或高度 ⇒ 決定容器元素的寬度或高度。 每一幀的寬度 ＝ 總寬度 / 幀數 所以每一幀的寬度為 2280px / 8，等於 360px ⇒ 將容器元素寬度設定為 360px 實現結果 1234&lt;div class=\"container\"&gt; &lt;!-- 雪碧圖(總寬度 2880px，共 8 幀)--&gt; &lt;img src=\"https://i.imgur.com/5aXROc2.png\" alt=\"\"/&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728.container { width: 360px; // 總寬度 2880px / 8幀 overflow: hidden; animation: moveContainer 5s infinite linear;}img { animation: run 0.5s infinite steps(8); // 8 幀}@keyframes run { 0% { transform: translateX(0px); } 100% { transform: translateX(-2880px); // 總寬度 2880px }}// 移動 container，製造「向前跑」效果@keyframes moveContainer { 0% { transform: translateX(0px); } 100% { transform: translateX(1600px); }} See the Pen jOEMBzQ by yachen (@yachen) on CodePen. 可以在網路上找自己喜歡的雪碧圖素材，運用相同的原理，做出各種有趣的定格動畫。 See the Pen YzPGNaK by yachen (@yachen) on CodePen. See the Pen VwYmVYd by yachen (@yachen) on CodePen. 參考資源： CSS Easing Functions Level 1 MDN-timing-function","link":"/article/%E7%94%A8%E7%B4%94CSS%E5%81%9A%E5%AE%9A%E6%A0%BC%E5%8B%95%E7%95%AB.html"},{"title":"三種改變函式內部 this 的方式：apply()、call()、bind()","text":"在 JavaScript 中，改變函數內部 this 的指向常見的方式有 call()、apply()、bind()，而這三種方式又存在些微差異。 call() call() 方法會呼叫(執行)一個函數，且可以同時改變函數內部的 this 指向。 語法： 1fun.call(thisArg ,arg1, arg2, ...); 參數說明： thisArg：在函式運行時的 this 指向，若省略則僅執行函式而不改變 this 指向。 arg1, arg2, …：傳遞的參數(可省略)。 例如： 在非嚴格模式下，函式 foo 中的 this 指向的原本是 window，因在此例子中，foo 其實是屬於 window 物件的一個方法。(若在嚴格模式下，則為 undefined) 123456789var obj = { name: 'yachen'}function foo(){ console.log(this);} foo(); // window，其實這裡的 foo() 是 window.foo() 剛提到，call() 會呼叫(執行)函式，但若無給第一個參數，則僅會呼叫函式而不會改變 this 指向，所以除了用 foo() 執行 foo 函式之外，也可以透過 call() 來呼叫(當然不需要多此一舉)。 1foo.call(); // window 現在除了呼叫 foo 函式，同時想要將函式 foo 裡的 this 指向改為 obj，可以使用 call() 來達成。 1foo.call(obj); // obj 還可以傳遞一些參數。 123456789101112var obj = { name: 'yachen'}function foo(a, b){ console.log(this); console.log(a + b);} foo.call(obj, 1, 2); // obj // 3 實現繼承 call() 也可以用來實現繼承。 123456789101112131415function Person(name, age){ this.name = name; this.age = age; this.say = function(){ console.log(`${this.name} is ${this.age} years old`);}};function Taiwanese(name, age){ // this 指向 me Person.call(this, name, age);}var me = new Taiwanese('yachen', 18);me.say(); // \"yachen is 18 years old\" apply() 使用 apply() 會呼叫一個函數，同時可以改變函數內部 this 指向，apply() 與 call() 幾乎一樣，最大的不同是 call() 接受一連串的參數，而 apply() 接受一組陣列(或類陣列)形式的參數。 語法： 1fun.apply(thisArg, [argsArray]); 參數說明： thisArg：在函式運行時的 this 指向。 [argsArray]：傳遞的參數必須為陣列或類陣列(可省略)。 bind() bind() 能改變 this 指向，但不會呼叫(執行)函數，會 copy 並返回一個新的函數。 語法： 1fun.bind(thisArg, arg1, arg2, ...) 參數說明： thisArg：在 fun 函數運行時指定的 this 值。 arg1, arg2, …：傳遞其他參數(可省略)。 例如： 使用 bind() 將函式 foo 裡的 this 指向改為 obj，同時傳遞 1 和 2 兩個引數，有別於 call() 與 apply()，bind() 並不會呼叫執行 foo 函式，僅會返回一個新的函式。 12345678910var obj = { name: 'yachen'}function foo(a, b){ console.log(this); console.log(a + b);}foo.bind(obj, 1, 2); // 並未執行，而使返回一個新的函式 因 bind() 並不會呼叫執行 foo 函式，而是返回一個新的函式，若想要同時執行 foo，則需手動加上 ()。 123foo.bind(obj, 1, 2)(); // obj// 3 現在來看看返回的新函式長什麼樣子，可以打開瀏覽器，並輸入以下代碼。 1234567891011var obj = { name: 'yachen'}function foo(a, b){ console.log(this); console.log(a + b);}var newFoo = foo.bind(obj, 1, 2); // 並未執行，而使返回一個新的函式console.log(newFoo); 印出 newFoo： 咦？ newFoo 不就是 foo 嗎？ 再試著輸入以下代碼，事實證明 newFoo 不等於 foo。 1console.log(newFoo === foo); // false 在開發中，最常使用的應該是 bind()，因為很多情況下我們只是想改變 this，不想同時執行函數。 例如現在有一個按鈕，想要在用戶點擊後，禁用此按鈕 3 秒。 1&lt;button&gt;按鈕&lt;/button&gt; 若直接在定時器裡使用匿名 function(){} 形式的 callback，定時器裡的 this 指向的是 window。 123456789101112const btn = document.querySelector('button');btn.addEventListener('click', eventHandler);function eventHandler(){ // this 指向按鈕 btn this.disabled = true; setTimeout(function(){ // this 指向 window this.disabled = false; },3000)} 這時候 bind() 就可以派上用場了，因為不想要在改變 this 的同時執行 this.disabled = false，而是希望透過定時器 3 秒後執行，此時就不適用 call() 與 apply()。 1234567891011const btn = document.querySelector('button');btn.addEventListener('click', eventHandler);function eventHandler(){ // this 指向按鈕 btn this.disabled = true; setTimeout(function(){ this.disabled = false; }.bind(this),3000) // this 改指向按鈕 btn} 當然，也可以直接將定時器裡的 callback function 改成箭頭函式(arrow function)的形式來解決。 123456789101112const btn = document.querySelector('button');btn.addEventListener('click', eventHandler);function eventHandler(){ this.disabled = true; // 改為箭頭函式 setTimeout(()=&gt;{ // this 指向 btn this.disabled = false; },3000)} 總結 call()、apply()、bind() 皆可以改變函數內部的 this ，三者的差異在於： 自動呼叫函數 參數(可省略) call() ⭕️ arg1, arg2, … apply() ⭕️ [arg1, arg2, …] bind() ❌ arg1, arg2, … 參考資料： MDN - Function.prototype.call MDN - Function.prototype.apply() MDN - Function.prototype.bind() MDN - setTimeout","link":"/article/%E6%94%B9%E8%AE%8A%E5%87%BD%E5%BC%8F%E7%9A%84this.html"},{"title":"CSS 原理 - Collapsing margins","text":"什麼是 Collapsing margins？ 先來看一段 W3C 規範 的敘述： In CSS, the adjoining margins of two or more boxes (which might or might not be siblings) can combine to form a single margin. Margins that combine this way are said to collapse, and the resulting combined margin is called a collapsed margin. 簡單來說，當相鄰(adjoining)的 margin 相遇時，若合併成一個 margin，這種情況稱為 Collapsing margins。其中，W3C 對於相鄰(adjoining)的定義為： 僅發生於垂直方向 皆為在文檔流中(in flow)的塊級元素(block-level)元素，且參與同一個塊格式化上下文(block formatting context，BFC)。 例如，若是元素會創建新的 BFC，像是根元素 &lt;html&gt; 、float、position: absolute…等等，該元素就不會有 margin collapsing，至於什麼情況下會創建新的 BFC，可參考 MDN-block formatting context。 什麼時候會發生 margin collapsing？ margin collapsing 可分為兩種情況，一種是同層元素之間，另一種是元素與其父(母)容器之間，但並非所有 block-level 元素皆會發生 margin collapsing，而是有前提條件的。 (一) 相鄰的兄弟姊妹 同層且相鄰的 block 元素的 margin-bottom 與 margin-top 相遇時，發生重疊，僅發生於垂直方向。 前提條件： block 須符合相鄰(adjoining)的定義： 皆為在文檔流中(in flow)的塊級元素(block-level)元素，且參與同一個塊格式化上下文(BFC)。 例如：兩個相鄰的 block 元素，紅色 block 的 margin-bottom = 30px，黑色 block 的 margin-top = 30px，最終兩個 block 元素之間的距離為 30px，而非 60px。 範例連結 12&lt;div class=\"block1\"&gt;我有 margin-bottom：30px&lt;/div&gt;&lt;div class=\"block2\"&gt;我有 margin-top：30px&lt;/div&gt; 123456789.block1 { margin-bottom: 30px; background-color: red;}.block2 { margin-bottom: 30px; background-color: black;} (二) 容器與其第一個/最後一個子元素 亦僅發生於垂直方向，且有其前提條件。 前提條件: 皆為在文檔流中(in flow)的塊級元素(block-level)元素，且參與同一個塊格式化上下文(BFC)。 容器無設定邊框(border)、內距(padding)或加上 clear-fix 的屬性。 例如： 虛線為容器的 outline，紅色區塊為容器內的第一個子元素，現在子元素頂部緊貼著容器頂部。若想利用 margin-top 屬性，讓子元素的頂部距離容器頂部 50px。 結果會發現，子元素的頂部並沒有與容器頂部分離！ 範例連結 123&lt;div class=\"container\"&gt; &lt;div class=\"first_child\"&gt;容器中的第一個子元素&lt;/div&gt;&lt;/div&gt; 123.first_child { margin-top: 50px;} 打開開發人員工具檢視一下，會發現子元素的 margin-top 竟然跑出容器外了，這結果與直接在父容器上設定 margin-top: 50px 是一樣的。 解決方法： 使其不再符合前提條件，例如不再是 block 或是創建 BFC。 margin 計算方式 當發生 margin collapsing 時，由於外距(margin)可為負數，故會有三種情況： 兩個 margin 皆為正 ⇒ 取大值 一個 margin 為正，一個 margin 為負 ⇒ 相加 兩個 margin 皆為負 ⇒ 取最小 (最負) 參考資料 W3C - Collapsing Margins W3C - Box Model MDN - Mastering margin collapsing MDN - Block formatting context","link":"/article/Collapsing-margins.html"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"w3HexSchool","slug":"w3HexSchool","link":"/tags/w3HexSchool/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Vue3","slug":"Vue3","link":"/tags/Vue3/"},{"name":"composition API","slug":"composition-API","link":"/tags/composition-API/"},{"name":"MDN","slug":"MDN","link":"/tags/MDN/"},{"name":"Contributors","slug":"Contributors","link":"/tags/Contributors/"},{"name":"developer","slug":"developer","link":"/tags/developer/"},{"name":"PR","slug":"PR","link":"/tags/PR/"},{"name":"React Native","slug":"React-Native","link":"/tags/React-Native/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"}],"categories":[{"name":"web","slug":"web","link":"/categories/web/"},{"name":"developer","slug":"developer","link":"/categories/developer/"},{"name":"App","slug":"App","link":"/categories/App/"}]}