<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一起成為 MDN 的貢獻者吧!</title>
      <link href="/article/pr-mdn.html"/>
      <url>/article/pr-mdn.html</url>
      
        <content type="html"><![CDATA[<p>身為一個 web developer，查找 MDN 應該是家常便飯，如果想對 MDN 文件內容進行勘誤或是幫忙更新文件，可以參考一下這篇文章XD</p><p>故事是這樣的…某天在查找 MDN docs 時，突然注意到最底下這個區塊(以前都視而不見)…那天滑鼠不知為何就這樣點了進去，然後突然覺得發現新大陸🐒，加上原本正打算好好的看一下某個主題的 MDN API docs，於是就興起了一邊看 MDN docs 一邊幫忙翻譯的衝動。後來發 PR(Pull Request) 也意外的順利通過，決定來整理一下重點和注意事項給有興趣跳坑的人做參考。</p><a id="more"></a><br/><p><img src="./pr-mdn/foreword.png" alt=""></p><p>整個過程大致可分為四個步驟:<br>一、fork &amp; clone MDN 的 repo<br>二、詳細閱讀格式規範和注意事項<br>三、進行一些設置，在 local 即時預覽正在編輯的 MDN 頁面<br>四、編輯 &amp; 發送 PR</p><p>接下來會針對以上四個步驟進一步說明</p><br/><h2 id="一、Fork-Clone-repo"><a class="header-anchor" href="#一、Fork-Clone-repo"></a>一、Fork &amp; Clone repo</h2><p>MDN 的文件內容分為以下二個 repo，如果要編輯英文版文件，fork <a href="https://github.com/mdn/content">content repo</a> 即可; 如果想要編輯「<code>非</code>」英文版的 MDN 文件， 則以下<mark>二個 repo 都要 fork</mark> :</p><ol><li><a href="https://github.com/mdn/content">content</a>：這個 repo 只存放英文版的文件內容</li><li><a href="https://github.com/mdn/translated-content">translated-content</a>：這個 repo 存放所有「非」英文版的文件內容</li></ol><p>fork 完成後，再從自己的 Github 把 fork 來的 repo clone 下來。</p><br/><h2 id="二、閱讀格式規範和注意事項"><a class="header-anchor" href="#二、閱讀格式規範和注意事項"></a>二、閱讀格式規範和注意事項</h2><p>在開始編輯之前，務必先看過 repo 說明，確認自己的編輯有符合規範後再發送 PR，減少審核人員的負擔。</p><p><strong>以下整理幾個大重點:</strong></p><ol><li><p>英文版最大！所有的翻譯都是向英文版看齊，所以請直接拿英文版(content 資料夾)的 .html 或 .md 檔案內容的進行翻譯，因為其他語言(translated-content 資料夾)的內容不一定是最新的。</p></li><li><p>在 content 和 translated-content 下的 <code>/files</code> 資料夾中，可能會看到夾雜著 .html 或 .md 的檔案，MDN 團隊計畫慢慢將 .html(舊) 更新成 .md(新)，所以如果要翻譯的話建議可直接使用 .md 檔。</p></li><li><p>可以看到在 content 和 translated-content 下的 <code>/files</code> 資料夾中，還有巢狀的資料夾，在 translated-content 編輯時，如果需要新增 .html 或是 .md 檔案(可能之前沒人翻譯過，你是 NO.1)，須確認巢狀結構、資料夾名稱以及檔案名稱和 content 資料夾的一致。</p></li><li><p>參考格式規範：<a href="https://developer.mozilla.org/en-US/docs/MDN/Guidelines">MDN guidelines</a>、<a href="https://developer.mozilla.org/en-US/docs/MDN/Guidelines/Writing_style_guide">Writing style guide</a>、<a href="https://developer.mozilla.org/en-US/docs/MDN/Contribute/Markdown_in_MDN">guide to writing Markdown for MDN</a></p></li><li><p>需注意有些語言可能會有額外的格式規範，例如以「繁體中文」來說，可以在 translated-content 資料夾的 <code>/docs/zh-tw/translation-guide.md</code> 看到針對繁體中文格式的額外規範說明，像是標點符號、空白修飾、術語等等。</p></li><li><p>務必自己另開一個新的 branch 來進行編輯，不要在 main branch 進行任何修改。</p></li><li><p>注意 git commit 的拆分以及 commit message。</p></li></ol><p>📌 更多細節請詳見 <a href="https://github.com/mdn/content">content</a> 和 <a href="https://github.com/mdn/translated-content">translated-content</a></p><br/><h2 id="三、設置-預覽編輯畫面"><a class="header-anchor" href="#三、設置-預覽編輯畫面"></a>三、設置 &amp; 預覽編輯畫面</h2><p>📍 content 資料夾 👉 在 local 端跑起來可預覽編輯的 MDN 頁面(也可以預覽 translated-content 資料夾的東西，很酷!🧞‍♂️)<br>📍 translated-content 資料夾 👉 在這個資料夾可編輯「非」英文版本的 MDN 文件內容</p><p><strong>clone 之後，先在編輯器打開 <mark>content</mark>，接著進行下設定:</strong></p><ol><li>讓 git 也連到 mdn/content 的 repo，之後就可以在 local 端 pull mdn/content 的最新內容，執行:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add mdn git@github.com:mdn/content.git</span><br></pre></td></tr></table></figure><ol start="2"><li>確認有添加成功，執行:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p><img src="./pr-mdn/git_remote_content.png" alt=""></p><ol start="3"><li>建立自己的 branch:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch your-branch-name</span><br></pre></td></tr></table></figure><ol start="4"><li>切換到自己的 branch:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout your-branch-name</span><br></pre></td></tr></table></figure><ol start="5"><li>在 content 目錄下添加 .env 檔案，.env 檔案裡放上 <code>EDITOR</code> 和 <code>CONTENT_TRANSLATED_ROOT</code> ，CONTENT_TRANSLATED_ROOT 後面放路徑，指向 translated-content 下的 files 資料夾:<br><strong>❗️ 如果只想編輯英文版的文件，沒有要在本地端預覽其他語言的文件，則不需要 CONTENT_TRANSLATED_ROOT</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EDITOR &#x3D; code;</span><br><span class="line">CONTENT_TRANSLATED_ROOT&#x3D;&#x2F;Users&#x2F;yachen&#x2F;Desktop&#x2F;translated-content&#x2F;files 👉 不要複製貼上，這個是我的路徑，記得改成你自己的</span><br></pre></td></tr></table></figure><ol start="6"><li>執行 <code>yarn start</code>，之後可以在 local 端(local:5042)預覽編輯頁面，稍後在步驟四會進一步說明</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure><p>(如果只要編輯英文版文件，以下 7.8.9 的設定可省略)<br>7. 在編輯器打開 <mark>translated-content</mark>，讓 git 也連到 mdn/translated-content 的 repo，之後就可以在 local 端 pull mdn/translated-content 的最新內容，執行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add mdn git@github.com:mdn/translated-content.git</span><br></pre></td></tr></table></figure><ol start="8"><li>建立自己的 branch:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch your-branch-name</span><br></pre></td></tr></table></figure><ol start="9"><li>切換到自己的 branch:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout your-branch-name</span><br></pre></td></tr></table></figure><br/><h2 id="四、編輯-發送-PR"><a class="header-anchor" href="#四、編輯-發送-PR"></a>四、編輯 &amp; 發送 PR</h2><p>首先在編輯器打開 content 和 translated-content ，並且完成步驟二的設定，確定 <code>yarn start</code> 已經成功執行。<br>在編輯時，一定會想要即時預覽編輯的畫面，以下分享我的小撇步~<br>直接舉例子來做說明，假設「我想翻譯 <code>getUserMedia</code> 的繁體中文文件」：</p><ol><li>可直接打開 google 搜尋「getUserMedia mdn」，就可找到這份<a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia">線上的文件</a>，接著複製 domain url 後方的路由 <code>/en-US/docs/Web/API/MediaDevices/getUserMedia</code>。<mark>注意這個巢狀路由，和巢狀的資料夾結構是一樣的，可以利用它快速找到某個文件檔案</mark>。</li></ol><p><img src="./pr-mdn/copy_route.png" alt=""></p><br/><ol start="2"><li>然後貼到 local:5042 後方，也就是 <code>http://localhost:5042/en-US/docs/Web/API/MediaDevices/getUserMedia</code>，就可以在 local 端即時預覽英文版的 getUserMedia API 文件的編輯畫面。<br><img src="./pr-mdn/preview_en.png" alt=""></li></ol><br/><ol start="3"><li>可以從下拉選單切換不同語言，同時可快速看出這份文件目前有哪些語言翻譯 (可以看出這份文件目前還沒有人翻成繁體中文)<br><img src="./pr-mdn/languages.png" alt=""></li></ol><br/><ol start="4"><li>從 3. 下拉選單切換語言的動作可看出只要將 /<code>en-US</code>/docs/Web/API/MediaDevices/getUserMedia 的 <code>en-US</code> 改成其他語言，例如: ja(日文) 或 ko(韓文)，就可以切換到其他語言的 getUserMedia 文件(如果該語言有人翻譯這份文件的話)<br><img src="./pr-mdn/ja.png" alt=""></li></ol><br/><ol start="5"><li>從 3. 也可以看出，目前 getUserMedia API 沒有繁體中文的文件，所以如果「我想幫忙翻譯成繁體中文(zh-tw)」的話，就需要在 translated-content 資料夾下的 <code>/files/zh-tw/web/api/mediaDevices/getUserMedia</code> 建立一個 <a href="http://index.md">index.md</a> 檔案。如果是第一個翻譯的人，就會需要自己建立相關的資料夾和 .md 檔案，注意！<mark>在 translated-content 所新增的資料夾/檔案結構和名稱都要和英文版(content 資料夾)的一樣!</mark><br><img src="./pr-mdn/folder.png" alt=""></li></ol><br/><ol start="6"><li>完成了 5. 之後，到英文版的 content 資料夾的 <code>/files/en-US/web/api/mediaDevices/getUserMedia</code> 的 .md 檔案，直接複製並貼到 translated-content 裡相同位置的 .md 檔案，就可以在 local 端看到語言切換的下拉選單，多出了「繁體中文」的選項！點擊切換到繁體中文！<br><img src="./pr-mdn/copy_md.png" alt=""></li></ol><p><img src="./pr-mdn/option_zh.png" alt=""></p><br/><ol start="7"><li>開始進行編輯，可以即時預覽畫面<br><img src="./pr-mdn/edit.png" alt=""></li></ol><br/><ol start="8"><li>編輯完成後，push 到自己的 github，並發送 PR，等待該語系的審核人員審查。</li></ol><br/><h2 id="結語"><a class="header-anchor" href="#結語"></a>結語</h2><p>第一次在大型的開源專案發 PR，也意外的順利，覺得開心哈哈</p><p>在過程中也發現，MDN docs 的繁體中文資源相對少很多，雖然說看英文版才能獲得第一手最新的資訊，但還是希望繁體中文的勢力可以日益壯大XD</p><p>以這次的經驗來說，總結了以下五大收穫(優點)：</p><ol><li>看了自己想看的某部分 MDN API docs，獲得相關知識</li><li>在翻譯的過程中，加深自己對於 docs 內容的印象 (怕被退件 &amp; 翻錯誤人子弟所以看得更仔細)</li><li>可以順便練英文</li><li>體驗大型開源專案的 PR 流程</li><li>讓閱讀 MDN docs 的人們可以多一個語言切換的選擇</li></ol><p>是不是助人助己~ 好處多多~😆      <sub>(缺點:需要時間XD)</sub></p><br/><p>最後還有一個 bonus! 就是 Github 個人頁面上會出現一個閃亮亮的酷東西😍，趕緊入坑吧各位！</p><p><img src="./pr-mdn/tag.png" alt=""></p><br/><br/><br/><p><b>參考資源:</b></p><ol><li><a href="https://github.com/mdn/content">Content of MDN Web Docs</a></li><li><a href="https://github.com/mdn/translated-content">Translated content of MDN Web Docs</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> developer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MDN </tag>
            
            <tag> Contributors </tag>
            
            <tag> developer </tag>
            
            <tag> PR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native - 打包 AAB(APK)</title>
      <link href="/article/rn-apk.html"/>
      <url>/article/rn-apk.html</url>
      
        <content type="html"><![CDATA[<p>這系列文章將一步步介紹如何在 mac 上搭建 Android 和 ios 的開發環境(React Native ClI)、如何在模擬器和實體裝置中運行、如何打包 AAB(APK) 和 IPA。</p><p>而這篇將介紹如何<b>將你的 RN 專案打包成 AAB(APK)！</b>，如果你還沒建置好 Android 的開發環境，請先跟著:</p><ul><li><a href="https://yachen168.github.io/article/rn-environment-android.html#more">React Native 開發環境建置 - Android 篇(上)</a></li><li><a href="https://yachen168.github.io/article/rn-hello-world.html#more">React Native 開發環境建置 - Android 篇(下)</a></li></ul><p>的步驟設定 Android 開發環境和建立 RN 專案。</p><a id="more"></a><br/><h1 id="生成簽名密鑰"><a class="header-anchor" href="#生成簽名密鑰"></a>生成簽名密鑰</h1><p>首先，用 VSCode 打開你的 RN 專案，在專案的根目錄下，執行以下指令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo keytool -genkey -v -keystore my-upload-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000</span><br></pre></td></tr></table></figure><p>上方指令中的 <code>my-upload-key.keystore</code> 可以任意改成 xxxx.keystore<br>上方指令中的 <code>my-key-alias</code> 可以任意改成 xxxx，但<b><code>請務必記得你設定的 alias!</code></b></p><p>接著需要填寫一些設定:</p><ul><li><p>輸入金鑰儲存庫密碼: yachen168 (自行設定，<code>必須記住!</code>)</p></li><li><p>再次輸入新密碼: yachen168</p></li><li><p>您的名字與姓氏為何: yachen (自行設定)</p></li><li><p>您的組織單位名稱為何: front-end (自行設定)</p></li><li><p>您的組織名稱為何: yachen    (自行設定)</p></li><li><p>您所在的城市或地區名稱為何: tainan    (自行設定)</p></li><li><p>您所在的州及省份名稱為何: tainan   (自行設定)</p></li><li><p>此單位的兩個字母國別代碼為何: TW   (自行設定)</p></li><li><p>CN=yachen, OU=front-end, O=yachen, L=tainan, ST=tainan, C=TW 正確嗎？: 是</p></li><li><p>輸入 <my-key-alias> 的金鑰密碼 (如果要和金鑰儲存庫密碼相同 👉 直接按 Enter) : 按 enter 或另外設定密碼(<code>必須記住!</code>)</p></li></ul><p>完成上述動作後，會看到專案下多了一個 <code>xxxx.keystore</code> 的檔案:</p><p><img src="./rn-apk/keystore-1.png" alt=""></p><br/><h2 id="設置-Gradle-variables"><a class="header-anchor" href="#設置-Gradle-variables"></a>設置 Gradle variables</h2><ol><li>將剛剛生成的 <code>xxxx.keystore</code> 檔案移到專案中的 android/app 資料夾下:</li></ol><p><img src="./rn-apk/keystore-2.png" alt=""></p><ol start="2"><li>在 ~/.gradle/gradle.properties(全域，將套用到所有專案) 或你的 RN 專案中的 <code>android/gradle.properties</code> 加上 (<b>下方 4 個等號後面改成你剛剛填寫的設定</b>):</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MYAPP_UPLOAD_STORE_FILE=my-upload-key.keystore</span><br><span class="line">MYAPP_UPLOAD_KEY_ALIAS=my-key-alias</span><br><span class="line">MYAPP_UPLOAD_STORE_PASSWORD=你設定的密碼</span><br><span class="line">MYAPP_UPLOAD_KEY_PASSWORD=你設定的密碼</span><br></pre></td></tr></table></figure><p><img src="./rn-apk/keystore-5.png" alt=""></p><h2 id="將簽名配置加到專案中的-Gradle-config"><a class="header-anchor" href="#將簽名配置加到專案中的-Gradle-config"></a>將簽名配置加到專案中的 Gradle config</h2><p>在專案下的 android/app/build.gradle 中添加以下配置(參考下圖):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123; ... &#125;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            if (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) &#123;</span><br><span class="line">                storeFile file(MYAPP_RELEASE_STORE_FILE)</span><br><span class="line">                storePassword MYAPP_RELEASE_STORE_PASSWORD</span><br><span class="line">                keyAlias MYAPP_RELEASE_KEY_ALIAS</span><br><span class="line">                keyPassword MYAPP_RELEASE_KEY_PASSWORD</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            ...</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./rn-apk/keystore-3.png" alt=""><br><img src="./rn-apk/keystore-4.png" alt=""></p><br/><h1 id="生成-ABB"><a class="header-anchor" href="#生成-ABB"></a>生成 ABB</h1><p>cd 進到 RN 專案的 android 資料夾中，然後執行 <code>./gradlew bundleRelease</code> 打包 <code>ABB</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd android</span><br><span class="line">./gradlew bundleRelease</span><br></pre></td></tr></table></figure><p>生成的 <code>ABB</code> 檔案會在 <code>android/app/build/outputs/bundle/release</code> 中，之後可以上架到 Google Play 商店。</p></br><h1 id="生成-APK"><a class="header-anchor" href="#生成-APK"></a>生成 APK</h1><p>如果你還不想上架到 Google Play 商店，只是想直接傳給親朋好友做測試，那可以選擇打包 <code>APK</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd android</span><br><span class="line">./gradlew assembleRelease</span><br></pre></td></tr></table></figure><p>生成的 <code>APK</code> 檔案會在 <code>android/app/build/outputs/apk/release</code> 中，將 <code>app-release.apk</code> 的檔案傳給朋友，朋友直接在手機上下載安裝後就可以使用你的 app 了！</p><p><img src="./rn-apk/apk-1.png" alt=""></p><p>打開 APP:</p><p><img src="./rn-apk/apk-2.png" alt=""></p><br/><h1 id="結語"><a class="header-anchor" href="#結語"></a>結語</h1><p>這篇文章主要目的為「如何打包 ABB(APK)」，因筆者目前自學 RN 還不到 1 個禮拜，所以有關於 APK 效能的一些進階設定，選擇先略過 &gt;&lt;，有興趣的讀者可以先參考 <a href="https://reactnative.dev/docs/signed-apk-android">RN 文件</a> 上較詳細的說明。如果文章中有描述不正確的地方，也歡迎留言指正 😆。</p><p>最後，如果在打包過程中有發生任何 error，請先耐心的回頭檢查 Android 開發環境、keystore 是否有正確設置，任何一個小環節沒設置好都可能發生問題!</p><p>Android 篇就暫時告一段落了，接下來將進入 ios 囉!</p><br/><br/><p><b>參考資源</b></p><ol><li><a href="https://reactnative.dev/docs/signed-apk-android">RN Docs - signed-apk-android</a></li><li><a href="https://developer.android.com/studio/publish/app-signing">Android developer - app-signing</a></li><li><a href="https://yachen168.github.io/article/rn-environment-android.html#more">React Native 開發環境建置 - Android 篇(上)</a></li><li><a href="https://yachen168.github.io/article/rn-hello-world.html#more">React Native 開發環境建置 - Android 篇(下)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> App </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native 開發環境建置 - Android 篇(下)</title>
      <link href="/article/rn-hello-world.html"/>
      <url>/article/rn-hello-world.html</url>
      
        <content type="html"><![CDATA[<p>這系列文章將一步步介紹如何在 mac 上搭建 Android 和 ios 的開發環境(React Native ClI)、如何在模擬器和實體裝置中運行、如何打包 AAB(APK) 和 IPA。</p><p>會選擇 React Native ClI 而不是較友善的 Expo ClL 是因為筆者之後想要在 RN 上用 WebRTC，考慮到支援度的問題，所以選擇 React Native ClI。</p><p>而這篇將介紹如何在<b>模擬器(Android Studio)和實體裝置中運行你的 RN 專案！</b>在閱讀這篇文章之前，請先確實按照上一篇 <a href="https://yachen168.github.io/article/rn-environment-android.html#more">React Native 開發環境建置 - Android 篇(上)</a> 的步驟進行相關的 Android 開發環境設定。</p><a id="more"></a><br/><h1 id="Hello-World"><a class="header-anchor" href="#Hello-World"></a>Hello World!</h1><p>現在可以開始建立 RN 專案了！</p><blockquote><p>❗️❗️注意: 如果你之前有在全域安裝過 <code>react-native-cli</code>，記得要先 <code>npm uninstall -g react-native-cli</code>，否則可能會出現一些無法預期的問題。</p></blockquote><br/><p>建立一個名叫 AwesomeProject 的 RN 專案:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx react-native init AwesomeProject</span><br></pre></td></tr></table></figure><p>或是建立 Typescript 的 template:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx react-native init AwesomeTSProject --template react-native-template-typescript</span><br></pre></td></tr></table></figure><p>建立 RN 專案後，可以透過兩種方式查看 android 的運行結果:</p><ul><li>模擬器 - Android Studio</li><li>實體裝置 (需要 USB 連接電腦和手機)</li></ul><br/><h1 id="在模擬器-Android-Studio-上運行"><a class="header-anchor" href="#在模擬器-Android-Studio-上運行"></a>在模擬器(Android Studio)上運行</h1><p>使用 <code>Android Studio</code> 打開剛剛建立好的 AwesomeProject，然後打開 AVD Manager (AVD Manager 的 icon: <img src="./rn-hello-world/icon-avd.png" alt=""></p><p>如果你是剛安裝好 Android Studio，你需要先<a href="https://developer.android.com/studio/run/managing-avds">建立 AVD (Android Virtual Device)</a>: 點擊 <code>Create Virtual Device</code></p><p><img src="./rn-hello-world/create-avd.png" alt=""></p><p>選擇你要的虛擬裝置，然後按 <code>Next</code>:</p><p><img src="./rn-hello-world/virtual-device-1.png" alt=""></p><p>選擇 <code>Q API Level 29 image</code>，然後按 <code>Next</code>:</p><p><img src="./rn-hello-world/virtual-device-2.png" alt=""></p><p>再按 <code>Finish</code>:</p><p><img src="./rn-hello-world/virtual-device-3.png" alt=""></p><p>新增完 AVD 後，就可以按<b>綠色三角形</b>的按鈕來啟動:</p><p><img src="./rn-hello-world/virtual-device-4.png" alt=""></p><p><img src="./rn-hello-world/virtual-device-5.png" alt=""></p><p>在 VSCode 中打開 RN 專案，並在專案下執行 <code>yarn android</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn android</span><br></pre></td></tr></table></figure><p>就可以看到 RN 專案運行在 Android Studio 上了:</p><p><img src="./rn-hello-world/virtual-device-6.png" alt=""></p><p>可以在 <code>App.js</code> 修改幾行程式碼看效果(記得按 command + s 儲存變更):</p><p><img src="./rn-hello-world/virtual-device-7.png" alt=""></p><br/><h1 id="USB-連接實體裝置"><a class="header-anchor" href="#USB-連接實體裝置"></a>USB 連接實體裝置</h1><p>很多時候會需要連接實體裝置來運行，例如當你的專案需要使用到手機的 camera 時，就會需要使用真的實體機來看效果。</p><p>要在實體手機上運行，需要以下步驟:</p><ol><li><p>在實體手機上點選 <code>設定</code> → <code>關於手機</code> → <code>軟體資訊</code>，找到轉體資訊中的<code>版本號碼</code>，連續點擊<code>版本號碼</code> <code>7 下</code>，<b>手機就會啟動開發者模式</b>。</p></li><li><p>回到手機上的 <code>設定</code> 畫面，會看到多出一個 <code>開發人員選項</code>，點擊進入開發人員選項。</p></li><li><p>在開發人員選項中，找到 <code>USB 偵錯</code> 並<code>開啟</code>。</p></li><li><p>用 <b>USB 連接電腦和手機裝置</b>，然後在 RN 專案下執行 <code>adb devices</code>，查看裝置有無連接成功:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> adb devices</span></span><br><span class="line"></span><br><span class="line"> List of devices attached</span><br><span class="line"> 14ed2fcc device         # 實體裝置</span><br></pre></td></tr></table></figure><blockquote><p>❗️❗️注意: 一次只能連接一個裝置(包含 Android Studio)，也就是需要確保 <code>adb devices</code> 回傳的 List of devices attached 中<code>只有 1 個</code>是連線狀態，否則後續操作可能會失敗。<b>如果你要使用實體裝置，就斷開 Android Studio; 要使用 Android Studio，就斷開實體裝置!</b></p></blockquote></li><li><p>執行 <code>yarn android</code>，就可以看到它在實體裝置上運行了:</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn android</span><br></pre></td></tr></table></figure></li></ol><p>結束後記得關閉實體手機的開發者模式: 設定 → 開發者模式 → 關閉</p><br/><h1 id="結語"><a class="header-anchor" href="#結語"></a>結語</h1><p>…筆者身為一個 Web 開發者，覺得 App 的開發者也太有耐性了吧! 🤔</p><br/><br/><p><b>參考資源</b></p><ol><li><a href="https://reactnative.dev/docs/environment-setup">RN Docs - Setting up the development environment<br></a></li><li><a href="https://reactnative.dev/docs/running-on-device">RN Docs - Running On Device<br></a></li></ol>]]></content>
      
      
      <categories>
          
          <category> App </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native 開發環境建置 - Android 篇(上)</title>
      <link href="/article/rn-environment-android.html"/>
      <url>/article/rn-environment-android.html</url>
      
        <content type="html"><![CDATA[<p>這系列文章將一步步介紹如何在 mac 上搭建 Android 和 ios 的開發環境(React Native ClI)、如何在模擬器和實體裝置中運行、如何打包 AAB(APK) 和 IPA。因為筆者覺得 ios 比較複(機)雜(車)，所以會先從 Android 開始介紹。</p><p>會選擇 React Native ClI 而不是較友善的 Expo ClL 是因為筆者之後想要在 RN 上用 WebRTC，考慮到支援度的問題，所以選擇 React Native ClI。</p><a id="more"></a><br/><h1 id="安裝-dependencies"><a class="header-anchor" href="#安裝-dependencies"></a>安裝 dependencies</h1><p>在建置 Android 開發環境之前，需要先安裝的 dependencies 有：</p><ul><li>Node</li><li>Watchman</li><li>JDK (Java Development Kit)</li><li>Android Studio</li></ul><br/><h2 id="Node-Watchman-JDK"><a class="header-anchor" href="#Node-Watchman-JDK"></a>Node &amp; Watchman &amp; JDK</h2><p>使用 <code>Homebrew</code> 安裝 Node、Watchman、JDK：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line">brew install watchman</span><br><span class="line">brew install --cask adoptopenjdk/openjdk/adoptopenjdk8</span><br></pre></td></tr></table></figure><p>如果你以前就安裝過 Node，請確保 Node 版本為 12 以上。<br>如果你以前就安裝過 JDK，請確保 JDK 版本為 8 以上。</p><br/><h1 id="建置-Android-開發環境"><a class="header-anchor" href="#建置-Android-開發環境"></a>建置 Android 開發環境</h1><h2 id="安裝-Android-Studio"><a class="header-anchor" href="#安裝-Android-Studio"></a>安裝 Android Studio</h2><p>安裝完 Node、Watchman 和 JDK 後，就可以開始建置 Android 的開發環境了！<br><a href="https://developer.android.com/studio">下載並安裝 Android Studio</a>，需注意的是，在安裝 Android Studio 時，記得要將以下三個勾選起來：</p><ul><li>Android SDK</li><li>Android SDK Platform</li><li>Android Virtual Device</li></ul><br/><h2 id="安裝-Android-SDK"><a class="header-anchor" href="#安裝-Android-SDK"></a>安裝 Android SDK</h2><p>Android Studio 預設會安裝最新版的 SDK，而 React Native 需要的是 <code>Android 10 (Q)</code> 版本的 SDK，可以在 Android Studio 中的 <code>SDK Manager</code> 選擇 SDK 版本。</p><p>可以在 Android Studio menu 中的 <code>Preferences</code> → <code>Appearance &amp; Behavior</code> → <code>System Settings</code> → <code>Android SDK</code> 找到:</p><p><img src="https://i.imgur.com/PTNFhCy.jpg" alt=""></p><p>勾選 <code>Android 10 (Q)</code>:</p><p><img src="./rn-environment-android/android-sdk-1.png" alt=""></p><p>接著繼續在 <code>SDK Platform</code> 的 tab 下，勾選右下角的 <code>Show Package Details</code>，確認在 Android 10 (Q) 下有勾選：</p><ul><li>Android SDK Platform 29</li><li>Intel x86 Atom_64 System Image 或 Google APIs Intel x86 Atom System Image</li></ul><p><img src="./rn-environment-android/android-sdk-2.png" alt=""></p><p>在 <code>SDK Tools</code> 的 tab 中，勾選右下方的 <code>Show Package Details</code>，確認 <code>Android SDK Build-Tools</code> 下的 <code>29.0.2</code> 有被勾選起來:</p><p><img src="./rn-environment-android/android-sdk-3.png" alt=""></p><p>將 <code>Android SDK Command-line Tools (latest)</code> 勾選起來:</p><p><img src="./rn-environment-android/android-sdk-4.png" alt=""></p><p>最後按下 <code>Apply</code> 開始下載並安裝以上的設定!!!</p><br/><h2 id="配置-ANDROID-HOME-的環境變量"><a class="header-anchor" href="#配置-ANDROID-HOME-的環境變量"></a>配置 ANDROID_HOME 的環境變量</h2><p>打開終端機，在 $HOME/.bash_profile 或 $HOME/.bashrc (如果你是使用 zsh 則為 ~/.zprofile 或 ~/.zshrc) 添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export ANDROID_HOME=$HOME/Library/Android/sdk</span><br><span class="line">export PATH=$PATH:$ANDROID_HOME/emulator</span><br><span class="line">export PATH=$PATH:$ANDROID_HOME/tools</span><br><span class="line">export PATH=$PATH:$ANDROID_HOME/tools/bin</span><br><span class="line">export PATH=$PATH:$ANDROID_HOME/platform-tools</span><br></pre></td></tr></table></figure><p>之後執行 <code>source $HOME/.bash_profile</code> 或 <code>source $HOME/.zprofile</code> (zsh 則為 <code>source ~/.zprofile</code> 或 <code>source ~/.zshrc</code>) 來生效上方的環境變量設定</p><p>在終端機執行 <code>echo $ANDROID_HOME</code>，檢查環境變量是否已經正確配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $ANDROID_HOME</span><br></pre></td></tr></table></figure><p><img src="./rn-environment-android/android-env-variables.png" alt=""></p><blockquote><p>再次確認在 Android Studio menu 中的 <code>Preferences</code> → <code>Appearance &amp; Behavior</code> → <code>System Settings</code> → <code>Android SDK</code> 的路徑:</p></blockquote><p><img src="./rn-environment-android/android-env-2.png" alt=""></p><br/><p>終於!!! 經過這些繁瑣的設定之後，就可以建立 RN 專案並在 Android Studio 上運行了!!!(下集待續) 🎉🎉🎉</p><br/><h1 id="結語"><a class="header-anchor" href="#結語"></a>結語</h1><p>雖然 RN 建置開發環境的過程很枯燥乏味，但每個步驟都不能少，否則之後很容易出現各種奇怪的問題 🐛。</p><p>下一篇 <a href="https://yachen168.github.io/article/rn-hello-world.html#more">React Native 開發環境建置 - Android 篇(下)</a> 將繼續介紹如何在模擬器(Android Studio)和實體裝置中運行你的 RN 專案！</p><br/><br/><p><b>參考資源</b><br><a href="https://reactnative.dev/docs/environment-setup">RN Docs - Setting up the development environment<br></a></p>]]></content>
      
      
      <categories>
          
          <category> App </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 Composition API - Teleport 瞬移!</title>
      <link href="/article/composition-api-teleport.html"/>
      <url>/article/composition-api-teleport.html</url>
      
        <content type="html"><![CDATA[<p>Vue3 Composition API 新增了 Teleport 功能，讓我們可以輕鬆的將組件傳送到指定的地方，很酷的是，它還能夠保存狀態!</p><a id="more"></a><h2 id="為什麼需要-Teleport？"><a class="header-anchor" href="#為什麼需要-Teleport？"></a>為什麼需要 Teleport？</h2><p>最常見的情境是彈跳視窗，在開發時，我們會希望把彈跳視窗的開關邏輯封裝在 component 裡面，而不是裸露在頁面上。以程式碼來說，就是將控制開關的變數 <code>isModalOpen: false(true)</code> 設置在 component 裡。</p><p>一個極端的例子是：有 6 張 HTML 和 CSS 樣式皆相同的 Cards，但裡面的資料不同，點擊這 6 張 Cards，會分別跳出各自的彈跳視窗，而 6 個彈跳視窗的 HTML 和 CSS 樣式皆相同，但裡面的資料不同。</p><p>在這樣的情境下，應該沒有人想要在頁面上設定 6 個變數，分別控制這 6 個彈跳視窗吧!</p><p>較好的作法是將彈跳視窗開關的邏輯封裝在 Card component 中，然後在頁面上用 <code>v-for</code> 產生 6 張 Card，這時每張 Card 裡控制彈跳視窗開關的變數 <code>isModalOpen</code> 都是獨立的，不會互相干擾。</p><p>但是這樣的方式其實會有隱患，因為一般來說會將彈跳視窗用 <code>position: fixed</code> 固定在視窗(viewport)，在大多數情況下，彈跳視窗會如我們所願的針對視窗做定位，但仔細看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position">MDN</a> 上對於 <code>position: fixed</code> 的定義：</p><p><img src="./composition-api-teleport/position-fixed.png" alt=""><br>圖片來源: <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position">MDN-position</a></p><p>簡單來說，若彈跳視窗(position: fixed)的祖譜鏈中有一個祖先元素設定了 transform、perspective 或 filter 屬性時，那麼彈跳視窗將不再以視窗(viewport) 做定位，而是以該祖先元素做定位，那麼彈跳視窗就會壞掉！</p><p>有了 <code>Teleport</code>，就可以開閃現，讓彈跳視窗在 DOM tree 中瞬移到 body 節點(整個 &lt;app&gt; 外)的尾部，如此一來我們就可以安心的把開關的邏輯封裝在 Card 中，因為不管是 Card 或是 Card 外層元素使用了 transform、perspective 或 filter，都不再關彈跳視窗的事了，因為這時彈跳視窗的祖先元素就是 &lt;body&gt; → &lt;html&gt; → viewport。這樣還有另一個好處是，不用再微調 z-index 了，因為彈跳視窗被傳送到 &lt;app&gt; 後方(&lt;body&gt; 尾部)。</p><h2 id="Teleport-語法"><a class="header-anchor" href="#Teleport-語法"></a>Teleport 語法</h2><p>在 Vue 的 &lt;template&gt; 中可以直接使用 &lt;Teleport&gt;，無需特別引入。</p><p>&lt;Teleport&gt; 有兩個屬性：</p><ul><li>to: 用 query selector 指定要傳送到哪裡，也可以使用動態指定<code> :to</code>。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"#some-id"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">".some-class"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"body"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"[data-teleport]"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>disabled: 決定是不是要傳送出去。<ul><li>false: 傳出去(預設)。</li><li>true: 不要傳出去，將 &lt;Teleport&gt; 裡的東西留在原本的地方</li></ul></li></ul><br><h3 id="範例"><a class="header-anchor" href="#範例"></a>範例</h3><h4 id="使用-Teleport-前"><a class="header-anchor" href="#使用-Teleport-前"></a>使用 Teleport 前</h4><p>現在有 Card 與 Modal 組件，點擊 Card 裡面的按鈕，會打開彈跳視窗(Modal)，Modal 以 position: fixed 固定在視窗(viewport)。</p><p>在 Card 中引入 Modal 組件，並且把控制 Modal 開關的邏輯封裝在 Card 中。這時的畫面是可以正常運行的。</p><p><a href="https://stackblitz.com/edit/vue3-teleport?file=src%2Fcomponents%2FCard.vue">程式碼範例</a></p><p>在 Card.vue 中:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>這是 Card component<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"isModalOpen = true"</span>&gt;</span>確認送出訂單<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Modal</span> <span class="attr">v-if</span>=<span class="string">"isModalOpen"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Modal <span class="keyword">from</span> <span class="string">'./Modal.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Card'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Modal</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> isModalOpen = ref(<span class="literal">false</span>);  <span class="comment">// 控制 Modal 開關</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      isModalOpen</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span> <span class="selector-tag">scoped</span>&gt;</span><br><span class="line">  <span class="selector-class">.card</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在 Modal.vue 中:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-background"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal"</span>&gt;</span></span><br><span class="line">    OH! Modal 被打開了</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Modal'</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span> <span class="selector-tag">scoped</span>&gt;</span><br><span class="line">  <span class="selector-class">.modal-background</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>);</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.modal</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="./composition-api-teleport/without-teleport-normal.gif" alt=""></p><p>打開開發者工具檢視一下 DOM 結構，可以看到在尚未使用 &lt;Teleport&gt; 之前，Modal 是長在 Card 裡面。</p><p><img src="./composition-api-teleport/without-teleport-normal-dom.png" alt=""></p><p>如剛剛所說，這樣的問題是，只要上層元素中有一個設定了 transform、perspective 或 filter，那麼 Modal 將不再針對視窗做定位，且有時可能會需要微調 z-index。</p><p>證明方式很簡單，可以在 Card 的 style 中加入 <code>transform: translateY(20%)</code> 來做測試。<a href="https://stackblitz.com/edit/vue3-teleport?file=src%2Fcomponents%2FCard.vue">程式碼範例</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span> <span class="selector-tag">scoped</span>&gt;</span><br><span class="line">  <span class="selector-class">.card</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="comment">/* 在 Modal 的祖先元素 Card 中加上 transform */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">20%</span>);   </span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>會發現 Modal 壞掉了，因為這時 Modal 將以 Card 做定位，而非視窗。</p><p><img src="./composition-api-teleport/without-teleport-broken.gif" alt=""></p><h4 id="使用-Teleport-後"><a class="header-anchor" href="#使用-Teleport-後"></a>使用 Teleport 後</h4><p>現在使用 &lt;Teleport&gt;，將 Modal 瞬移到 body 節點的尾部。<a href="https://stackblitz.com/edit/vue3-teleport?file=src%2Fcomponents%2FCard.vue">程式碼範例</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>這是 Card component<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"isModalOpen = true"</span>&gt;</span>點我打開 Modal<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">--</span> 使用 <span class="attr">Teleport</span> 將 <span class="attr">Modal</span> 傳送到 <span class="attr">body</span> 尾部 <span class="attr">--</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Teleport</span> <span class="attr">to</span>=<span class="string">"body"</span> <span class="attr">v-if</span>=<span class="string">"isModalOpen"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Modal</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Teleport</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Modal <span class="keyword">from</span> <span class="string">'./Modal.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Card'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Modal</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> isModalOpen = ref(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      isModalOpen</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span> <span class="selector-tag">scoped</span>&gt;</span><br><span class="line">  <span class="selector-class">.card</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="comment">/* card 不再是 Modal 的祖先元素，所以再也無法影響 Modal */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">20%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>再次打開開發者工具檢視，可以看到 Modal 出現在 body 內的尾部(在 <app> 之後)，如此以來，即使在 Card 的 style 中設定了 transform、perspective 或 filter，Modal 皆不會受到影響，也不會有煩人的 z-index 問題。</p><p><img src="./composition-api-teleport/with-teleport-dom.png" alt=""></p><br><h2 id="Teleport-特性-保留狀態"><a class="header-anchor" href="#Teleport-特性-保留狀態"></a>Teleport 特性 - 保留狀態</h2><p><code>Teleport</code> 還有一個特別之處是：裡面的狀態會被保存，就像是 &lt;keep-alive&gt; 那樣，不會被 destroyed(或 unmounted)。</p><h3 id="範例-v2"><a class="header-anchor" href="#範例-v2"></a>範例</h3><p>利用 &lt;Teleport&gt; 的 <code>disabled</code> 屬性來證明：</p><p>首先讓 <code>isNumTeleport</code> 預設值為 <code>true</code>(表示 Teleport 內的東西不會被傳送出去)，當點擊按鈕時，就會 toggle <code>isNumTeleport</code> 變數，使 &lt;Teleport&gt; 內東西可以在 &lt;Card&gt; 與 &lt;body&gt; 之間來回穿梭。</p><p>而 &lt;Teleport&gt; 內為 <code>num</code>，每 1 秒會增加 1。</p><p><a href="https://stackblitz.com/edit/vue3-teleport-3bqzmz?file=src%2Fcomponents%2FCard.vue">範例程式碼</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>這是 Card component<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"toggleNumTeleport"</span>&gt;</span>傳送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    /* Teleport 狀態會像 keep-alive 那樣保留。 */</span><br><span class="line">    <span class="tag">&lt;<span class="name">Teleport</span> <span class="attr">to</span>=<span class="string">"body"</span> <span class="attr">:disabled</span>=<span class="string">"isNumTeleport"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>num: &#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Teleport</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Card'</span>,</span><br><span class="line">  setup()&#123;</span><br><span class="line">    <span class="keyword">const</span> num = ref(<span class="number">0</span>); </span><br><span class="line">    <span class="keyword">const</span> isNumTeleport = ref(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        num.value++;</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> toggleNumTeleport = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      isNumTeleport.value = !isNumTeleport.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      num,</span><br><span class="line">      isNumTeleport,</span><br><span class="line">      toggleNumTeleport</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span> <span class="selector-tag">scoped</span>&gt;</span><br><span class="line">  <span class="selector-class">.card</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">370px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>實現效果如下，可以清楚看到，無論怎麼切換，&lt;Teleport&gt; 裡面的狀態都會被保留(num 不會重頭計算)。</p><p><img src="./composition-api-teleport/teleport-keep-state.gif" alt=""></p><br><p>Facebook 和 Youtube 的縮小影片功能，感覺就很適合用 Teleport 實現呢XD<br><br></p><p><img src="./composition-api-teleport/case-fb.gif" alt=""></p><br><h2 id="結論"><a class="header-anchor" href="#結論"></a>結論</h2><p>使用 &lt;Teleport&gt; 將彈跳視窗傳送到 &lt;body&gt; 尾部(&lt;app&gt; 後方)的好處是可以避開 CSS 中 fixed 定位的雷，也不用再調 z-index 了，讓開發者可以安心地的把邏輯封裝在 component 裡面。</p><p>&lt;Teleport&gt; 除了瞬移之外，還有保留狀態的特性，所以總覺得 &lt;Teleport&gt; 還可以拿來應用在其它有趣的地方，但是暫時想不到其它案例哈，如果讀者有遇到其它適合使用 &lt;Teleport&gt; 的情境，歡迎留言告訴我XD</p><br><br><p><b>參考資料</b></p><ol><li><a href="https://v3.vuejs.org/guide/teleport.html#using-with-vue-components">Vue3 文件 - Teleport</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position">MDN - position</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
            <tag> composition API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>讓網頁平滑滾動!</title>
      <link href="/article/Smooth-Scrolling.html"/>
      <url>/article/Smooth-Scrolling.html</url>
      
        <content type="html"><![CDATA[<p>在網頁開發中，錨點算是個常見的需求，例如：在點擊按鈕後，畫面想要蝦趴的「滑」到頂部。</p><p>這種平滑的滾動效果，其實只要加一行 CSS 就可以辦得到，無需勞動到 JS，也就是今天要介紹的 <code>scroll-behavior</code> 屬性，直接進入實作吧!</p><a id="more"></a><h2 id="實作範例"><a class="header-anchor" href="#實作範例"></a>實作範例</h2><p><b>情境：</b><br>現在頁面上有很多區塊(達到可滾動的狀態)，而不管畫面在哪，只要<code>點擊右下角橘色按鈕，就要滑動到最上方</code>。<br><a href="https://codepen.io/yachen/pen/gOwzmVo?editors=1100">codepen 原始碼範例</a></p><p><img src="./Smooth-Scrolling/situation.png" alt=""></p><br><p>HTML 如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"top"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>1<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>2<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>3<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>4<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>5<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>6<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>7<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>8<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>9<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>10<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn-back"</span> <span class="attr">href</span>=<span class="string">"#top"</span>&gt;</span></span><br><span class="line">  ↑</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS 的部分，在 html 加上 <code>scroll-behavior: smooth</code> 即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">scroll-behavior</span>: smooth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>實際效果如下：</p><p><img src="./Smooth-Scrolling/result.gif" alt=""></p><br><p>最後，順帶看一下瀏覽器兼容性:</p><p><img src="./Smooth-Scrolling/browser-compatibility.png" alt=""><br>圖片來源: <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-behavior">MDN</a></p><br><p>結束XD</p><br><br/><br/><p><b>參考資源</b><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-behavior">MDN-scroll-behavior</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 閉包與範圍 ── Execution Context</title>
      <link href="/article/JavaScript%E9%96%89%E5%8C%85%E8%88%87%E7%AF%84%E5%9C%8Dexecution-context.html"/>
      <url>/article/JavaScript%E9%96%89%E5%8C%85%E8%88%87%E7%AF%84%E5%9C%8Dexecution-context.html</url>
      
        <content type="html"><![CDATA[<p>閉包(closure)在 JavaScript 中佔著重要的地位，但閉包本人其實不太好搞，先從與閉包密不可分的 ── 作用範圍(Scope)開始下手吧！這篇將從執行背景空間(execution context)開始介紹，一步步看 JavaScript 引擎是如何追蹤程式碼的執行，然後…等時機到了就會知道什麼是閉包了(吧)。</p><a id="more"></a><p>如果不相信閉包本人很難搞的話，可以打開 MDN，你會看到<strong>閉包的定義</strong>為：</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">英版 MDN</a>：</p><blockquote><p>A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.</p></blockquote><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Closures">中版 MDN</a>：</p><blockquote><p>閉包（Closure）是函式以及該函式被宣告時所在的作用域環境（lexical environment）的組合。</p></blockquote><br><img src="https://i.imgur.com/045RJSL.png" width="320px"><br><br><p>如果你看不懂 MDN 在說什麼，別鐵齒了~還是先繞過閉包本人吧！</p><br><h2 id="Execution-Context-執行背景空間"><a class="header-anchor" href="#Execution-Context-執行背景空間"></a>Execution Context (執行背景空間)</h2><p>由於 JavaScript 屬於單執行緒(Single Thread)，也就是它「<code>一次只能做一件事</code>」，所以當它要去執行另一件任務 B 時，就勢必得先暫停手上正在進行的任務 A，等待任務 B 執行完畢後，再回過頭繼續完成任務 A。若是在執行任務 B 時，又被叫去做任務 Ｃ，這時又得停下手邊的任務 B，先去執行完任務 C，接著回頭處理完任務 B，最後再回到任務 A。以此類推，因此所有一連串的任務都需要被追蹤。</p><p>每個任務都有一個<code>執行背景空間(execution context)</code>，JavaScript 引擎用 call stack 來追蹤它們。</p><p>在 JavaScript 中，有兩種執行背景空間(execution context)：</p><ol><li><strong>全域執行背景空間</strong></li></ol><blockquote><p>只有一個，且總是最早被建立的，負責處理全域中的程式碼。</p></blockquote><ol start="2"><li><strong>函式執行背景空間</strong></li></ol><blockquote><p>每<code>呼叫</code>函式一次，就會建立一個新的函式執行背景空間，負責處理函式中的程式碼。</p></blockquote><br><br><h2 id="call-stack-呼叫堆疊"><a class="header-anchor" href="#call-stack-呼叫堆疊"></a>call stack (呼叫堆疊)</h2><p>JavaScript 引擎利用<code>call stack(呼叫堆疊)</code>來追蹤所有任務，</p><p>現在用個例子來看看執行背景空間(execution context)究竟是如何堆疊(被追蹤)的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  b();    <span class="comment">// 呼叫函式 b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'函式 b 被執行了'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();    <span class="comment">// 第一次呼叫函式 a</span></span><br><span class="line">a();    <span class="comment">// 第二次呼叫函式 a</span></span><br></pre></td></tr></table></figure><br><p><img src="https://i.imgur.com/1aoMHGq.png" alt=""><br><img src="https://i.imgur.com/CTDEBoE.png" alt=""></p><ol><li><p>最先被創建的永遠是全域執行背景空間。<br><br></p></li><li><p>在全域下，定義了函式 a 與函式 b，接著<strong>呼叫了函式 a</strong> (第 9 行)，於是建立 a 函式執行背景空間，並堆放至 stack 中，由於 JavaScript 一次只能做一件事，所以此時全域執行背景空間會被暫停。<br><br></p></li><li><p>因在函式 a 中又<strong>呼叫了函式 b</strong>，於是建立 b 函式執行背景空間，並堆放至 stack 中，此時 a 函式執行背景空間會被暫停。<br><br></p></li><li><p>印出「函式 b 被執行了」後，b 函式執行完畢，於是 b 函式執行背景空間從 stack 中移出(pop)，回到了 a 函式執行背景空間繼續執行。<br><br></p></li><li><p>a 函式執行完畢(a 函式中也已經沒有其他程式碼需要被執行了)，a 函式執行背景空間從 stack 中移出，回到全域執行背景空間繼續執行。<br><br></p></li><li><p>在全域下，第 10 行中又再次<strong>呼叫函式 a</strong>，以上 2~5 的過程又重複一次。</p></li></ol><br><p>可以發現，stack 中的執行背景空間會「後進先出」，也就是較晚被堆疊進來的執行背景空間，會先被執行完然後 pop 出去。</p><p>我們也可以在瀏覽器的除錯工具中觀察 call stack 的變化，來驗證一下過程是不是如上述一樣。</p><p>首先在 VScode 中開啟 live server，接著打開開發者工具(按 F12)，點選 <code>Source</code>，然後選擇要觀察的 js 檔案。</p><p><img src="https://i.imgur.com/9QtZBy6.png" alt=""></p><br><p>點擊左邊的行數來下中斷點，一個紅點代表一個中斷點(範例中將中斷點下在第 9 行)。</p><p>然後重新整理一下頁面。</p><p>會發現在 call stack 欄位中，出現一個 (anonymous)，它就是全域執行背景空間(global execution context)。要注意的是，此時第 9 行的程式碼尚未被執行。</p><p><img src="https://i.imgur.com/Y4Lvx2w.png" alt=""></p><p>接著按下一步，開始執行第 9 行程式碼，也就是<strong>呼叫函式 a</strong>。<br>會發現 call stack 中被疊加了 a 函式執行背景空間。</p><p><img src="https://i.imgur.com/sJb1wuF.png" alt=""><br><img src="https://i.imgur.com/5EYxFyc.png" alt=""></p><p>接著繼續按下一步，執行函式 a 中的程式碼，也就是<strong>呼叫函式 b</strong>。會發現 call stack 中又被疊加了 b 函式執行背景空間，此時 a 函式執行背景空間被暫停。</p><p><img src="https://i.imgur.com/YpH3TcJ.png" alt=""></p><p>接著再按下一步，執行完函式 b 中的程式碼(console.log)，b 函式執行背景空間從 call stack 中彈出，恢復執行 a 函式執行背景空間。</p><p><img src="https://i.imgur.com/WpiFoKg.png" alt=""></p><p>接著繼續按下一步，因函式 a 中，在呼叫函式 b 之後，已經無其他程式碼需要被執行，所以函式 a 也執行完畢，a 函式執行背景空間彈出 call stack，恢復執行全域執行背景空間。</p><p><img src="https://i.imgur.com/MgZCMNx.png" alt=""></p><br><p>因全域執行背景空間中，第 10 行程式碼還沒被執行(再次呼叫函式 a)，所以繼續按下一步，會發現剛剛的過程又會重複一遍。</p><br><br><p>除了 call stack 之外， Web API、Task Queue、Event Loop 也扮演著重要的角色，推薦參考影片 <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway?</a>，該影片將 JS 引擎的運作流程解釋得非常淺顯易懂。</p><br><p>執行背景空間(execution context) 就簡單的介紹到此，在這篇文章中，瞭解到 JavaScript 引擎如何透過執行背景空間來追蹤程式碼的執行，下一篇將繼續介紹 JavaScript 如何透過字彙環境(lexical environment)來追蹤變數和函式的作用範圍。</p><br><br><br><br><p><b>參考資料</b></p><ol><li><a href="https://www.books.com.tw/products/0010773867">忍者：JavaScript開發技巧探秘第二版</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">MDN - closure</a></li><li><a href="https://www.youtube.com/watch?v=Bv_5Zv5c-Ts">JavaScript: Understanding the Weird Parts</a></li><li><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway?</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> w3HexSchool </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用純 CSS 做定格動畫</title>
      <link href="/article/%E7%94%A8%E7%B4%94CSS%E5%81%9A%E5%AE%9A%E6%A0%BC%E5%8B%95%E7%95%AB.html"/>
      <url>/article/%E7%94%A8%E7%B4%94CSS%E5%81%9A%E5%AE%9A%E6%A0%BC%E5%8B%95%E7%95%AB.html</url>
      
        <content type="html"><![CDATA[<p>什麼是定格動畫？簡單來說，是一種動畫技術，它的原理是將每幀不同的圖像快速播放，因人眼有視覺暫留，所以會產生動畫效果。小時候玩的手翻書就是以這樣的原理來達成動畫的效果！</p><a id="more"></a><br><h2 id="事前準備"><a class="header-anchor" href="#事前準備"></a>事前準備</h2><p>要用 CSS 完成定格動畫，首先需要有雪碧圖(Sprite)素材，當然，還需要會 CSS animation 的基本操作。</p><ul><li>雪碧圖(Sprite)</li><li>CSS animation</li></ul><br><h2 id="什麼是雪碧圖-Sprite"><a class="header-anchor" href="#什麼是雪碧圖-Sprite"></a>什麼是雪碧圖(Sprite)</h2><p>將多張圖像整合為單一圖像，然後利用定位的方式顯示各部分圖的技術，早期網頁常以這種方式來減少圖片加載的次數，以便提高網頁顯示速度。</p><br><h2 id="CSS-animation"><a class="header-anchor" href="#CSS-animation"></a>CSS animation</h2><p>在 CSS animation 包含了以下幾種屬性，其中，若要做定格動畫，<code>timing-function</code> 的設定為關鍵，需要將 timing-function 設定為 <code>steps</code>。</p><ul><li><p>動畫名稱 animation-name</p></li><li><p>持續時間 animation-duration</p></li><li><p><code>時間函數 animation-timing-function</code></p><ul><li>ease (預設值)</li><li>ease-in</li><li>ease-in-out</li><li>ease-out</li><li>linear</li><li><code>steps(n, step position)</code></li></ul></li><li><p>延遲時間 animation-delay</p></li><li><p>播放次數 animation-iteration-count</p></li><li><p>播放方向 animation-direction</p></li><li><p>前後狀態 animation-fill-mode</p></li><li><p>運行停止 animation-play-state</p></li></ul><br><h3 id="steps-n-step-position"><a class="header-anchor" href="#steps-n-step-position"></a>steps(n, step position)</h3><p>steps 第一個參數 n 為一正整數，至於第二個參數 step position，這裡僅介紹 <code>start</code> 與 <code>end(預設值)</code> 兩個值。</p><ul><li><p><strong>n</strong>： 正整數</p></li><li><p><strong>step position</strong></p><ul><li>start：動畫一開始就跳一階</li><li><code>end (預設值)</code><br><br></li></ul></li></ul><p>與<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/timing-function">其他多數 timing-function</a> 不一樣的是，<code>step</code> 像是階梯(step) 一樣，一階一階，而非完全連續型函數。</p><p>下圖左方為 <code>start</code> 的 timing-function，右方為 <code>end</code> 的 timing-function，若看不懂 timing-function 其實也沒關係，會用就好XD</p><p><img src="https://i.imgur.com/REHYirr.png" alt=""></p><p><img src="https://i.imgur.com/pi70fox.png" alt=""></p><br><br><p>用一個簡單的小範例可看出 <code>start</code> 與 <code>end</code> 的差異。<br>若要做定格動畫，我們需要利用 <code>end</code> 的特性。</p><iframe height="439" style="width: 100%;" scrolling="no" title="PowbBxq" src="https://codepen.io/yachen/embed/PowbBxq?height=439&theme-id=default&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/yachen/pen/PowbBxq'>PowbBxq</a> by yachen  (<a href='https://codepen.io/yachen'>@yachen</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><br><br><h3 id="開始做定格動畫"><a class="header-anchor" href="#開始做定格動畫"></a>開始做定格動畫</h3><p>有了一些預備知識之後，就可以來動手做定格動畫了！只要依照以下 3 個步驟就可以完成。</p><br><h4 id="step1"><a class="header-anchor" href="#step1"></a>step1</h4><blockquote><p>確認雪碧圖有幾幀 ⇒ 決定 steps(n) 中的 n，完整寫法為 steps(n, end)，可省略 end 不寫(因為是預設值)。</p></blockquote><p>例如：<br>下方雪碧圖有 8 幀 ⇒ steps(8)。</p><p><img src="https://i.imgur.com/wiVwOhb.png=80%25" alt=""></p><br><h4 id="step2"><a class="header-anchor" href="#step2"></a>step2</h4><blockquote><p>確認雪碧圖的總寬度(或總高度) ⇒ 決定總共要移動多少距離。</p></blockquote><p>例如：下方雪碧圖的總寬度為 2880px ⇒ 圖片將移動(translateX) 2880px。</p><p><img src="https://i.imgur.com/vRkxFb8.png" alt=""></p><br><h4 id="step3"><a class="header-anchor" href="#step3"></a>step3</h4><blockquote><p>計算每一幀的寬度或高度 ⇒ 決定容器元素的寬度或高度。</p></blockquote><p>每一幀的寬度 ＝ 總寬度 / 幀數</p><p>所以每一幀的寬度為 2280px / 8，等於 360px  ⇒ 將容器元素寬度設定為 360px</p><br><h4 id="實現結果"><a class="header-anchor" href="#實現結果"></a>實現結果</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 雪碧圖(總寬度 2880px，共 8 幀)--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://i.imgur.com/5aXROc2.png"</span> <span class="attr">alt</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  width: 360px;    // 總寬度 2880px / 8幀</span><br><span class="line">  <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line">  <span class="selector-tag">animation</span>: <span class="selector-tag">moveContainer</span> 5<span class="selector-tag">s</span> <span class="selector-tag">infinite</span> <span class="selector-tag">linear</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  animation: run 0.5s infinite steps(8);  // 8 幀</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> run &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">      transform: translateX(-2880px);    // 總寬度 2880px</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移動 container，製造「向前跑」效果</span><br><span class="line"><span class="keyword">@keyframes</span> moveContainer &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">1600px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe height="631" style="width: 100%;" scrolling="no" title="jOEMBzQ" src="https://codepen.io/yachen/embed/jOEMBzQ?height=631&theme-id=default&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/yachen/pen/jOEMBzQ'>jOEMBzQ</a> by yachen  (<a href='https://codepen.io/yachen'>@yachen</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><br><br><br><br><p>可以在網路上找自己喜歡的雪碧圖素材，運用相同的原理，做出各種有趣的定格動畫。</p><iframe height="572" style="width: 100%;" scrolling="no" title="YzPGNaK" src="https://codepen.io/yachen/embed/YzPGNaK?height=572&theme-id=default&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/yachen/pen/YzPGNaK'>YzPGNaK</a> by yachen  (<a href='https://codepen.io/yachen'>@yachen</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><br><br><iframe height="640" style="width: 100%;" scrolling="no" title="VwYmVYd" src="https://codepen.io/yachen/embed/VwYmVYd?height=640&theme-id=light&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/yachen/pen/VwYmVYd'>VwYmVYd</a> by yachen  (<a href='https://codepen.io/yachen'>@yachen</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><br><br><br><br><br><br><br><br><p>參考資源：<br><a href="https://www.w3.org/TR/css-easing-1/#step-position">CSS Easing Functions Level 1</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/timing-function">MDN-timing-function</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> w3HexSchool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解決 Vue.js-devtools 無法開啟問題</title>
      <link href="/article/vue-devtools%E7%84%A1%E6%B3%95%E9%96%8B%E5%95%9F.html"/>
      <url>/article/vue-devtools%E7%84%A1%E6%B3%95%E9%96%8B%E5%95%9F.html</url>
      
        <content type="html"><![CDATA[<p>相信用過 Vue.js 的應該都有裝 Vue.js-devtools (吧)。</p><p>最近發現若是單純以引入 <code>CDN</code> 的方式使用 Vue，而非用 <a href="https://cli.vuejs.org/zh/">Vue CLI</a>，會出現 <a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd">Vue.js-devtools</a> 無法正常開啟的情況。</p><a id="more"></a><p><img src="./vue-devtools%E7%84%A1%E6%B3%95%E9%96%8B%E5%95%9F/devtools.png" alt=""></p><br><p>查了一下文件，原因是：<br><img src="https://i.imgur.com/NY3MZWM.png" alt=""></p><br><p>總之，<strong>解決辦法</strong>是需要手動進行設定，需要在 js 檔案中添加以下程式碼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.devtools = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><br><p>像這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.devtools = <span class="literal">true</span>;   <span class="comment">// 手動添加這行程式碼</span></span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;li&gt;...&lt;/li&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(...)</span><br></pre></td></tr></table></figure><br><p>然後重新開啟 live server，就可以看到 <code>Vue.js-devtools</code> 正常運作囉！</p><p><img src="./vue-devtools%E7%84%A1%E6%B3%95%E9%96%8B%E5%95%9F/success.png" alt=""><br><img src="./vue-devtools%E7%84%A1%E6%B3%95%E9%96%8B%E5%95%9F/success-open.png" alt=""></p><br><br><br><br><br><p><strong>參考資料</strong> <br><br><a href="https://cn.vuejs.org/v2/api/#devtools">Vue 官方文件</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三種改變函式內部 this 的方式：apply()、call()、bind()</title>
      <link href="/article/%E6%94%B9%E8%AE%8A%E5%87%BD%E5%BC%8F%E7%9A%84this.html"/>
      <url>/article/%E6%94%B9%E8%AE%8A%E5%87%BD%E5%BC%8F%E7%9A%84this.html</url>
      
        <content type="html"><![CDATA[<p>在 JavaScript 中，改變函數內部 this 的指向常見的方式有 <code>call()</code>、<code>apply()</code>、<code>bind()</code>，而這三種方式又存在些微差異。</p><a id="more"></a><br><h2 id="call"><a class="header-anchor" href="#call"></a>call()</h2><p><code>call()</code> 方法會<code>呼叫(執行)一個函數</code>，且可以同時改變函數內部的 <code>this</code> 指向。</p><p>語法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg ,arg1, arg2, ...);</span><br></pre></td></tr></table></figure><p>參數說明：</p><ul><li><strong>thisArg</strong>：在函式運行時的 <code>this</code> 指向，若省略則僅執行函式而不改變 <code>this</code> 指向。</li><li><strong>arg1, arg2, …</strong>：傳遞的參數(可省略)。<br><br></li></ul><p>例如：</p><p>在非嚴格模式下，函式 foo 中的 <code>this</code> 指向的原本是 <code>window</code>，因在此例子中，<code>foo</code> 其實是屬於 <code>window</code> 物件的一個方法。(若在嚴格模式下，則為 <code>undefined</code>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'yachen'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">foo();  <span class="comment">// window，其實這裡的 foo() 是 window.foo()</span></span><br></pre></td></tr></table></figure><br><p>剛提到，<code>call()</code> 會呼叫(執行)函式，但若無給第一個參數，則僅會呼叫函式而不會改變 <code>this</code> 指向，所以除了用 <code>foo()</code> 執行 <code>foo</code> 函式之外，也可以透過 <code>call()</code> 來呼叫(當然不需要多此一舉)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.call();  <span class="comment">// window</span></span><br></pre></td></tr></table></figure><br><p>現在除了呼叫 foo 函式，同時想要將函式 foo 裡的 <code>this 指向改為 obj</code>，可以使用 <code>call()</code> 來達成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.call(obj);  <span class="comment">// obj</span></span><br></pre></td></tr></table></figure><br><p>還可以傳遞一些參數。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'yachen'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">foo.call(obj, <span class="number">1</span>, <span class="number">2</span>);     </span><br><span class="line"><span class="comment">// obj </span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><br><h3 id="實現繼承"><a class="header-anchor" href="#實現繼承"></a>實現繼承</h3><p><strong><code>call()</code> 也可以用來實現繼承。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old`</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Taiwanese</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// this 指向 me</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> Taiwanese(<span class="string">'yachen'</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">me.say();  <span class="comment">//  "yachen is 18 years old"</span></span><br></pre></td></tr></table></figure><br><br><h2 id="apply"><a class="header-anchor" href="#apply"></a>apply()</h2><p>使用 <code>apply()</code> 會呼叫一個函數，同時可以改變函數內部 <code>this</code> 指向，<code>apply()</code> 與 <code>call()</code> 幾乎一樣，最大的不同是 <code>call()</code> 接受一連串的參數，而 <code>apply()</code> 接受一組陣列(或類陣列)形式的參數。</p><br><p>語法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.apply(thisArg, [argsArray]);</span><br></pre></td></tr></table></figure><p>參數說明：</p><ul><li><strong>thisArg</strong>：在函式運行時的 <code>this</code> 指向。</li><li><strong>[argsArray]</strong>：傳遞的參數必須為<mark>陣列或類陣列</mark>(可省略)。</li></ul><br><br><h2 id="bind"><a class="header-anchor" href="#bind"></a>bind()</h2><p><code>bind()</code> 能改變 <code>this</code> 指向，但<code>不會呼叫</code>(執行)函數，會 copy 並返回一個新的函數。</p><br><p>語法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.bind(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><p>參數說明：</p><ul><li><strong>thisArg</strong>：在 fun 函數運行時指定的 <code>this</code> 值。</li><li><strong>arg1, arg2, …</strong>：傳遞其他參數(可省略)。</li></ul><br><p>例如：</p><p>使用 <code>bind()</code> 將函式 foo 裡的 <code>this</code> 指向改為 <code>obj</code>，同時傳遞 <code>1</code> 和 <code>2</code> 兩個引數，有別於 <code>call()</code> 與 <code>apply()</code>，<code>bind()</code> 並不會呼叫執行 <code>foo</code> 函式，僅會返回一個新的函式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'yachen'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bind(obj, <span class="number">1</span>, <span class="number">2</span>);   <span class="comment">// 並未執行，而使返回一個新的函式</span></span><br></pre></td></tr></table></figure><br><p>因 <code>bind()</code> 並不會呼叫執行 foo 函式，而是返回一個新的函式，若想要同時執行 <code>foo</code>，則需手動加上 ()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.bind(obj, <span class="number">1</span>, <span class="number">2</span>)();  </span><br><span class="line"><span class="comment">// obj</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><br><p>現在來看看返回的新函式長什麼樣子，可以打開瀏覽器，並輸入以下代碼。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'yachen'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newFoo = foo.bind(obj, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 並未執行，而使返回一個新的函式</span></span><br><span class="line"><span class="built_in">console</span>.log(newFoo);</span><br></pre></td></tr></table></figure><p>印出 <code>newFoo</code>：</p><p><img src="https://i.imgur.com/cOC7AnG.png" alt=""></p><br><p>咦？ <code>newFoo</code> 不就是 <code>foo</code> 嗎？</p><p>再試著輸入以下代碼，事實證明 <code>newFoo</code> 不等於 <code>foo</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(newFoo === foo);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><br><br><p>在開發中，最常使用的應該是 <code>bind()</code>，因為很多情況下我們只是想改變 <code>this</code>，不想同時執行函數。</p><p>例如現在有一個按鈕，想要在用戶點擊後，禁用此按鈕 3 秒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;按鈕&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><br><p>若直接在定時器裡使用匿名 <code>function(){}</code> 形式的 callback，定時器裡的 <code>this</code> 指向的是 <code>window</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, eventHandler);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// this 指向按鈕 btn</span></span><br><span class="line">    <span class="keyword">this</span>.disabled = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// this 指向 window</span></span><br><span class="line">        <span class="keyword">this</span>.disabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>這時候 <code>bind()</code> 就可以派上用場了，因為不想要在改變 <code>this</code> 的同時執行 <code>this.disabled = false</code>，而是希望透過定時器 3 秒後執行，此時就不適用 <code>call()</code> 與 <code>apply()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, eventHandler);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// this 指向按鈕 btn</span></span><br><span class="line">    <span class="keyword">this</span>.disabled = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.disabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>),<span class="number">3000</span>)  <span class="comment">// this 改指向按鈕 btn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>當然，也可以直接將定時器裡的 callback function 改成<code>箭頭函式(arrow function)</code>的形式來解決。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, eventHandler);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.disabled = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改為箭頭函式</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// this 指向 btn</span></span><br><span class="line">        <span class="keyword">this</span>.disabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2><p><code>call()</code>、<code>apply()</code>、<code>bind()</code> 皆可以改變函數內部的 <code>this</code> ，三者的差異在於：</p><table><thead><tr><th></th><th style="text-align:center">自動呼叫函數</th><th style="text-align:center">參數(可省略)</th></tr></thead><tbody><tr><td>call()</td><td style="text-align:center">⭕️</td><td style="text-align:center">arg1, arg2, …</td></tr><tr><td>apply()</td><td style="text-align:center">⭕️</td><td style="text-align:center">[arg1, arg2, …]</td></tr><tr><td>bind()</td><td style="text-align:center">❌</td><td style="text-align:center">arg1, arg2, …</td></tr></tbody></table><br><br><br><br><br><p>參考資料：</p><ol><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/call">MDN - Function.prototype.call</a></li><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">MDN - Function.prototype.apply()</a></li><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN - Function.prototype.bind()</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout">MDN - setTimeout</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> w3HexSchool </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 原理 - Flex(下)</title>
      <link href="/article/Flex3.html"/>
      <url>/article/Flex3.html</url>
      
        <content type="html"><![CDATA[<p>vertical-align、text-align 甚至 float 都是控制不了 flex items 的，flex 有自己專屬的對齊屬性，而因對齊分為水平對齊與垂直對齊，所以首先要先認清楚誰是主軸(main axis)誰是副軸(cross axis)，才不會精神分裂。</p><a id="more"></a><br><p>先稍微複習一下，主軸(main axis)與副軸(cross axis)的方向取決於 flex direction 屬性與書寫模式 writing-mode，可參考先前文章 <a href="https://yachen168.github.io/article/Flex.html#more">CSS 原理 - Flex(上)</a>。</p><p><img src="https://i.imgur.com/3ow0Yie.png" alt=""></p><p><img src="https://i.imgur.com/EkZ9GhU.png" alt=""></p><br><h2 id="flex-的對齊"><a class="header-anchor" href="#flex-的對齊"></a>flex 的對齊</h2><p>要小心的是，有些屬性是適用於 flex container，有些屬性則適用於 flex items，用錯地方是沒反應的唷。</p><p><strong>適用於 flex container 的對齊屬性</strong></p><ul><li>justify-content</li><li>align-items</li><li>align-content</li></ul><p><strong>適用於 flex items 的對齊屬性</strong></p><ul><li>align-self</li></ul><br><h3 id="justify-content-屬性"><a class="header-anchor" href="#justify-content-屬性"></a>justify-content 屬性</h3><p>控制 <code>flex items</code> 在<code>主軸(main axis)</code>方向的對齊方式，僅<code>適用於 flex container</code>。以下為幾個常用且瀏覽器支援度較高的屬性值：</p><h4 id="•-flex-start"><a class="header-anchor" href="#•-flex-start"></a>• flex-start</h4><p>為預設值，flex items 由<code>主軸</code>的<code>始端</code>開始排列。<br><br></p><h4 id="•-flex-end"><a class="header-anchor" href="#•-flex-end"></a>• flex-end</h4><p>flex items 由<code>主軸</code>的<code>末端</code>開始排列。<br><br></p><h4 id="•-center"><a class="header-anchor" href="#•-center"></a>• center</h4><p>flex items <code>置中</code>於<code>主軸</code>。<br><br></p><h4 id="•-space-between"><a class="header-anchor" href="#•-space-between"></a>• space-between</h4><p><code>第一個</code> flex item 對齊<code>主軸</code>的<code>始端</code>，<code>最後一個</code> flex item 對齊<code>主軸</code>的<code>末端</code>，其餘空間<code>平均</code>分佈於 flex items 之間。<br><br></p><h4 id="•-space-around"><a class="header-anchor" href="#•-space-around"></a>• space-around</h4><p>以 flex-direction: row 來看，每個 flex item 左右像自備 x 空間，第一個與最後一個 flex item 與 container 的之間有 <code>x</code> 空間，而 flex items 兩兩之間有 <code>2x</code> 空間。<br><br></p><h4 id="•-pace-evenly"><a class="header-anchor" href="#•-pace-evenly"></a>• pace-evenly</h4><p>以 flex-direction: row 來看，每個 flex item 左右各有 <code>x</code> 空間，第一個與最後一個 flex item 與 container 的之間的空間亦為 <code>x</code>。</p><br><h4 id="圖形輔助"><a class="header-anchor" href="#圖形輔助"></a>圖形輔助</h4><p>用圖形非常好理解，在水平且由左至右的書寫模式下，若<code>主軸</code>為 <code>row</code> (flex-direction：row)，使用此六種屬性值會呈現下圖中的結果。</p><p><img src="https://i.imgur.com/7p2W0W4.png" alt=""><br><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">圖片來源：CSS TRICKS</a></p><br><h3 id="align-items-屬性"><a class="header-anchor" href="#align-items-屬性"></a>align-items 屬性</h3><p>控制 <code>flex items</code> 在<code>副軸(cross axis)</code>方向上的對齊方式，僅<code>適用於 flex container</code>。以下為幾個常用且瀏覽器支援度較高的值。</p><h4 id="•-flex-start-v2"><a class="header-anchor" href="#•-flex-start-v2"></a>• flex-start</h4><p>flex items 由<code>副軸</code>的<code>始端</code>開始排列。<br><br></p><h4 id="•-flex-end-v2"><a class="header-anchor" href="#•-flex-end-v2"></a>• flex-end</h4><p>flex items 由<code>副軸</code>的<code>末端</code>開始排列。<br><br></p><h4 id="•-center-v2"><a class="header-anchor" href="#•-center-v2"></a>• center</h4><p>flex items <code>置中</code>於<code>副軸</code>。<br><br></p><h4 id="•-stretch"><a class="header-anchor" href="#•-stretch"></a>• stretch</h4><p>為<code>預設值</code>，這也是為什麼 flex item 在<code>預設</code>下會<code>撐滿</code>容器在<code>副軸</code>上的空間。<br><br></p><h4 id="•-baseline"><a class="header-anchor" href="#•-baseline"></a>• baseline</h4><p>flex items 依照 <code>baseline</code> 對齊。</p><br><h4 id="圖形輔助-v2"><a class="header-anchor" href="#圖形輔助-v2"></a>圖形輔助</h4><p>在水平且由左至右的書寫模式下，若<code>副軸</code>為 <code>column</code> (flex-direction：row)，使用此五種屬性值會呈現下圖中的結果。</p><p><img src="https://i.imgur.com/sx5hce7.png" alt=""><br><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">圖片來源：CSS TRICKS</a></p><br><h3 id="align-content-屬性"><a class="header-anchor" href="#align-content-屬性"></a>align-content 屬性</h3><p>控制「<code>多行(multi-line)主軸</code>」在<code>副軸</code>上的對齊方式，也就是前提為 flex container 的 <code>flex-wrap</code> 屬性值須為 <code>wrap</code> 或 <code>wrap-reverse</code>，而非預設的 flex-wrap: nowrap。僅適用於 flex container。</p><p>以下圖形範例以主軸(main axis)為 row(橫向)，副軸(cross axis)為 column(縱向)來說，即 flex-direction: row 下：</p><p><img src="https://i.imgur.com/3ow0Yie.png" alt=""></p><br><h4 id="•-flex-start-v3"><a class="header-anchor" href="#•-flex-start-v3"></a>• flex-start</h4><p>「多行(multi-line)主軸」對齊<code>副軸</code>的<code>始端</code>。<br><img src="https://i.imgur.com/srlWDT2.png" alt=""></p><br><h4 id="•-flex-end-v3"><a class="header-anchor" href="#•-flex-end-v3"></a>• flex-end</h4><p>「多行(multi-line)主軸」對齊<code>副軸</code>的<code>末端</code>。</p><p><img src="https://i.imgur.com/sFvkK2O.png" alt=""></p><br><h4 id="•-center-v3"><a class="header-anchor" href="#•-center-v3"></a>• center</h4><p>「多行(multi-line)主軸」<code>置中</code>於<code>副軸</code>。</p><p><img src="https://i.imgur.com/4zVdwuE.png" alt=""></p><br><h4 id="•-space-between-v2"><a class="header-anchor" href="#•-space-between-v2"></a>• space-between</h4><p><code>第一個</code>與<code>最後一個</code> line 對齊<code>副軸</code>的<code>始端</code>與<code>末端</code>，其餘空間<code>平均</code>分佈於 flex items 之間。</p><p><img src="https://i.imgur.com/scRqyPx.png" alt=""></p><br><h4 id="•-stretch-v2"><a class="header-anchor" href="#•-stretch-v2"></a>• stretch</h4><p><code>延伸撐滿副軸</code>。</p><p><img src="https://i.imgur.com/i3vPqQ9.png" alt=""></p><br><h4 id="•-space-around-v2"><a class="header-anchor" href="#•-space-around-v2"></a>• space-around</h4><p>每個 line 兩旁像自備 x 空間，第一個與最後一個 line 與 container 的之間有 <code>x</code> 空間，而 lines 兩兩之間有 <code>2x</code> 空間。</p><p><img src="https://i.imgur.com/k5GAD3M.png" alt=""></p><br><h4 id="•-space-evenly"><a class="header-anchor" href="#•-space-evenly"></a>• space-evenly</h4><p>每個 line 左右各有 <code>x</code> 空間，第一個與最後一個 line 與 container 的之間的空間亦為 <code>x</code>。</p><p><img src="https://i.imgur.com/GRJBloJ.png" alt=""></p><br><br><h3 id="align-self-屬性"><a class="header-anchor" href="#align-self-屬性"></a>align-self 屬性</h3><p>也可以單獨控制<code>個別</code> <code>flex item</code> 在副軸上的對齊方式。僅適用於 flex items。</p><p>以主軸(main axis)為 row(橫向)，副軸(cross axis)為 column(縱向)來說，即 flex-direction: row 下：</p><p><img src="https://i.imgur.com/3ow0Yie.png" alt=""></p><br><h4 id="•-flex-start-v4"><a class="header-anchor" href="#•-flex-start-v4"></a>• flex-start</h4><p>flex item 由<code>副軸</code>的<code>始端</code>開始排列。<br><img src="https://i.imgur.com/QCt1SRV.png" alt=""></p><br><h4 id="•-flex-end-v4"><a class="header-anchor" href="#•-flex-end-v4"></a>• flex-end</h4><p>flex item 由<code>副軸</code>的<code>末端</code>開始排列。<br><img src="https://i.imgur.com/0u8vWak.png" alt=""><br><br></p><h4 id="•-center-v4"><a class="header-anchor" href="#•-center-v4"></a>• center</h4><p>flex item <code>置中</code>於<code>副軸</code>。<br><img src="https://i.imgur.com/JGqJAn0.png" alt=""></p><br><h4 id="•-stretch-v3"><a class="header-anchor" href="#•-stretch-v3"></a>• stretch</h4><p>flex item 撐滿<code>副軸</code>。<br><img src="https://i.imgur.com/S5WlRPy.png" alt=""></p><br><h4 id="•-baseline-v2"><a class="header-anchor" href="#•-baseline-v2"></a>• baseline</h4><p>flex item 對齊 <code>baseline</code>。</p><br><br><br><br><h3 id="總整理"><a class="header-anchor" href="#總整理"></a>總整理</h3><ul><li><p><strong>適用於 flex container</strong></p><ul><li>justify-content<br>控制<code>主軸</code>上所有 flex items 的對齊。</li><li>align-items<br>控制<code>副軸</code>上所有 flex items 的對齊。</li><li>align-content<br>控制「多行(multi-line)主軸」在<code>副軸</code>上的對齊方式。<br><br></li></ul></li><li><p><strong>適用於 flex items</strong></p><ul><li>align-self<br>控制<code>副軸</code>上個別 flex item 的對齊。</li></ul></li></ul><br><br><br><br><br><p><b>參考資料</b></p><ol><li><a href="https://www.w3.org/TR/css-flexbox-1/#justify-content-property">W3C - Flexible Box Layout Module Level 1</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Aligning_Items_in_a_Flex_Container">MDN - Aligning Items in a Flex Container</a></li><li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">CSS TRICKS - A Complete Guide to Flexbox</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 原理 - Flex(中)</title>
      <link href="/article/Flex2.html"/>
      <url>/article/Flex2.html</url>
      
        <content type="html"><![CDATA[<p>這篇將介紹 flex 屬性，並且深入探討 flex 究竟是如何計算伸縮的比例。</p><a id="more"></a><br><h2 id="名詞介紹"><a class="header-anchor" href="#名詞介紹"></a>名詞介紹</h2><p>若要理解 flex 是如何計算伸縮比例，首先需要了解一下 positive free space 與 negative free space 這兩個名詞。</p><h3 id="positive-free-space"><a class="header-anchor" href="#positive-free-space"></a>positive free space</h3><p>若 <code>flex items</code> 在<code>主軸(main axis)</code>方向上的尺寸總和<code>小於</code> <code>flex container</code> 的尺寸，此時會出現 flex container 的空間沒有被填滿，這些剩餘空間就稱為 <code>positive free space</code>。</p><p>例如，在主軸(main axis)為 row 下，若 flex container 的寬度為 500px，而 a、b、c 三個 flex items 寬度各為 100px，此時 flex container 還有 200px 的 positive free space。</p><br><p><img src="https://i.imgur.com/lNhLpcs.png" alt=""><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Controlling_Ratios_of_Flex_Items_Along_the_Main_Ax">圖片來源 MDN</a></p><br><h3 id="negative-free-space"><a class="header-anchor" href="#negative-free-space"></a>negative free space</h3><p>若 <code>flex items</code> 在<code>主軸(main axis)</code>方向上的尺寸總和<code>大於</code> <code>flex container</code> 的尺寸，此時 flex container 的空間不夠用，而 flex items 的尺寸總和與 flex container 尺寸的<code>差額</code>就稱為 <code>negative free space</code>。</p><p>例如，在主軸(main axis)為 row 下，若 flex container 的寬度為 500px，而 a、b、c 三個 flex items 寬度各為 200px，此時 flex container 的寬度 500px 小於 flex items 的寬度總和 600px，negative free space 為 600px 減 500px，等於 100px。</p><br><p><img src="https://i.imgur.com/OugSaLG.png" alt=""><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Controlling_Ratios_of_Flex_Items_Along_the_Main_Ax">圖片來源 MDN</a></p><br><h2 id="flex-屬性"><a class="header-anchor" href="#flex-屬性"></a>flex 屬性</h2><p><img src="https://i.imgur.com/MkKEK9o.png" alt=""><br>圖片來源：<a href="https://www.w3.org/TR/css-flexbox-1/#flex-property">W3C</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: <span class="selector-tag">flex-grow</span> ｜ <span class="selector-tag">flex-shrink</span> ｜ <span class="selector-tag">flex-basis</span>;</span><br></pre></td></tr></table></figure><ul><li><p>為三個屬性 <code>flex-grow</code>、<code>flex-shrink</code> 與 <code>flex-basis</code> 的縮寫。</p><ul><li>flex-grow: 決定 <code>flex item</code> 將<code>得到</code>多少<code>比例</code>的 <code>positive free space</code>。</li><li>flex-shrink: 決定 <code>flex item</code> 將<code>得到</code>多少<code>比例</code>的 <code>negative free space</code>。</li><li>flex-basis: 決定 <code>flex item</code> 在尚未 grow 與 shrink 前的<code>原始尺寸</code>。</li></ul></li><li><p>預設值為 <code>flex: 0 1 auto</code></p></li></ul><br><h3 id="flex-grow"><a class="header-anchor" href="#flex-grow"></a>flex-grow</h3><ul><li>以 <code>flex-basis</code> 為基礎，決定 <code>positive free space</code> 的<code>分配比例</code>，所以有 positive free space 才有作用。<ul><li>必須為 <code>≥ 0</code> 的值。</li><li>若為 <code>0</code> (<code>預設值</code>)，則<code>不會延伸</code>。</li></ul></li></ul><h4 id="計算方式"><a class="header-anchor" href="#計算方式"></a>計算方式</h4><p>在 flex-direction: row 下，有一個寬度為 500px 的 flex container，與三個寬度各為 100px、80px、70px 的 flex items，則在預設下會有 500px - 250px = 250px 的 positive free space 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item2"</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">3px</span> solid <span class="number">#444</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">120px</span>;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">1</span> auto;    <span class="comment">/* 此為預設值 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">1</span> auto;    <span class="comment">/* 此為預設值 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">1</span> auto;    <span class="comment">/* 此為預設值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/UyGZoAz.png" alt=""></p><br><p>現在將三個 flex items 的 <code>flex-grow</code> 分別設定為 <code>1</code>、<code>2</code>、<code>2</code>。</p><ul><li>item1 將分配到 1/(1+2+2) = <code>1/5</code> 的 positive free space。最終寬度為 150px。</li><li>item2 將分配到 2/(1+2+2) = <code>2/5</code> 的 positive free space。最終寬度為 180px。</li><li>item3 將分配到 2/(1+2+2) = <code>2/5</code> 的 positive free space。最終寬度為 170px。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto; <span class="comment">/* 將 flex-grow 改為 1，將佔 1/5 等分 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">1</span> auto; <span class="comment">/* 將 flex-grow 改為 2，將佔 2/5 等分 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">1</span> auto;  <span class="comment">/* 將 flex-grow 改為 2，將佔 2/5 等分 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/xOlD3h8.gif" alt=""><br><br></p><h3 id="flex-shrink"><a class="header-anchor" href="#flex-shrink"></a>flex-shrink</h3><ul><li><p>以 <code>flex-basis</code> 為基礎，決定 <code>negative free space</code> 的<code>分配比例</code>，所以有 negative free space 才有作用。</p><ul><li>必須為 <code>≥ 0</code> 的值。</li><li>若為 <code>0</code>，則<code>不會</code>收縮，此時若 container 空間不夠，會發生 <code>overflow</code>。</li><li><code>預設值</code>為 <code>1</code>。</li></ul></li><li><p>flex items <code>不會</code>縮短至<code>小於</code> <code>min-content</code> 的尺寸，除非設定 min-width 或 min-height 屬性。</p></li></ul><br><h4 id="計算方式-v2"><a class="header-anchor" href="#計算方式-v2"></a>計算方式</h4><p>flex container 寬度為 500px，其三個 flex items 寬度各為 200px，故此時有 100px 的 negative free space，若將所有 flex items 的 flex-shrink 皆設定為 0，則將發生 overflow。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item2"</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123; </span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">outline</span>: <span class="number">3px</span> solid <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &gt; * &#123;      </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;       <span class="comment">/* 所有 flex items 寬度皆為 200px */</span> </span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> auto;     <span class="comment">/* 將所有的 flex-shrink 設定為 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/QmDyzSx.png" alt=""></p><br><p>現在將第一個與第二個 flex item 的 <code>flex-shrink</code> 分別設定為 <code>1</code> 與 <code>4</code>，第三個 flex item 的 flex-shrink 依然為 <code>0</code>。</p><p><b>注意，shrink 與 grow 的計算方法並不相同，公式可參考 <a href="https://ithelp.ithome.com.tw/articles/10194694">前端新手村 flex grow &amp; shrink 演算法</a>。</b></p><p>negative free space = 500px - 200 *3 = -100px</p><ul><li><p>item 1 將分配到 <code>1/5</code> 的 negative free space，所以最後寬度為 180px。</p><blockquote><p>算法： 1 * 200/(1 * 200 + 4 * 200 + 0 * 200)= 1/5</p></blockquote></li><li><p>item 2 將分配到 <code>4/5</code> 的 negative free space，所以最後寬度為 120px。</p><blockquote><p>算法： 4 * 200/(1 * 200 + 4 * 200 + 0 * 200)= 4/5</p></blockquote></li><li><p>item 3 將分配到 <code>0/5</code> 的 negative free space，所以最後寬度為 200px。</p><blockquote><p>算法： 0 * 200/(1 * 200 + 4 * 200 + 0 * 200)= 0</p></blockquote></li></ul><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">1</span> auto;      <span class="comment">/* 佔 1*200/(1*200+4*200+0*200)= 1/5 等份 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">4</span> auto;     <span class="comment">/* 佔 4*200/(1*200+4*200+0*200)= 4/5 等份 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> auto;     <span class="comment">/* 佔 0*200/(1*200+4*200+0*200)= 0 等份 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/3pxK0LD.gif" alt=""></p><br><h3 id="flex-basis"><a class="header-anchor" href="#flex-basis"></a>flex-basis</h3><ul><li><p>決定 flex item 在尚未 grow 或 shrink 前的<code>原始尺寸</code>。</p></li><li><p><code>預設值</code>為 <code>auto</code>。</p><ul><li>若<code>有</code>指定尺寸 width、height (視主軸 main axis 而定)，則依照<code>所指定的尺寸</code>。</li><li>若<code>無</code>指定尺寸 width、height (視主軸 main axis 而定)，則由其<code>內容大小</code>決定。</li></ul></li><li><p>若為 <code>0</code>，則 flex item <code>不被納入空間計算</code>。例如有一個 container 寬度 400px，裡面有 item1 與 item2，寬度各為 200px，此時 flex-basis 為預設的 auto，故沒有剩餘空間。但若將 item2 的 flex-basis 設為 0，則會有 200px 的剩餘空間，原因是 flex-basis 優先級高於 width 與 height。</p></li><li><p>除了 auto 之外，尚有 content、max-content、min-content 等屬性值，不過多數瀏覽器不支援。</p></li><li><p>可給定<code>有單位</code>的<code>數值</code>，例如 100px 或 10%，若<code>同時</code>設定 <code>flex-basis (非 auto)</code> 和<code>尺寸</code>(width 或 height，視主軸 main axis 而定)，則以 <code>flex-basis</code> 為<code>優先</code>。</p></li></ul><p>例如：</p><p>有三個 flex items，指定第一個 flex item 的 width 為 200px，<br>在 flex-direction: row 且 flex-grow 與 flex-shrink 皆為 0 的前提下，設定 flex-basis 值為 auto，此時</p><ul><li>第一個 flex item 的寬度為 200px。</li><li>第二與第三個 flex item 的寬度為其內容尺寸。</li></ul><p><img src="https://i.imgur.com/zY5dqky.png" alt=""></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>flex item 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>flex item 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>flex item 3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;    <span class="comment">/* 第一個子元素給定寬度 200px */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &gt; * &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> auto;  <span class="comment">/* 所有子元素的 flex basis 為 auto*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h2 id="flex-屬性另類寫法"><a class="header-anchor" href="#flex-屬性另類寫法"></a>flex 屬性另類寫法</h2><p>flex 屬性除了直接給定 flex-grow、flex-shrink、flex-basis 三個值之外，還有以下幾種寫法。</p><ul><li>flex: <code>initial</code></li><li>flex: <code>auto</code></li><li>flex: <code>none</code></li><li>flex: <code>&lt;正數&gt;</code></li></ul><p>註：&lt;正數&gt; 可不必為整數，例如可為 0.5。</p><br><p>以下分別說明這四種屬性值的意義。</p><br><h3 id="flex-initial"><a class="header-anchor" href="#flex-initial"></a>flex: initial</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>： <span class="selector-tag">initial</span>;</span><br></pre></td></tr></table></figure><p>等同於</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>： 0 1 <span class="selector-tag">auto</span>;</span><br></pre></td></tr></table></figure><p>flex item 會依照 width 或 height (視主軸 main axis 而定)屬性決定其尺寸，即使 container 中<code>有剩餘空間</code>，flex item 仍<code>無法延伸</code>，但當<code>空間不足</code>時，元素<code>可收縮</code>。</p><br><h3 id="flex-auto"><a class="header-anchor" href="#flex-auto"></a>flex: auto</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: <span class="selector-tag">auto</span>;</span><br></pre></td></tr></table></figure><p>等同於</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: 1 1 <span class="selector-tag">auto</span>;</span><br></pre></td></tr></table></figure><p>flex item <code>可延伸</code>與<code>收縮</code>，會依照 width 或 height (視主軸 main axis 而定)屬性決定其尺寸。若所有 flex items 均設定 flex: auto 或 flex: none，則在 flex items 尺寸決定後，剩餘空間會被平分給 flex: auto 的 flex items。</p><br><h3 id="flex-none"><a class="header-anchor" href="#flex-none"></a>flex: none</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: <span class="selector-tag">none</span>;</span><br></pre></td></tr></table></figure><p>等同於</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: 0 0 <span class="selector-tag">auto</span>;</span><br></pre></td></tr></table></figure><p>flex item <code>不可延伸</code>與<code>收縮</code>，會依照 width 或 height (視主軸 main axis 而定)屬性決定其尺寸。</p><br><h3 id="flex-positive-number"><a class="header-anchor" href="#flex-positive-number"></a>flex: positive-number</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: &lt;正數&gt;;</span><br></pre></td></tr></table></figure><p>等同於</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: &lt;正數&gt; 1 0;</span><br></pre></td></tr></table></figure><p>flex item <code>可延伸</code>與<code>收縮</code>，flex-basis 為 <code>0</code>，故 flex item 會依據所設定的比例佔用 container 中的剩餘空間。</p><p>例如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: 2;</span><br></pre></td></tr></table></figure><p>等同於</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: 2 1 0;</span><br></pre></td></tr></table></figure><p>可利用此種屬性值的指定方式，輕易地決定 <code>flex items</code> 在 <code>flex container</code> 中所佔的尺寸<code>比例</code> (width 或 height，視主軸 main axis 而定)。</p><br><p>例如，一個 flex container 裡面有三個 flex items，希望不管 container 如何變化，這三個 items 的<code>尺寸皆一樣大</code>，則可設定每個 items 的 flex 屬性有相同的正數(positive-number)。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;   <span class="comment">/* 將得到容器中剩餘空間的 1/(1+1+1)＝1/3 等份 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;   <span class="comment">/* 將得到容器中剩餘空間的 1/(1+1+1)＝1/3 等份 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;   <span class="comment">/* 將得到容器中剩餘空間的 1/(1+1+1)＝1/3 等份 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>註：只要是<code>相同正數</code>即可，其僅代表<code>比例</code>關係。</p><p><img src="https://i.imgur.com/wWL2qtn.png" alt=""></p><p>且不論容器如何變動(例如縮放視窗時)，比例皆為 <code>1 : 1 : 1</code>。</p><p><img src="https://i.imgur.com/xNoC0bS.gif" alt=""></p><br><p>同理，若希望這三個 flex items 的尺寸比例分別為 <code>3 : 2 : 1</code>，則可設定：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">3</span>;   <span class="comment">/* 將得到容器中剩餘空間的 3/(3+2+1)＝3/6 等份 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span>;   <span class="comment">/* 將得到容器中剩餘空間的 2/(3+2+1)＝2/6 等份 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;   <span class="comment">/* 將得到容器中剩餘空間的 1/(3+2+1)＝1/6 等份 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/L1azPUh.png" alt=""></p><p>且不論容器如何變動(例如縮放視窗時)，比例皆為 <code>3 : 2 : 1</code>。</p><p><img src="https://i.imgur.com/qIBQMX1.gif" alt=""></p><br><br><br><p>有關於 flex 屬性以及伸縮的計算方式就介紹到此，下一篇將繼續介紹 flex 的各種對齊方式。</p><br><br><br><br><p><b>參考資源</b></p><ol><li><a href="https://www.w3.org/TR/css-flexbox-1/#flexibility">W3C-CSS Flexible Box Layout Module Level 1</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Controlling_Ratios_of_Flex_Items_Along_the_Main_Ax">MDN-Controlling Ratios of Flex Items Along the Main Axis</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10194694">前端新手村 flex grow &amp; shrink 演算法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 原理 - Flex(上)</title>
      <link href="/article/Flex.html"/>
      <url>/article/Flex.html</url>
      
        <content type="html"><![CDATA[<p>接下來將介紹 flex，從先前 <a href="https://yachen168.github.io/article/Formatting-context.html">formatting context</a> 的觀念開始，再詳細介紹每個屬性的用法以及 flex box 伸縮的計算方式。</p><a id="more"></a><br><h2 id="display-flex-inline-flex"><a class="header-anchor" href="#display-flex-inline-flex"></a>display: flex | inline-flex</h2><p>flex container 顧名思義就是一個容器(container)，描述 flex 元素與其後裔元素之間的關係，當對一個元素設定 <code>display: flex</code> 時，<code>此元素</code>稱為 <code>flex container</code>，而其<code>直接子元素</code>則稱為 <code>flex item</code>。</p><p><img src="https://i.imgur.com/nWyrjIY.png" alt=""><br><br></br></p><p><code>display: flex</code> 的元素會生成 <code>block-level box</code> 與 <code>flex container</code>，所以該元素本身會<code>參與 BFC</code> 佈局，呈現垂直排列，另一方面，為其內容<code>建立 FFC</code>。</p><p><code>display: inline-flex</code> 的元素會生成 <code>inline-level box</code> 與 <code>flex container</code>，所以該元素本身會<code>參與 IFC</code> 佈局，且會為其內容<code>建立 FFC</code>。</p><p><img src="https://i.imgur.com/bkFfnzR.png" alt=""></p><br><h3 id="flex-container"><a class="header-anchor" href="#flex-container"></a>flex container</h3><ul><li><p>display 為 <code>flex</code> 或 <code>inline-flex</code> 的元素。</p></li><li><p>flex container 會建立 flex formatting contex(FFC)，所以此元素<code>不會</code>與 float 元素重疊。</p></li><li><p>column-* 屬性<code>不</code>適用。</p></li></ul><br><h3 id="flex-item"><a class="header-anchor" href="#flex-item"></a>flex item</h3><p>display 為 flex 或 inline-flex 元素的<code>子</code>元素稱為 <code>flex item</code>。</p><ul><li><p><code>建立</code> BFC，所以 <code>flex items</code> 之間<code>不會</code>發生 <code>margin collapsing</code>，也不會與其父元素(flex container)發生 margin collapsing。</p></li><li><p><code>參與</code> FFC。</p></li><li><p>vertical-align <code>不</code>適用。</p></li><li><p>float 與 clear <code>不</code>適用。</p></li><li><p>即使 flex item 是 display: inline 的元素，仍然<code>可以</code>透過 <code>width</code> 與 <code>height</code> 屬性調整寬高。因 flex item 是 <a href="https://www.w3.org/TR/css-display-3/#blockify">blockified</a>。</p></li></ul><br><br><h2 id="主軸-main-axis-與副軸-cross-axis"><a class="header-anchor" href="#主軸-main-axis-與副軸-cross-axis"></a>主軸(main axis)與副軸(cross axis)</h2><p>flex items 可以透過 <code>flex-direction</code> 屬性來決定<code>排列方向</code>，flex-direction 同時也會決定<code>主軸(main axis)</code>與<code>副軸(cross axis)</code>。</p><p><img src="https://i.imgur.com/8G9pzzZ.png" alt=""><br>圖片來源：<a href="https://www.w3.org/TR/css-flexbox-1/#flex-direction-property">W3C</a></p><br><p>flex-direction 共有四個屬性值，會受到<code>書寫方向 writing-mode</code> 影響。<br><br></p><p><img src="https://i.imgur.com/3ow0Yie.png" alt=""><br><img src="https://i.imgur.com/EkZ9GhU.png" alt=""></p><br><p><b>以<code>橫向</code>且<code>由左至右</code>的書寫方式來說，此時 row 為橫向，column 為直向。</b></p><h3 id="flex-direction-row"><a class="header-anchor" href="#flex-direction-row"></a>flex-direction: row</h3><ul><li>主軸為 row 方向。</li><li>副軸為 column 方向。</li><li>由 <code>main start</code> 至 <code>main end</code> 排列。</li></ul><h3 id="flex-direction-row-reverse"><a class="header-anchor" href="#flex-direction-row-reverse"></a>flex-direction: row-reverse</h3><ul><li>主軸為 row 方向。</li><li>副軸為 column 方向。</li><li>由 <code>main end</code> 至 <code>main start</code> 排列。</li></ul><h3 id="flex-direction-column"><a class="header-anchor" href="#flex-direction-column"></a>flex-direction: column</h3><ul><li>主軸為 column 方向。</li><li>副軸為 row 方向。</li><li>由 <code>main start</code> 至 <code>main end</code> 排列。</li></ul><h3 id="flex-direction-column-reverse"><a class="header-anchor" href="#flex-direction-column-reverse"></a>flex-direction:column-reverse</h3><ul><li>主軸為 column 方向。</li><li>副軸為 row 方向。</li><li>由 <code>main end</code> 至 <code>main start</code> 排列。</li></ul><br><h2 id="flex-wrap"><a class="header-anchor" href="#flex-wrap"></a>flex-wrap</h2><p><code>flex-wrap</code> 屬性適用於 <code>flex container</code>，有 <code>nowrap</code>、<code>wrap</code> 與 <code>wrap-reverse</code> 三種屬性值。<br><br></p><p><img src="https://i.imgur.com/BNQ3Lbt.png" alt=""><br>圖片來源：<a href="https://www.w3.org/TR/css-flexbox-1/#flex-wrap-property">W3C</a></p><br><h3 id="nowrap"><a class="header-anchor" href="#nowrap"></a>nowrap</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-wrap</span>: <span class="selector-tag">nowrap</span></span><br></pre></td></tr></table></figure><ul><li><code>不</code>換行，為預設值。</li></ul><p><img src="https://i.imgur.com/UA89lTf.png" alt=""><br><br></p><h3 id="wrap"><a class="header-anchor" href="#wrap"></a>wrap</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-wrap</span>: <span class="selector-tag">wrap</span>;</span><br></pre></td></tr></table></figure><ul><li><code>換行</code>，由 <code>cross start</code> 開始向 <code>cross end</code> 堆疊。</li></ul><p><img src="https://i.imgur.com/zstxoLd.png" alt=""></p><br><h3 id="wrap-reverse"><a class="header-anchor" href="#wrap-reverse"></a>wrap-reverse</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-wrap</span>: <span class="selector-tag">wrap-reverse</span>;</span><br></pre></td></tr></table></figure><ul><li><code>可換行</code>，由 <code>cross end</code> 開始向 <code>cross start</code> 堆疊。</li></ul><p><img src="https://i.imgur.com/OkMGviF.png" alt=""></p><br><h2 id="flex-flow-屬性"><a class="header-anchor" href="#flex-flow-屬性"></a>flex-flow 屬性</h2><p><code>flex-direction</code> 屬性與 <code>flex-wrap</code> 屬性的<code>縮寫</code>。</p><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-flow</span>: <span class="selector-tag">row</span> <span class="selector-tag">wrap</span>;</span><br></pre></td></tr></table></figure><p>上式等同於</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">row</span>;   <span class="comment">/* 預設值 */</span></span><br><span class="line"><span class="selector-tag">flex-wrap</span>: <span class="selector-tag">wrap</span>;</span><br></pre></td></tr></table></figure><br><p>又例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-flow</span>: <span class="selector-tag">row-reverse</span> <span class="selector-tag">wrap-reverse</span>;</span><br></pre></td></tr></table></figure><p>上式等同於</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">row-reverse</span>;</span><br><span class="line"><span class="selector-tag">flex-wrap</span>: <span class="selector-tag">wrap-reverse</span>;</span><br></pre></td></tr></table></figure><br><h2 id="order-屬性"><a class="header-anchor" href="#order-屬性"></a>order 屬性</h2><p><code>order</code> 屬性可以控制 <code>flex items</code> 的<code>順序</code>，會從 order 最小的開始排序。<br>僅適用於 <code>flex items</code>，屬性值須為<code>整數(可為負數)</code>， 預設下皆為 <code>0</code>。</p><p><img src="https://i.imgur.com/8WuzGEP.png" alt=""><br>圖片來源：<a href="https://www.w3.org/TR/css-flexbox-1/#order-property">W3C</a></p><br><p>直接看圖比較快～<br>例如在書寫方向為橫向且由左至右的前提下，若主軸(main axis)為 row，即 flex-direction: row，則 flex items 的會依照其 order 由左至右排序(order 愈小愈優先)。</p><ul><li><strong>1 &lt; 3 &lt; 4</strong></li></ul><p><img src="https://i.imgur.com/GCfs4Aw.png" alt=""><br><br></br></p><ul><li><strong>-5 &lt; -2 &lt; 4 &lt; 8</strong></li></ul><p><img src="https://i.imgur.com/lrWZ1qB.png" alt=""></p><br><p>若主軸(main axis)為 column，即 flex-direction: column，則 flex items 會依照其 order 由上至下排序(order 愈小愈優先)。<br><br></p><ul><li><strong>1 &lt; 3 &lt; 4</strong></li></ul><p><img src="https://i.imgur.com/jrz2iEn.png" alt=""><br><br></br></p><ul><li><strong>-10 &lt; 4 &lt; 7 &lt; 13</strong></li></ul><p><img src="https://i.imgur.com/owoYoSz.png" alt=""></p><br><br><h4 id="參考資料"><a class="header-anchor" href="#參考資料"></a>參考資料</h4><ol><li><a href="https://www.w3.org/TR/css-flexbox-1/#flexibility">W3C-CSS Flexible Box Layout Module Level 1</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Controlling_Ratios_of_Flex_Items_Along_the_Main_Ax">MDN-Controlling Ratios of Flex Items Along the Main Axis</a></li><li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">CSS TRICKS-A Complete Guide to Flexbox</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 原理 - position</title>
      <link href="/article/Position.html"/>
      <url>/article/Position.html</url>
      
        <content type="html"><![CDATA[<p>這篇要介紹的是 position，顧名思義，它與元素的位置或定位方式有關，了解它的各種屬性值肯定是必要的，像是常見的彈跳視窗或固定導覽列，也都需要它。</p><a id="more"></a><br><h2 id="position-語法"><a class="header-anchor" href="#position-語法"></a>position 語法</h2><p>position 的屬性值有 static、relative、absolute、fixed 與 sticky。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: static | relative | absolute | fixed | sticky</span><br></pre></td></tr></table></figure><br><h3 id="static"><a class="header-anchor" href="#static"></a>static</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">static</span>;</span><br></pre></td></tr></table></figure><ul><li><p>為預設值。</p></li><li><p>元素為 in-flow。</p></li><li><p>top、right、bottom 與 left 屬性皆無效。</p></li><li><p>z-index 屬性無效。</p></li></ul><br><p><img src="https://i.imgur.com/Z8A5Qln.png" alt=""></p><br><h3 id="relative"><a class="header-anchor" href="#relative"></a>relative</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br></pre></td></tr></table></figure><ul><li><p>元素仍為 in-flow，為元素<code>預留原本的空間</code>。</p></li><li><p>top、right、bottom 與 left 屬性可指定元素相對於<code>自身原本的位置</code>做偏移，<code>不影響</code>其他元素的位置。</p></li></ul><p><img src="https://i.imgur.com/PzvtHCj.png" alt=""></p><ul><li>此屬性值對 display 值為 table-row-group、table-header-group、table-footer-group、table-row、table-column-group、 table-column、table-cell 與 table-caption 的元素無效。</li></ul><br><h3 id="absolute"><a class="header-anchor" href="#absolute"></a>absolute</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br></pre></td></tr></table></figure><ul><li>元素 out-of-flow，<code>不為</code>元素預留原本的空間。</li></ul><p><img src="https://i.imgur.com/N7nm4d3.png" alt=""></p><ul><li><p>相對於祖譜中<code>最接近</code>且 <code>position</code> 值<code>非 static</code> 的<code>containing block(包含塊)</code>做定位，<code>若無</code>，則追溯至 initial containing block (初始包含塊)，在連續媒體下即為 veiwport (視口)。</p></li><li><p>top、right、bottom 與 left 屬性可指定其對於<code>containing block(包含塊)</code>的偏移量，不影響其他元素的位置。</p></li><li><p><code>不會</code>與其他元素發生 <code>margin collapsing(外距重疊)</code>，因為會建立一個新的 BFC。</p></li><li><p>建立 <code>Block Formatting Context(BFC)</code>。</p></li></ul><br><h3 id="fixed"><a class="header-anchor" href="#fixed"></a>fixed</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">fixed</span>;</span><br></pre></td></tr></table></figure><br><ul><li>元素 out-of-flow，<code>不為</code>元素預留原本的空間。</li></ul><p><img src="https://i.imgur.com/BIxGB5g.gif" alt=""></p><ul><li><p><code>containing block(包含塊)</code>為 <code>veiwport</code>，所以會以 veiwport 做定位，滾動時，元素相對於 viewport 仍處於同一位置。</p></li><li><p>上層元素中若有 <code>transform</code> 屬性<code>非 none </code>的祖先時，<code>containing block(包含塊)</code>由 veiwport <code>改為該祖先</code>，即針對該祖先定位。</p></li><li><p>top、right、bottom 與 left 屬性可指定其對於<code>containing block</code>的偏移量。</p></li><li><p><code>不會</code>與其他元素發生 margin collapsing(外距重疊)。</p></li><li><p>建立 <code>Block Formatting Context(BFC)</code>。</p></li></ul><br><h3 id="sticky"><a class="header-anchor" href="#sticky"></a>sticky</h3><p>為相對定位(relative)和固定定位(fixed)的混合體。元素在跨越<code>特定門檻(specified threshold)</code>之前屬於相對定位，之後屬於固定定位。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">sticky</span>;</span><br></pre></td></tr></table></figure><ul><li><p>元素為 in-flow。</p></li><li><p>必須指定 top、right、bottom 或 left 其中一個做為<code>特定門檻(specified threshold)</code>，sticky 才有效，<code>即使是 top: 0</code>。</p></li><li><p>相對於最近的可滾動祖先和 containing block 做定位。</p></li><li><p>top、right、bottom 與 left 屬性可指定其偏移量，不影響其他元素的位置。</p></li><li><p>建立 <code>Block Formatting Context(BFC)</code>。</p></li></ul><br><p>例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">280px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1850px</span>;  <span class="comment">/*  可滾動   */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: sticky;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">150px</span>;  <span class="comment">/*  門檻值(必要條件)  */</span> </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">70px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ZoLNZ9R.gif" alt=""></p><br><br><p><br>參考資源</br><br><a href="https://www.w3.org/TR/CSS22/visuren.html#choose-position">W3C-hoosing a positioning scheme: ‘position’ property</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position">MDN-position</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context">MDN-Block formatting context</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 原理 - Block Formatting Context</title>
      <link href="/article/Block-formatting-context.html"/>
      <url>/article/Block-formatting-context.html</url>
      
        <content type="html"><![CDATA[<p>或許你沒聽過 Block Formatting Context，但你肯定有用過！其實在切版時，常常會使用到 BFC，只是你沒有意識到而已，如果能夠有意識的使用 BFC，對於版面的掌控非常有幫助。</p><a id="more"></a><br><h2 id="什麼是-Block-Formatting-Context"><a class="header-anchor" href="#什麼是-Block-Formatting-Context"></a>什麼是 Block Formatting Context</h2><p>如同上一篇 <a href="https://yachen168.github.io/article/Formatting-context.html#more">CSS 原理 - Formatting Context</a> 所說，Formatting Context 指的是佈局環境，而佈局環境有許多種，不同的佈局環境會有不同的佈局規則，Block Formatting Context (BFC)是其中一種。</p><p>下方為一段 <a href="https://www.w3.org/TR/CSS21/visuren.html#block-formatting">W3C</a> 對於 BFC 的敘述：</p><blockquote><p>In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.</p></blockquote><blockquote><p>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch).</p></blockquote><br><p>簡單來說，處在<code>同一個 BFC </code>中的元素(盒子)，會有以下現象：</p><ul><li><p>元素(盒子)從其 <code>containing block(包含塊)</code>的頂部開始，一個接一個呈現<code>垂直</code>排列。</p></li><li><p>若書寫方向為預設的由左至右，則元素(盒子)會貼齊其 containing block(包含塊)左側。</p></li><li><p>相鄰元素(盒子)之間的垂直距離，由元素的 margin 屬性決定。</p></li><li><p>相鄰的 block-level box(塊級盒子)垂直方向會發生 <code>margin collapsing(邊距重疊)</code>。</p></li></ul><br><h3 id="圖示"><a class="header-anchor" href="#圖示"></a>圖示</h3><p>將上述現象用圖形表示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先，&lt;html&gt; 會建立一個 BFC (先破梗了)，而 &lt;body&gt; 與三個 &lt;div&gt; 參與的是 &lt;html&gt; 建立的 BFC，也就是說， &lt;body&gt; 與三個 &lt;div&gt; 處於同一個 BFC 中，因此元素會：</p><ul><li>呈現垂直排列。</li><li>可以用 margin 來推開彼此。</li><li>垂直方向會發生 margin collapsing(邊距重疊)，其中 margin collapsing 又分為兩種(同層元素間以及元素與其容器間)，可參考先前文章 <a href="https://yachen168.github.io/article/Collapsing-margins.html">CSS 原理 - Collapsing margins</a>。</li></ul><p><img src="./Block-formatting-context/BFC.png" alt=""></p><br><p>注意，以上現象強調的是處於同一個 BFC 裡的元素(盒子)，若元素自立門戶創建新的 BFC，則不完全適用，所以<code>了解什麼情況會建立新的 BFC 很重要</code>。</p><br><br><h2 id="何時會建立-BFC"><a class="header-anchor" href="#何時會建立-BFC"></a>何時會建立 BFC</h2><p>對於「什麼時候會建立一個 BFC」，其實 <a href="https://www.w3.org/TR/css-display-3/#block-formatting-context">W3C</a> 並沒有一個非常正式的定義，有些條件是非常不嚴謹的，而在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">MDN</a> 上則有逐一詳細列出，可供參考。</p><br><p>根據 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">MDN</a>，以下情況的元素會創建 Block Formatting Context(BFC)：</p><blockquote><ul><li>&lt;html&gt;</li><li>float 元素</li><li>position: absolute、fixed 的元素</li><li>overflow: hidden、scroll、auto 的元素</li><li>display: inline-block 的元素</li><li>display: flow-root 的元素</li><li>display: flex 或 inline-flex 元素的<code>直接子元素</code>，即 flex items</li><li>display: grid 或 inline-grid 元素的<code>直接子元素</code>，即 grid items</li><li>display: table、table-caption、table-cell、table-rowtable-row-group、table-header-group、table-footer-groupinline-table</li><li>contain: layout、content 或 paint 的元素</li><li>column-count 或 column-width 不為 auto 的元素</li><li>column-span 為 all 的元素</li></ul></blockquote><br><br><hr><h2 id="BFC-功用"><a class="header-anchor" href="#BFC-功用"></a>BFC 功用</h2><p>可以解決：</p><ul><li><code>float</code> 元素的<code>外層容器塌陷</code>問題。</li><li>元素間的 <code>margin collapsing(外邊距重疊)</code>問題</li><li>float 元素與其他元素的重疊問題 (float 元素遮住其他元素)。</li></ul><br><h3 id="解決-float-元素造成外容器塌陷問題"><a class="header-anchor" href="#解決-float-元素造成外容器塌陷問題"></a>解決 float 元素造成外容器塌陷問題</h3><p>float 元素會導致外層容器的高度塌陷(若外層容器高度為 auto 且無其它比 float 元素高的子元素)。</p><p>例如：<a href="https://codepen.io/yachen/pen/wvambOK?editors=1100">範例連結</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是裝著 float 元素的容器<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>我是 float 元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: grey;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.float</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./Block-formatting-context/float-1.png" alt=""></p><br><p>此時可以<code>使外層容器建立 BFC 來恢復高度</code>，例如在外層容器加上 overflow: hidden 或 display: flow-root。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">      <span class="attribute">display</span>: flow-root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登愣～外層容器撐開了。<br><img src="./Block-formatting-context/float-2.png" alt=""></p><br><h3 id="解決-margin-collapsing-問題"><a class="header-anchor" href="#解決-margin-collapsing-問題"></a>解決 margin collapsing 問題</h3><p>當元素與元素之間發生 margin collapsing 時，可使元素建立 BFC 來解決 margin collapsing 的問題。</p><br><h3 id="解決-float-元素遮住其他元素的問題"><a class="header-anchor" href="#解決-float-元素遮住其他元素的問題"></a>解決 float 元素遮住其他元素的問題</h3><p>在先前文章 <a href="https://yachen168.github.io/article/LineBox.html">CSS 原理 - Line box</a> 曾提到，float 元素會擠壓 line box，除此之外，float 元素還可能遮住其它元素！<br><br></p><p>如果你有用過 float，應該有遇過 float 元素遮住其它非 float 元素的情況，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.float</span>&#123;</span><br><span class="line">      <span class="attribute">float</span>: left;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">      <span class="attribute">display</span>: block;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>橘色的 float 元素蓋住了黃色元素。</p><p><img src="./Block-formatting-context/float-3.png" alt=""></p><br><p>只要讓黃色元素建立 BFC 即可解決重疊問題，例如加上 overflow: hidden 或 display: flow-root。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">      <span class="attribute">display</span>: flow-root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./Block-formatting-context/float-4.png" alt=""></p><br><br><br><p><b>參考資源</b></p><p><a href="https://www.w3.org/TR/css-display-3/#glossary">W3C-Appendix A: Glossary</a><br><a href="https://www.w3.org/TR/css-display-3/#the-display-properties">W3C-Box Layout Modes: the display property</a><br><a href="https://www.w3.org/TR/CSS21/box.html#collapsing-margins">W3C-Collapsing margins</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context">MDN-Block formatting context</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> w3HexSchool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 原理 - Formatting Context</title>
      <link href="/article/Formatting-context.html"/>
      <url>/article/Formatting-context.html</url>
      
        <content type="html"><![CDATA[<p>每個元素都是一個個的盒子(box)，這些盒子在 in flow 下會如何排列就要看該盒子處在什麼樣的佈局環境，而 formatting context (格式化上下文) 指的就是佈局環境，不同類型的佈局環境會有不同的佈局規則，換句話說，處在不同類型佈局環境裡的盒子，排列方式會有所不同。</p><a id="more"></a><h2 id="什麼是-Formatting-Context"><a class="header-anchor" href="#什麼是-Formatting-Context"></a>什麼是 Formatting Context</h2><p>先來看一段 W3C 規範對於 formatting context (格式化上下文) 的敘述。<br>摘自 <a href="https://www.w3.org/TR/css-display-3/#glossary">W3C</a></p><blockquote><p>A formatting context is the environment into which a set of related boxes are laid out. Different formatting contexts lay out their boxes according to different rules.</p></blockquote><blockquote><p>A box either establishes a new independent formatting context or continues the formatting context of its containing block. The type of formatting context established by the box is determined by its inner display type.</p></blockquote><blockquote><p>Additionally, some types of formatting contexts interleave and co-exist.</p></blockquote><br><p>也就是說，formatting context 指的是一個「佈局環境」，處在什麼佈局環境裡的元素(盒子)，就得遵守什麼環境的佈局規則，盒子也可以自立門戶，建立新的 formatting context，再繼續裝其它盒子，而會<code>建立什麼類型的 formatting context</code>，取決於 display 屬性的 <code>inner display type</code>。可參考先前文章 <a href="https://yachen168.github.io/article/display.html">你所不知道的 display</a>。</p><p>有些類型的 formatting contexts 可以同時交互並存，像是 BFC 與 IFC 或是 FFC 與 IFC 等。<br><br></p><h2 id="Formatting-Context-類型"><a class="header-anchor" href="#Formatting-Context-類型"></a>Formatting Context 類型</h2><p>Formatting context 大致有以下幾種，其中，BFC 與 IFC 對於排版來說最為重要，而除了 BFC 較為特殊之外，其餘的 formatting context 取決於元素的 display 屬性。</p><ul><li>Block Formatting Context (BFC)</li><li>Inline Formatting Context (IFC)</li><li>Flex Formatting Context (FFC)</li><li>Grid Formatting Context (GFC)</li><li>Ruby Formatting Contect (RFC)</li></ul><br><h2 id="Independent-Formatting-Context"><a class="header-anchor" href="#Independent-Formatting-Context"></a>Independent Formatting Context</h2><p>剛提到盒子可以自立門戶，為其後裔元素<code>建立</code>自己的 formatting context，而當一個元素(盒子)建立了獨立的 formatting context，不論所建立的類型是否與該元素所處的 formatting context 相同，都是為其<code>後裔元素</code>建立了一個新的佈局環境，所以其後裔元素的佈局通常不必再遵守該元素所處的佈局環境規則。</p><p>值得留意的是，除了 display 之外，有些屬性也會使元素<code>建立</code>獨立的 formatting context，像是 <code>float</code>、<code>position: absolute</code> 或 <code>fixed</code> 這些會使元素脫離正常流(out-of-flow)的屬性皆會<code>建立</code>獨立的 formatting context。</p><br><h2 id="圖解-Formatting-Context"><a class="header-anchor" href="#圖解-Formatting-Context"></a>圖解 Formatting Context</h2><p>「Formatting context 是個佈局環境，不同的 formatting context 有不同的佈局方式」，用圖形或許可以幫助理解，以下將舉三個例子，主要為 BFC 與 IFC，其他類型的 formatting context 概念皆相同，可以此類推。</p><p>下圖截取部分 W3C 規範中的 display 表格，若對於這個表格感到陌生的讀者，建議先看先前文章 <a href="https://yachen168.github.io/article/display.html">你所不知道的 display</a>。</p><p><img src="./Formatting-context/display.png" alt=""><br>圖片來源: <a href="https://www.w3.org/TR/css-display-3/#the-display-properties">W3C</a></p><br><h3 id="Case1-BFC"><a class="header-anchor" href="#Case1-BFC"></a>Case1: BFC</h3><p>&lt;html&gt; 就是個超級大盒子，裡面裝著其他盒子，且會<code>建立</code>一個 BFC，由上方 display 表可知，其後裔元素 &lt;body&gt; 與三個橘色的 block 元素皆會生成 block-level box，且處在 BFC 裡(或說是<code>參與</code> BFC)，所以會呈現垂直排列。</p><p><img src="./Formatting-context/BFC.png" alt=""></p><br><h3 id="Case2-IFC"><a class="header-anchor" href="#Case2-IFC"></a>Case2: IFC</h3><p>由上方 display 表可知，&lt;body&gt; 對內會生成 block container，可以建立 IFC，而其兩個橘色的 inline 後裔元素會生成 inline box(為一種 inline-level box)，且處在此 IFC 中(或說是<code>參與</code>該 IFC)，所以呈現水平排列。</p><p><img src="./Formatting-context/IFC.png" alt=""></p><br><h3 id="Case3-混合"><a class="header-anchor" href="#Case3-混合"></a>Case3: 混合</h3><p>inline-block 元素會生成<code>inline-level box</code>，該元素本身處在 &lt;body&gt; 所建立的 IFC 中(或說是<code>參與</code>該 IFC)，且兩個 inline-block 元素分別為其後裔元素建立了新的獨立佈局環境──<code>BFC</code> 與 <code>IFC</code>，所以其後裔元素<code>不會</code>與 inline-block 元素一同參與外部 IFC。</p><p><img src="./Formatting-context/inline-block.png" alt=""></p><br><br><h2 id="結語"><a class="header-anchor" href="#結語"></a>結語</h2><p>說穿了，formatting context 就真的只是「佈局環境」而已，花了一個篇幅解釋 formatting context 其實是在替後面的文章鋪路，接下來將介紹在排版中最為重要的 block formatting context(BFC)。</p><br><br><br><p><b>參考資料</b><br><a href="https://www.w3.org/TR/css-display-3/#glossary">W3C - Appendix A: Glossary</a><br><a href="https://www.w3.org/TR/css-display-3/#the-display-properties">W3C - Box Layout Modes: the display property</a><br><a href="https://www.w3.org/TR/CSS2/visuren.html#block-boxes">W3C - Block-level elements and block boxes</a><br><a href="https://www.w3.org/TR/CSS2/visuren.html#inline-boxes">W3C - Inline-level elements and inline boxes</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> w3HexSchool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 原理 - Line box</title>
      <link href="/article/LineBox.html"/>
      <url>/article/LineBox.html</url>
      
        <content type="html"><![CDATA[<p>Line box 就像筆記本上的線框，一行一行的垂直堆疊，裡面裝著文字或是 inline-level boxes，而我們可以利用 text-align 與 vertical-align 屬性操控 inline-level boxes 在 line box 裡的水平與垂直對齊。</p><a id="more"></a><h2 id="什麼是-line-box"><a class="header-anchor" href="#什麼是-line-box"></a>什麼是 line box</h2><p><img src="./LineBox/notebook.jpg" alt=""><br>圖片來源：<a href="https://visualhunt.com/photo2/1605/">visualhunt</a></p><p>line box 是用來裝文字與所有 inline-level box 的，換句話說，<code>只要有文字或是 inline-level box 的地方，就會出現 line box</code>，就像「行」的概念，一個 line box 就是一行。這篇將說明 line box 的範圍是如何決定的。</p><p>若對於哪些元素會生成 inline-level box 不太清楚，可複習<a href="https://yachen168.github.io/article/dispaly.html#more">上一篇 display</a> 文章。</p><br><h2 id="line-box-寬度"><a class="header-anchor" href="#line-box-寬度"></a>line box 寬度</h2><p>line box 是「行」的概念，也是一個矩形範圍，正常情況下，line box 的寬度取決於 <a href="https://yachen168.github.io/article/Containing-block.html">Containing block(包含塊)</a>，但若有 float 元素，則 line box 會受到壓縮(shrink)。</p><p>直接用實例來看會較具體一點，以下將比較正常情況下與在有 float 元素下，line box 的寬度會如何變化。</p><br><h3 id="Case-無-float-元素時"><a class="header-anchor" href="#Case-無-float-元素時"></a>Case: 無 float 元素時</h3><p>以 display: inline-block 為例，該元素屬於 inline-level box，故會產生 line box，而 line box 寬度取決於其 containing block(包含塊)。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block-container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inline-level-box"</span>&gt;</span></span><br><span class="line">    display: inline-block</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block-container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">250px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inline-level-box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block; <span class="comment">/* 為一種 inline-level-box */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./LineBox/width-2.png" alt=""></p><br><p>此時設定 text-align: center，則橘色的 inline-level box 會水平置中於 line box 裡，這結果應該毫不令人意外。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block-container</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./LineBox/text-align-2.png" alt=""></p><br><h3 id="Case-有-float-元素時"><a class="header-anchor" href="#Case-有-float-元素時"></a>Case: 有 float 元素時</h3><p>當有 float 元素時，line box 會受到 float 元素的擠壓，若擠壓到 line box 無法容納裡面的文字或是 inline-level box 時，line box 就會自動「<code>換行</code>」。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block-container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">250px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.float</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;   <span class="comment">/* float 會擠壓 line box */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#F75848</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inline-level-box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;   <span class="comment">/* 為一種 inline-level-box */</span></span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>此時 line box 已經被 float 元素壓縮了。<a href="https://codepen.io/yachen/pen/dyoOLWR?editors=1100">範例連結</a></p><p><img src="./LineBox/float-1.png" alt=""></p><p>設定 text-align: center，讓橘色的 inline-level box 水平置中於被壓縮後的 line box 裡。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block-container</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./LineBox/float-2.png" alt=""></p><br><p>接著，若 float 元素變更寬，擠壓 line box 更多，多到該行無法再容納橘黃色的 inline-level box 時，line box 就會「換行」。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.float</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;  <span class="comment">/* 變超胖 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./LineBox/float-4.png" alt=""></p><br><h2 id="line-box-高度"><a class="header-anchor" href="#line-box-高度"></a>line box 高度</h2><p>如同上述，line box 是用來裝文字或 inline-levle box 的，所以一個 line box (同一行)高度由位置<code>最高</code>的 <code>inline-level box 頂部</code>與位置<code>最低</code>的 <code>inline-level box 底部</code>的距離。</p><p>其中 inline-level box 又可二分為 inline box 與 atomic inline-level box 兩種，像是<code>替換元素 &lt;img&gt;</code> 或 <code>display: inline-block</code> 皆屬於 atomic inline-level box，下一篇文章會說明兩種有何差別(應該會吧)。</p><br><h3 id="Case-若是-inline-box"><a class="header-anchor" href="#Case-若是-inline-box"></a>Case: 若是 inline box</h3><blockquote><p>Inline box 僅有 box model 中的 content area 會影響 line box 高度。</p></blockquote><p>Line box 僅取決於 inline box 的 content area (像是 line-height 或 font-size 皆會影響 content area)，<code>不</code>包含 padding、border、margin。</p><h4 id="例子"><a class="header-anchor" href="#例子"></a>例子</h4><p>&lt;span&gt; 預設為 display: inline，且非替換元素(nonreplaced elememt)，為 inline-level element 中的 inline element，故其僅有 line-height 會影響 line box，padding、border、margin 皆不會影響 line box 高度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Lorem ipsum, dolor sit add</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>我在 inline box 裡面<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    Lorem ipsum, dolor sit amet consectetur .</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">220px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>為方便觀察，給 &lt;span&gt; 背景橘色的顏色，並給 &lt;span&gt; 上下左右 padding 各 10px。<br><code>反白區域為一個 line box 高度</code>。可以清楚看見，<code>line box 並沒有被撐高</code>，上下方的文字沒有被推開(但左右有)。</p><p><img src="./LineBox/inline-box.png" alt=""></p><p><br></br></p><h3 id="Case-若是-atomic-inline-level-box"><a class="header-anchor" href="#Case-若是-atomic-inline-level-box"></a>Case: 若是 atomic inline-level box</h3><blockquote><p>Atomic inline-level box 的整個 box model 會影響 line box 高度。</p></blockquote><p>Line box 取決於 atomic inline-level box 的整個 <code>box model 高度</code>，即包含 padding、border 與 margin 部分。</p><br><h4 id="例子-v2"><a class="header-anchor" href="#例子-v2"></a>例子</h4><p>現在將 &lt;span&gt; 設定為 display: inline-block，&lt;span&gt; 仍然屬於 inline-level element，但由 inline element 變成 <code>atomic inline-level element</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block; <span class="comment">/* 變成 atomic inline-level */</span></span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></br></p><p><code>反白區域為一個 line box 高度</code>。可以清楚看見，<code>line box 長高了</code>，所以上下方文字的距離也隔開了！</p><p><img src="./LineBox/atomic-box.png" alt=""></p><br><p>註：<br>① box model 高度為內容區高度 + 上下內距 +上下邊框 + 上下外距，可參考<a href="https://yachen168.github.io/article/box-model.html#more">先前文章</a>。</p><p>② <a href="https://developer.mozilla.org/zh-TW/docs/Web/CSS/Replaced_element">其它替換元素</a></p><br><br><p><b>參考資源</b><br><a href="https://www.w3.org/TR/CSS21/visuren.html#inline-formatting">W3C - Inline formatting contexts</a><br><a href="https://www.w3.org/TR/CSS21/visudet.html#line-height">W3C - Line height calculations</a><br><a href="https://www.w3.org/TR/CSS2/visuren.html#floats">W3C - Floats</a><br><a href="https://ithelp.ithome.com.tw/articles/10216486">鉄人28号FX　鉄人2号「文本士」content area</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> w3HexSchool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 原理 - 你所不知道的 display</title>
      <link href="/article/display.html"/>
      <url>/article/display.html</url>
      
        <content type="html"><![CDATA[<p>Visual formatting model (視覺格式化模型) 對於排版來說是很重要的觀念，但不是那麼平易近人且有點抽象，在初次看 <a href="https://www.w3.org/TR/CSS2/visuren.html">W3C 規範</a> 時一定是霧煞煞，強烈建議先釐清幾個重要名詞的定義，會發現繞來繞去，講的其實都是相同的概念。</p><a id="more"></a><h2 id="display"><a class="header-anchor" href="#display"></a>display</h2><p>為什麼 display: block 的元素們會呈現垂直排列？為什麼 display: inline 的元素們會呈現水平排列？又為什麼 display: inline-block 的元素是呈現水平排列呢？其實答案都與元素生成(generate)何種類型的 box 有關。<br><br></p><p>在先前 <a href="https://yachen168.github.io/article/box-model.html">box model 文章</a>中曾介紹，元素就像一個個的盒子 (box)，這篇將介紹在 in flow 下，這些「 盒子如何排列」，或說是「<code>元素如何佈局</code>」。</p><p>元素在 in flow 下如何佈局的主要關鍵為該元素「生成 (generate)了什麼類型的 box」，而這會取決於元素的 <code>display 屬性</code>。其實我們所熟悉的 display 同時定義了元素的兩種 display type：</p><ul><li><p><strong>outer display type</strong>：決定元素「<code>本身</code>」在 in flow 下如何佈局，即元素本身<code>參與</code>的是何種 formatting context (格式化上下文)。<br><br></p></li><li><p><strong>inner display type</strong>：決定元素為它的後裔元素<code>建立</code>何種 formatting context，與其<code>後裔元素的佈局</code>有關。<br><br></p></li></ul><h3 id="outer-display-type"><a class="header-anchor" href="#outer-display-type"></a>outer display type</h3><p>在 outer display type 方面，box 類型可分成 <code>inline-level box</code> 與 <code>block-level box</code> 兩大類，所有 inline-level box 皆會<code>參與 IFC</code>，呈現<code>水平</code>排列，而所有 block-level box 皆會<code>參與 BFC</code>，呈現<code>垂直</code>排列。</p><ul><li><p><strong>inline-level box (行內級盒子)</strong></p><ul><li><p>inline box (行內盒子)</p></li><li><p>atomic inline-level box (原子行內級盒)<br><br></p></li></ul></li><li><p><strong>block-level box (塊級盒子)</strong><br><br></p></li></ul><h3 id="inner-display-type"><a class="header-anchor" href="#inner-display-type"></a>inner display type</h3><p>在 inner display type 方面，因其描述的是元素本身與其內容或後裔元素的關係，可以想像成元素像個容器 (container)，裝著文字內容或後裔元素。常見的 container box 類型有 block container box、flex container box 與 grid container box 等等。</p><p>而什麼類型的 container box，就會為其內容或後裔元素<code>建立</code>什麼類型的 formatting context，例如：</p><ul><li><p>flex container 建立 flex formatting context (FFC)</p></li><li><p>grid container 建立 grid formatting context (GFC)</p></li><li><p>block container 可建立 block formatting context (BFC) 或 inline formatting context (IFC)</p></li></ul><p>順帶一提，替換元素 (replaced element)，例如 &lt;img&gt;，display 的預設值為 inline，不論將其 display 屬性值改成什麼，皆不會有 container box，因為它就是路徑來源的圖片，不是用來裝像是 &lt;span&gt;、&lt;div&gt; 或其他元素的容器。</p><p><img src="./display/display.png" alt=""><br>圖片來源: <a href="https://www.w3.org/TR/css-display-3/#the-display-properties">W3C</a></p><br><br><h2 id="了解-display-的好處"><a class="header-anchor" href="#了解-display-的好處"></a>了解 display 的好處</h2><p>講了這麼多，了解 display 到底有什麼好處？<br>個人認為至少有三大優點。</p><h3 id="秒殺元素排列方式"><a class="header-anchor" href="#秒殺元素排列方式"></a>秒殺元素排列方式</h3><p>即使遇到一個從來沒用過的 display 屬性值，也能夠馬上知道在 in flow 下，元素會<code>如何排列</code>，例如，你有聽過或用過 display: flow-root 或 inline-flex 嗎？</p><p>在沒有用過，甚至從沒聽過的情況下，一看 display 表就可以得知 display: flow-root 的元素會生成 block-level box，故元素本身參與 BFC，在 in flow 下會呈現垂直排列。而 display: inline-flex 會生成 inline-level box，故元素本身參與 IFC，在 in flow 下會呈現水平排列。<br><br></p><h3 id="秒殺屬性的適用對象"><a class="header-anchor" href="#秒殺屬性的適用對象"></a>秒殺屬性的適用對象</h3><p>例如常用的 vertical-align 與 text-align 對齊，你知道他們能操控的對象總共有哪些嗎？<br>其實他們是在操控 <code>inline-level</code> 的垂直與水平對齊。</p><p>vertical-align 屬性可以適用於所有 inline-level boxes，也就是可以操控 display 表上所有會生成 inline-level box 元素的垂直對齊。</p><p><img src="./display/vertical-align.png" alt=""><br>圖片來源：<a href="https://www.w3.org/TR/css-inline-3/#propdef-vertical-align">W3C</a></p><p>而 text-align 的屬性則是須設定在 inline-level 外層的 block container，它可操控 display 表上所有會生成 inline-level box 元素的水平對齊。</p><p><img src="./display/text-align.png" alt=""><br>圖片來源：<a href="https://www.w3.org/TR/css-text-3/#justification">W3C</a></p><br><p>再例如，margin: 0 auto，常用在 display: block 元素的水平置中，但除此之外，還可以用在哪些元素上呢？</p><p>其實 display 表上會生成 block-level box 的皆適用。<br><br></p><h3 id="何種-display-會產生-BFC"><a class="header-anchor" href="#何種-display-會產生-BFC"></a>何種 display 會產生 BFC</h3><p>就如同剛剛提及的，什麼類型的 container box 就會<code>建立</code>什麼類型的 formatting context，所以 block container box 可以建立 BFC，這時就可以由 dispaly 表中得知 display: inline-block 與 flow-root 皆會建立 BFC (display: block 例外)。</p><p>另外，其實 display: table 與 inline-table 亦會建立 BFC，因生成的 <a href="https://drafts.csswg.org/css-tables-3/#table-wrapper-box">table wrapper box</a> 也是一種 block container。</p><p>block formatting context (BFC) 在排版中是非常重要的一環，這部分的介紹留在之後文章再詳細說明。</p><br><br><br><br><p>參考資源</p><ol><li><a href="https://www.w3.org/TR/CSS22/visuren.html">W3C-Controlling box generation</a></li><li><a href="https://www.w3.org/TR/css-display-3/#glossary">W3C-Appendix A: Glossary</a></li><li><a href="https://www.w3.org/TR/css-display-3/#the-display-properties">W3C-Box Layout Modes: the display property</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> w3HexSchool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 原理 - Collapsing margins</title>
      <link href="/article/Collapsing-margins.html"/>
      <url>/article/Collapsing-margins.html</url>
      
        <content type="html"><![CDATA[<h2 id="什麼是-Collapsing-margins？"><a class="header-anchor" href="#什麼是-Collapsing-margins？"></a>什麼是 Collapsing margins？</h2><p>先來看一段 <a href="https://www.w3.org/TR/CSS2/box.html#collapsing-margins">W3C 規範</a> 的敘述：</p><blockquote><p>In CSS, the adjoining margins of two or more boxes (which might or might not be siblings) can combine to form a single margin. Margins that combine this way are said to collapse, and the resulting combined margin is called a collapsed margin.</p></blockquote><a id="more"></a><p>簡單來說，當相鄰(adjoining)的 margin 相遇時，若合併成一個 margin，這種情況稱為 Collapsing margins。其中，<a href="https://www.w3.org/TR/CSS2/box.html#collapsing-margins">W3C</a> 對於<code>相鄰(adjoining)</code>的定義為：</p><ul><li><p>僅發生於<code>垂直方向</code><br><br></p></li><li><p>皆為在文檔流中(in flow)的塊級元素(block-level)元素，且參與<code>同一個</code><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">塊格式化上下文(block formatting context，BFC)</a>。</p><p>例如，若是元素會創建新的 BFC，像是根元素 &lt;html&gt; 、float、position: absolute…等等，該元素就不會有 margin collapsing，至於什麼情況下會創建新的 BFC，可參考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">MDN-block formatting context</a>。</p></li></ul><p><br></br></p><h2 id="什麼時候會發生-margin-collapsing？"><a class="header-anchor" href="#什麼時候會發生-margin-collapsing？"></a>什麼時候會發生 margin collapsing？</h2><p>margin collapsing 可分為兩種情況，一種是同層元素之間，另一種是元素與其父(母)容器之間，但並非所有 block-level 元素皆會發生 margin collapsing，而是有前提條件的。</p><h3 id="一-相鄰的兄弟姊妹"><a class="header-anchor" href="#一-相鄰的兄弟姊妹"></a>(一) 相鄰的兄弟姊妹</h3><blockquote><p>同層且相鄰的 block 元素的 margin-bottom 與 margin-top 相遇時，發生重疊，僅發生於垂直方向。</p></blockquote><p><b>前提條件：</b><br>block 須符合相鄰(adjoining)的定義：</p><ul><li>皆為在文檔流中(in flow)的塊級元素(block-level)元素，且參與同一個<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">塊格式化上下文(BFC)</a>。</li></ul><p>例如：兩個相鄰的 block 元素，紅色 block 的 margin-bottom = 30px，黑色 block 的 margin-top = 30px，最終兩個 block 元素之間的距離為 30px，而非 60px。<br><br></br></p><p><a href="https://codepen.io/yachen/pen/xxKmZrd?editors=1100">範例連結</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block1"</span>&gt;</span>我有 margin-bottom：30px<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block2"</span>&gt;</span>我有 margin-top：30px<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block1</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block2</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./Collapsing-margins/demo.png" alt=""></p><p><br></br></p><h3 id="二-容器與其第一個-最後一個子元素"><a class="header-anchor" href="#二-容器與其第一個-最後一個子元素"></a>(二) 容器與其第一個/最後一個子元素</h3><blockquote><p>亦僅發生於垂直方向，且有其前提條件。</p></blockquote><p><b>前提條件:</b></p><ul><li><p>皆為在文檔流中(in flow)的塊級元素(block-level)元素，且參與同一個<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">塊格式化上下文(BFC)</a>。<br><br></p></li><li><p>容器<code>無</code>設定<code>邊框(border)</code>、<code>內距(padding)</code>或加上 <code>clear-fix</code> 的屬性。</p></li></ul><p><br></br></p><p>例如：</p><p>虛線為容器的 outline，紅色區塊為容器內的第一個子元素，現在子元素頂部緊貼著容器頂部。若想利用 margin-top 屬性，讓子元素的頂部距離容器頂部 50px。<br>結果會發現，子元素的頂部並沒有與容器頂部分離！</p><p><a href="https://codepen.io/yachen/pen/ZEzVGRx">範例連結</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"first_child"</span>&gt;</span>容器中的第一個子元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.first_child</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./Collapsing-margins/before-margin-collapsing.png" alt=""></p><p><br></br></p><p>打開開發人員工具檢視一下，會發現子元素的 margin-top 竟然跑出容器外了，這<code>結果與直接在父容器上設定 margin-top: 50px 是一樣的</code>。</p><p><br></br></p><p><img src="./Collapsing-margins/after-margin-collapsing.png" alt=""></p><p><br></br></p><h2 id="解決方法："><a class="header-anchor" href="#解決方法："></a>解決方法：</h2><p>使其不再符合前提條件，例如不再是 block 或是創建 BFC。</p><p><br></br></p><h2 id="margin-計算方式"><a class="header-anchor" href="#margin-計算方式"></a>margin 計算方式</h2><p>當發生 margin collapsing 時，由於外距(margin)可為負數，故會有三種情況：</p><ul><li><p>兩個 margin 皆為正 ⇒ 取大值</p></li><li><p>一個 margin 為正，一個 margin 為負 ⇒ 相加</p></li><li><p>兩個 margin 皆為負 ⇒ 取最小 (最負)</p></li></ul><p><br></br></p><p>參考資料</p><ol><li><a href="https://www.w3.org/TR/CSS2/box.html#collapsing-margins">W3C - Collapsing Margins</a></li><li><a href="https://www.w3.org/TR/css-box-3/">W3C - Box Model</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">MDN - Mastering margin collapsing</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">MDN - Block formatting context</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 原理 - Containing block</title>
      <link href="/article/Containing-block.html"/>
      <url>/article/Containing-block.html</url>
      
        <content type="html"><![CDATA[<p>Containing block，中文常被翻譯為包含塊，它其實代表的是一個「區域」，一個由 box model 的 content edge 或 padding edge (若有設定 padding)所圍繞的範圍，它攸關元素的定位、寬高、內距與外距的計算，所以必須清楚知道元素的 containing block 是誰，才不會使畫面失控。</p><a id="more"></a><p>例如，在元素設定 width、height、padding、margin 屬性時，若屬性值給予的單位為百分比(％)，則將會以該元素的 containing block 為基準去做計算，再例如，元素的 position定位，也與該元素的 containing block 有關。</p><p><img src="./Containing-block/box-model.svg" alt="box model"><br><br></br></p><h2 id="如何尋找包含塊："><a class="header-anchor" href="#如何尋找包含塊："></a>如何尋找包含塊：</h2><p>一個容易犯的錯誤是直接將元素的「父層」視為該元素的 containing block，事實上，在有些情況下並非如此，像是 position: absolute 與 fixed 時。大致情況如下：</p><ul><li><p>根元素 &lt;html&gt; 的 containing block 稱為 initial containing block (初始包含塊)，而在連續媒體下，initial containing block 即為 viewport (視口)。<br><br></p></li><li><p>若元素的 <code>position</code> 屬性值為 <code>static</code>、<code>relative</code> 或 <code>sticky</code>，則 containing block 為距離該元素最近的祖先 block container 或 formatting context (格式化上下文)的 <code>contnet edge (內容區邊緣)</code>組成。</p><p>其中，block container 並不完全等於 display: block，像是 display: inline-block 與 list-item 也會形成 block container，這部分有興趣可參考 <a href="https://www.w3.org/TR/css-display-3/#the-display-properties">W3C display 表格</a>。</p><p>至於 formatting context ，其實它只是一個「環境」，大致可分為幾種環境，像是 block formatting context、flex formatting context 或 grid formatting context，之後有機會再介紹。<br><br></p></li><li><p>若元素 <code>position</code> 屬性值為 <code>absolute</code>，則其 containing block 為距離它<code>最近</code>且 <code>position</code> 屬性值<code>非 static</code>（即為 fixed、absolute、relative 或 sticky）的<code>祖先元素</code>的 <code>padding edge(內距邊緣)</code>組成。<br><br></p></li><li><p>若元素 position 屬性值為 <code>fixed</code>，則其 containing block 在連續媒體下為 <code>viewport</code>。<br><br></p></li><li><p>如果 <code>position</code> 屬性值為 <code>absolute</code> 或 <code>fixed</code>，containing block 也可能是由滿足以下條件的<code>最接近祖先元素</code>的內容區邊緣組成：</p><ul><li>transform 或 perspective 屬性值不為 none。</li><li>filter 屬性值不為 none。</li></ul></li></ul><br><h3 id="來看幾個例子吧"><a class="header-anchor" href="#來看幾個例子吧"></a>來看幾個例子吧</h3><h4 id="例-1"><a class="header-anchor" href="#例-1"></a>例 1.</h4><blockquote><p>找出 &lt;p&gt; 的包含塊，並且計算出 &lt;p&gt; 最終的寬、高、內距與外距。</p></blockquote><p>在此例子中，因為 &lt;p&gt; 的 position 值為預設的 static，故其包含塊為距離它最近的 block container 的 padding edge(內距邊緣)所圍繞範圍，又因 &lt;p&gt; 的 width、 height、margin 與 padding 單位皆為百分比(%)，所以會以 containing block，即 &lt;section&gt; 為基準來計算。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">160px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;   <span class="comment">/* == 400px * .5 = 200px */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">25%</span>;  <span class="comment">/* == 160px * .25 = 40px */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5%</span>;   <span class="comment">/* == 400px * .05 = 20px */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5%</span>;  <span class="comment">/* == 400px * .05 = 20px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="例-2"><a class="header-anchor" href="#例-2"></a>例 2.</h4><blockquote><p>現在將 &lt;section&gt; 改為 display: inline。<br>找出 &lt;p&gt; 的包含塊，並且計算出 &lt;p&gt; 最終的寬度。</p></blockquote><p>在此例子中，&lt;p&gt; 的 position 依舊是預設的 static，但是 &lt;section&gt; 不再是 block container，沒有形成一個格式化上下文，故 &lt;p&gt; 的包含塊為 &lt;body&gt; 內距邊緣所圍範圍。</p><p>&lt;p&gt; 的寬度將以 &lt;body&gt; 為基準計算。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;     <span class="comment">/* == half the &lt;body&gt;'s width */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;  <span class="comment">/* <span class="doctag">Note:</span> a percentage would be 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="例-3"><a class="header-anchor" href="#例-3"></a>例 3.</h4><blockquote><p>包含塊有內距(padding)。<br>找出 &lt;p&gt; 的包含塊，並且計算出 &lt;p&gt; 的最終寬度、高度、外距與內距。</p></blockquote><p>在此例中，P元素的包含塊是 &lt;section&gt;，因為 &lt;section&gt; 的  position 值非 static。<br>&lt;p&gt; 百分值會受其包含塊 &lt;section&gt; 的 padding 所影響。若將包含塊的 box-sizing 值設置為 border-box，就可以避免這個問題。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">160px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;   <span class="comment">/* == (400px + 20px + 20px) * 50% = 220px */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">25%</span>;  <span class="comment">/* == (160px + 30px + 30px) * 25% = 55px */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5%</span>;   <span class="comment">/* == (400px + 20px + 20px) * 5% = 22px */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5%</span>;  <span class="comment">/* == (400px + 20px + 20px) * 5% = 22px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></br><br><br></br></p><p>參考資源</p><ol><li><a href="https://www.w3.org/TR/CSS2/visuren.html#block-boxes">W3C-Containing blocks</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block">MDN-Layout and the containing block</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10220938">每天來點 CSS Specification-Visual Formatting Model - 定義、containing block</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> w3HexSchool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 原理 - Box model</title>
      <link href="/article/box-model.html"/>
      <url>/article/box-model.html</url>
      
        <content type="html"><![CDATA[<p>想像每個元素都是個盒子，而 &lt;html&gt; 就像是個超級大盒子，裡面裝了許許多多大小不一的盒子，像是 &lt;div&gt;、&lt;p&gt;、&lt;span&gt;、&lt;button&gt;…等等，而每個盒子由四個部分組成。</p><a id="more"></a><p>如下圖所示，box model 由四個部分組成，由內至外依序為</p><ul><li>content area (內容區)</li><li>padding (內距)</li><li>border (邊框)</li><li>margin (外距)</li></ul><p><img src="./box-model/box-model.svg" alt="box model"></p><h2 id="content-area"><a class="header-anchor" href="#content-area"></a>content area</h2><p>內容區域，也就是盒子裡裝的東西，可能是文字、圖片或是又裝了其它元素(其他盒子)，例如 &lt;div&gt;、&lt;p&gt;、&lt;span&gt;、&lt;button&gt;…等等。</p><br><br><h2 id="padding-內距"><a class="header-anchor" href="#padding-內距"></a>padding (內距)</h2><p>可想像成盒子和其內容物的距離，介於 content area(內容區) 與 border(邊框)之間的部分。其特色為</p><ul><li><p>厚度取決於 padding 屬性，</p></li><li><p>不能為負值。</p></li><li><p>預設下，padding 不包含在屬性 width 的範圍，因 box-sizing 預設值為 content-box，當然只包含最裡面的 content 部分。</p></li></ul><br><br><h2 id="border-邊框"><a class="header-anchor" href="#border-邊框"></a>border (邊框)</h2><p>介於 margin (外距)與 padding(內距) 之間的範圍。</p><ul><li><p>可以使用 border 屬性來設置邊框的寬度、樣式與顏色。<br>三合一縮寫語法 (三個值的順序可以互換)：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border</span>: <span class="selector-tag">border-width</span>｜<span class="selector-tag">border-style</span>｜<span class="selector-tag">border-color</span></span><br></pre></td></tr></table></figure><p>亦可單獨指 定border 的寬度、樣式與顏色。個別屬性如下：</p><ul><li>border-width (邊框寬度)</li><li>border-style (邊框樣式)</li><li>border-color (邊框顏色)<br><br></li></ul></li><li><p>預設情況下，不包含在 width 與 height 的範圍內。</p></li></ul><br><br><h2 id="margin-外距"><a class="header-anchor" href="#margin-外距"></a>margin (外距)</h2><p>margin 圍繞於 border 之外，用於推開元素與其它元素之間的距離。其特色為</p><ul><li><p>厚度取決於 margin 屬性。</p></li><li><p>可以是正值或負值，但若為負值，可能會與其它元素重疊。</p></li><li><p>元素本身的背景設定無法渲染至 margin 部分，例如 background-color 或 background-image。</p></li><li><p>不包含在 width 與 height 範圍內。</p></li></ul><br><br><br><h2 id="box-sizing"><a class="header-anchor" href="#box-sizing"></a>box-sizing</h2><p>一個新手常遇見的問題：奇怪，明明指定了元素的 width 與 height，但元素渲染於畫面上的寬度與高度卻比自己設定的值來得大？</p><p>這問題通常與 box-sizing 有關。</p><p>box-sizing 屬性決定如何計算一個元素渲染於畫面上的總寬度與總高度，也就是 size，有 content-box 與 border-box 兩種屬性值。</p><br><h3 id="一-content-box"><a class="header-anchor" href="#一-content-box"></a>(一) content-box</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">content-box</span>；</span><br></pre></td></tr></table></figure><p>content-box 為預設值，如同字面上的意思，若該元素可以指定 width 與 height，則在設定 width 或 height 時，其指定的僅為最內層的 content 部分，例如 width: 100px，則代表元素的 content area 寬度為 100px。</p><p>如果同時還設定了 padding 或是 border，則必須再加上 padding 與 border，才是最終渲染於畫面上的寬度或高度。</p><br><p>例如： 給定一個 div 的設定如下：<br><a href="https://codepen.io/yachen/pen/oNvQpgG?editors=1100">codepen 範例連結</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: content-box; <span class="comment">/*預設值*/</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>則在 <code>content-box</code> 下：<br><br>最終渲染寬度 ≠ width 200px<br><br>而是 ( width 200 + 左右 padding 20*2 + 左右 border 10*2 )px = 260px ;<br></p><p>最終渲染高度 ≠ height 100px<br><br>而是( height 100 + 上下 padding 20*2 + 上下 border 10*2 )px = 160px。</p><p><img src="./box-model/content-box.png" alt="content-box"></p><br><br><h3 id="二-border-box"><a class="header-anchor" href="#二-border-box"></a>(二) border-box</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br></pre></td></tr></table></figure><p>如同字面上的意思，若該元素可以指定 width 與 height，則 width 和 height 屬性值涵蓋的範圍為 border 以內，也就是 content、padding 和 border，注意，不包括 margin。</p><p>border-box 可以使元素渲染於畫面上的總寬度與總高度的計算變得較直覺簡單，不必再額外加上 padding 和 border，連 bootstrap 也對所有元素做了此設定。</p><br><p>例如： 給定一個 div 的設定如下：<br>在 <code>border-box</code> 下：<br><br>最終渲染寬度即為 width 200px ;<br><br>最終渲染高度即為 height 100px。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./box-model/border-box.png" alt="border-box"></p><br><br><br><br><p>參考資料</p><ol><li><a href="https://www.w3.org/TR/css-box-3/">W3C - CSS Box Model Module Level 3</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model">MDN - The box model</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing">MDN - box-sizing</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
